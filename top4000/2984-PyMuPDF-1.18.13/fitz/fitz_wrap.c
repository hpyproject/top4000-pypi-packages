/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGPYTHON
#define SWIGPYTHON
#endif

#define SWIG_PYTHON_DIRECTOR_NO_VTABLE

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
/* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
# include <math.h>
#endif

#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */
# undef _DEBUG
# include <Python.h>
# define _DEBUG 1
#else
# include <Python.h>
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
#define PyString_Check(name) PyBytes_Check(name)
#define PyString_FromString(x) PyUnicode_FromString(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
#define PyString_AsString(str) PyBytes_AsString(str)
#define PyString_Size(str) PyBytes_Size(str)	
#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03030000
  return (char *)PyUnicode_AsUTF8(str);
#elif PY_VERSION_HEX >= 0x03000000
  char *newstr = 0;
  str = PyUnicode_AsUTF8String(str);
  if (str) {
    char *cstr;
    Py_ssize_t len;
    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
      newstr = (char *) malloc(len+1);
      if (newstr)
        memcpy(newstr, cstr, len+1);
    }
    Py_XDECREF(str);
  }
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
#  define SWIG_Python_str_DelForPy3(x)
#else
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
// interface files check for it.
# define SWIGPY_USE_CAPSULE
# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)

#if PY_VERSION_HEX < 0x03020000
#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
#define Py_hash_t long
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred())
    PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    PyObject *old_str = PyObject_Str(value);
    const char *tmp = SWIG_Python_str_AsChar(old_str);
    PyErr_Clear();
    Py_XINCREF(type);
    if (tmp)
      PyErr_Format(type, "%s %s", tmp, mesg);
    else
      PyErr_Format(type, "%s", mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

SWIGRUNTIME int
SWIG_Python_TypeErrorOccurred(PyObject *obj)
{
  PyObject *error;
  if (obj)
    return 0;
  error = PyErr_Occurred();
  return error && PyErr_GivenExceptionMatches(error, PyExc_TypeError);
}

SWIGRUNTIME void
SWIG_Python_RaiseOrModifyTypeError(const char *message)
{
  if (SWIG_Python_TypeErrorOccurred(NULL)) {
    /* Use existing TypeError to preserve stacktrace and enhance with given message */
    PyObject *newvalue;
    PyObject *type = NULL, *value = NULL, *traceback = NULL;
    PyErr_Fetch(&type, &value, &traceback);
#if PY_VERSION_HEX >= 0x03000000
    newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
#else
    newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
#endif
    Py_XDECREF(value);
    PyErr_Restore(type, newvalue, traceback);
  } else {
    /* Raise TypeError using given message */
    PyErr_SetString(PyExc_TypeError, message);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    define SWIG_PYTHON_USE_GIL
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  const char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

#if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
# error "This version of SWIG only supports Python >= 2.7"
#endif

#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
# error "This version of SWIG only supports Python 3 >= 3.2"
#endif

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)

#ifdef SWIGPYTHON_BUILTIN
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
#else
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
#endif

#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)

#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

#if defined(SWIGPYTHON_BUILTIN)

SWIGINTERN void
SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
  PyObject *s = PyString_InternFromString(key);
  PyList_Append(seq, s);
  Py_DECREF(s);
}

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  Py_DECREF(obj);
  if (public_interface)
    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
}

#else

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  Py_DECREF(obj);                            
}

#endif

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
}

/* Unpack the argument tuple */

SWIGINTERN Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

SWIGINTERN int
SWIG_Python_CheckNoKeywords(PyObject *kwargs, const char *name) {
  int no_kwargs = 1;
  if (kwargs) {
    assert(PyDict_Check(kwargs));
    if (PyDict_Size(kwargs) > 0) {
      PyErr_Format(PyExc_TypeError, "%s() does not take keyword arguments", name);
      no_kwargs = 0;
    }
  }
  return no_kwargs;
}

/* A functor is a function object with one single object argument */
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)

#ifdef __cplusplus
extern "C" {
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  int fail = data ? data->implicitconv : 0;
  if (fail)
    PyErr_SetString(PyExc_TypeError, "Implicit conversion is prohibited for explicit constructors.");
  return fail;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
      data->newraw = PyObject_GetAttrString(data->klass, "__new__");
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
      data->delargs = !(flags & (METH_O));
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData *data) {
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
#ifdef SWIGPYTHON_BUILTIN
  PyObject *dict;
#endif
} SwigPyObject;


#ifdef SWIGPYTHON_BUILTIN

SWIGRUNTIME PyObject *
SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;

  if (!sobj->dict)
    sobj->dict = PyDict_New();

  Py_INCREF(sobj->dict);
  return sobj->dict;
}

#endif

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_repr(SwigPyObject *v)
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (v->next) {
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
# if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
# else
    PyString_ConcatAndDel(&repr,nrep);
# endif
  }
  return repr;  
}

/* We need a version taking two PyObject* parameters so it's a valid
 * PyCFunction to use in swigobject_methods[]. */
SWIGRUNTIME PyObject *
SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  return SwigPyObject_repr((SwigPyObject*)v);
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
  return res;  
}


SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);

#ifdef SWIGPYTHON_BUILTIN
static swig_type_info *SwigPyObject_stype = 0;
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
    SwigPyClientData *cd;
    assert(SwigPyObject_stype);
    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
    assert(cd);
    assert(cd->pytype);
    return cd->pytype;
}
#else
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
  return type;
}
#endif

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
#ifdef SWIGPYTHON_BUILTIN
  PyTypeObject *target_tp = SwigPyObject_type();
  if (PyType_IsSubtype(op->ob_type, target_tp))
    return 1;
  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
#else
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
#endif
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *type = NULL, *value = NULL, *traceback = NULL;
      PyErr_Fetch(&type, &value, &traceback);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        res = SWIG_Python_CallFunctor(destroy, tmp);
        Py_DECREF(tmp);
      } else {
        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
        PyObject *mself = PyCFunction_GET_SELF(destroy);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(type, value, traceback);

      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
    return NULL;
  } else {
    SwigPyObject *sobj = (SwigPyObject *)v;
    PyObject *obj = PyBool_FromLong(sobj->own);
    if (val) {
      if (PyObject_IsTrue(val)) {
        SwigPyObject_acquire(v,args);
      } else {
        SwigPyObject_disown(v,args);
      }
    } 
    return obj;
  }
}

static PyMethodDef
swigobject_methods[] = {
  {"disown",  SwigPyObject_disown,  METH_NOARGS,  "releases ownership of the pointer"},
  {"acquire", SwigPyObject_acquire, METH_NOARGS,  "acquires ownership of the pointer"},
  {"own",     SwigPyObject_own,     METH_VARARGS, "returns/sets ownership of the pointer"},
  {"append",  SwigPyObject_append,  METH_O,       "appends another 'this' object"},
  {"next",    SwigPyObject_next,    METH_NOARGS,  "returns the next 'this' object"},
  {"__repr__",SwigPyObject_repr2,   METH_NOARGS,  "returns object representation"},
  {0, 0, 0, 0}  
};

SWIGRUNTIME PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03050000 /* 3.5 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */
#elif PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#else
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#endif
  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      "SwigPyObject",                       /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
      0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,                                    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
      0,                                    /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
      0,                                    /* tp_print */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
      0,                                    /* tp_prev */
      0                                     /* tp_next */
#endif
    };
    swigpyobject_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpyobject_type) < 0)
      return NULL;
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((const char *)v->pack, (const char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX>=0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      "SwigPyPacked",                       /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX>=0x03000000
      0, /* tp_reserved in 3.0.1 */
#else
      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
      0,                                    /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
      0,                                    /* tp_print */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
      0,                                    /* tp_prev */
      0                                     /* tp_next */
#endif
    };
    swigpypacked_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpypacked_type) < 0)
      return NULL;
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

static PyObject *Swig_This_global = NULL;

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  if (Swig_This_global == NULL)
    Swig_This_global = SWIG_Python_str_FromChar("this");
  return Swig_This_global;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;

#ifdef SWIGPYTHON_BUILTIN
  (void)obj;
# ifdef PyWeakref_CheckProxy
  if (PyWeakref_CheckProxy(pyobj)) {
    pyobj = PyWeakref_GET_OBJECT(pyobj);
    if (pyobj && SwigPyObject_Check(pyobj))
      return (SwigPyObject*) pyobj;
  }
# endif
  return NULL;
#else

  obj = 0;

#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
  if (PyInstance_Check(pyobj)) {
    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
  } else {
    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
    if (dictptr != NULL) {
      PyObject *dict = *dictptr;
      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
    } else {
#ifdef PyWeakref_CheckProxy
      if (PyWeakref_CheckProxy(pyobj)) {
	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
      }
#endif
      obj = PyObject_GetAttr(pyobj,SWIG_This());
      if (obj) {
	Py_DECREF(obj);
      } else {
	if (PyErr_Occurred()) PyErr_Clear();
	return 0;
      }
    }
  }
#else
  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    Py_DECREF(obj);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }
#endif
  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;
#endif
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;

  if (!obj)
    return SWIG_ERROR;
  if (obj == Py_None && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;
  }

  res = SWIG_ERROR;

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == SWIG_CAST_NEW_MEMORY) {
              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | SWIG_CAST_NEW_MEMORY;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (own)
      *own = *own | sobj->own;
    if (flags & SWIG_POINTER_DISOWN) {
      sobj->own = 0;
    }
    res = SWIG_OK;
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = SWIG_Python_CallFunctor(klass, obj);
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if (SWIG_IsOK(res)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = SWIG_AddCast(res);
                  res = SWIG_AddNewMask(res);
                } else {
                  res = SWIG_AddCast(res);		    
                }
              }
            }
            Py_DECREF(impconv);
          }
        }
      }
      if (!SWIG_IsOK(res) && obj == Py_None) {
        if (ptr)
          *ptr = 0;
        if (PyErr_Occurred())
          PyErr_Clear();
        res = SWIG_OK;
      }
    }
  }
  return res;
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    swig_cast_info *tc;

    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc)
      return SWIG_ERROR;
    tc = SWIG_TypeCheck(desc,ty);
    if (tc) {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    } else {
      return SWIG_ERROR;
    }
    return SWIG_OK;
  }
}

/* Convert a packed pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
        Py_DECREF(inst);
        inst = 0;
      }
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *empty_args = PyTuple_New(0);
    if (empty_args) {
      PyObject *empty_kwargs = PyDict_New();
      if (empty_kwargs) {
        inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
        Py_DECREF(empty_kwargs);
        if (inst) {
          if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
            Py_DECREF(inst);
            inst = 0;
          } else {
            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
          }
        }
      }
      Py_DECREF(empty_args);
    }
#else
    PyObject *dict = PyDict_New();
    if (dict) {
      PyDict_SetItem(dict, SWIG_This(), swig_this);
      inst = PyInstance_NewRaw(data->newargs, dict);
      Py_DECREF(dict);
    }
#endif
  }
  return inst;
}

SWIGRUNTIME int
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
  PyObject **dictptr = _PyObject_GetDictPtr(inst);
  if (dictptr != NULL) {
    PyObject *dict = *dictptr;
    if (dict == NULL) {
      dict = PyDict_New();
      *dictptr = dict;
    }
    return PyDict_SetItem(dict, SWIG_This(), swig_this);
  }
#endif
  return PyObject_SetAttr(inst, SWIG_This(), swig_this);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
        return NULL;
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & SWIG_BUILTIN_TP_INIT) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;
#ifdef SWIGPYTHON_BUILTIN
        newobj->dict = 0;
#endif
      }
    } else {
      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
#ifdef SWIGPYTHON_BUILTIN
      newobj->dict = 0;
#endif
    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  assert(!(flags & SWIG_BUILTIN_TP_INIT));

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    Py_DECREF(robj);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

SWIGRUNTIME void
SWIG_Python_DestroyModule(PyObject *obj)
{
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
  Swig_This_global = NULL;
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
  PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
#endif
  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
  } else {
    swig_module_info *swig_module = SWIG_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      PyObject *old_str = PyObject_Str(value);
      const char *tmp = SWIG_Python_str_AsChar(old_str);
      const char *errmesg = tmp ? tmp : "Invalid error message";
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, errmesg);
      } else {
	PyErr_Format(type, "%s %s", errmesg, mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}

#ifdef SWIGPYTHON_BUILTIN
SWIGRUNTIME int
SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
  PyTypeObject *tp = obj->ob_type;
  PyObject *descr;
  PyObject *encoded_name;
  descrsetfunc f;
  int res = -1;

# ifdef Py_USING_UNICODE
  if (PyString_Check(name)) {
    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
    if (!name)
      return -1;
  } else if (!PyUnicode_Check(name))
# else
  if (!PyString_Check(name))
# endif
  {
    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
    return -1;
  } else {
    Py_INCREF(name);
  }

  if (!tp->tp_dict) {
    if (PyType_Ready(tp) < 0)
      goto done;
  }

  descr = _PyType_Lookup(tp, name);
  f = NULL;
  if (descr != NULL)
    f = descr->ob_type->tp_descr_set;
  if (!f) {
    if (PyString_Check(name)) {
      encoded_name = name;
      Py_INCREF(name);
    } else {
      encoded_name = PyUnicode_AsUTF8String(name);
      if (!encoded_name)
        return -1;
    }
    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
    Py_DECREF(encoded_name);
  } else {
    res = f(descr, obj, value);
  }
  
  done:
  Py_DECREF(name);
  return res;
}
#endif


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



#ifdef __cplusplus
extern "C" {
#endif

/* Method creation and docstring support functions */

SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);

#ifdef __cplusplus
}
#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Annot swig_types[0]
#define SWIGTYPE_p_Colorspace swig_types[1]
#define SWIGTYPE_p_DeviceWrapper swig_types[2]
#define SWIGTYPE_p_DisplayList swig_types[3]
#define SWIGTYPE_p_Document swig_types[4]
#define SWIGTYPE_p_Font swig_types[5]
#define SWIGTYPE_p_Graftmap swig_types[6]
#define SWIGTYPE_p_Link swig_types[7]
#define SWIGTYPE_p_Outline swig_types[8]
#define SWIGTYPE_p_Page swig_types[9]
#define SWIGTYPE_p_Pixmap swig_types[10]
#define SWIGTYPE_p_TextPage swig_types[11]
#define SWIGTYPE_p_TextWriter swig_types[12]
#define SWIGTYPE_p_Tools swig_types[13]
#define SWIGTYPE_p_char swig_types[14]
static swig_type_info *swig_types[16];
static swig_module_info swig_module = {swig_types, 15, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#ifdef SWIG_TypeQuery
# undef SWIG_TypeQuery
#endif
#define SWIG_TypeQuery SWIG_Python_TypeQuery

/*-----------------------------------------------
              @(target):= _fitz.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__fitz

#else
#  define SWIG_init    init_fitz

#endif
#define SWIG_name    "_fitz"

#define SWIGVERSION 0x040002 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 


#define MEMDEBUG 0
#if MEMDEBUG == 1
    #define DEBUGMSG1(x) PySys_WriteStderr("[DEBUG] free %s ", x)
    #define DEBUGMSG2 PySys_WriteStderr("... done!\n")
#else
    #define DEBUGMSG1(x)
    #define DEBUGMSG2
#endif

#ifndef FLT_EPSILON
  #define FLT_EPSILON 1e-5
#endif

#define SWIG_FILE_WITH_INIT
#define SWIG_PYTHON_2_UNICODE

// memory allocation macros
#define JM_MEMORY 1

#if JM_MEMORY == 1
    #define JM_Alloc(type, len) PyMem_New(type, len)
    #define JM_Free(x) PyMem_Del(x)
#else
    #define JM_Alloc(type, len) (type *) malloc(sizeof(type)*len)
    #define JM_Free(x) free(x)
#endif

#define EMPTY_STRING PyUnicode_FromString("")
#define EXISTS(x) (x != NULL && PyObject_IsTrue(x)==1)
#define THROWMSG(gctx, msg) fz_throw(gctx, FZ_ERROR_GENERIC, msg)
#define ASSERT_PDF(cond) if (cond == NULL) fz_throw(gctx, FZ_ERROR_GENERIC, "not a PDF")
#define INRANGE(v, low, high) ((low) <= v && v <= (high))
#define MAX(a, b) ((a) < (b)) ? (b) : (a)
#define MIN(a, b) ((a) < (b)) ? (a) : (b)

#define JM_PyErr_Clear if (PyErr_Occurred()) PyErr_Clear()

#define JM_StrAsChar(x) (char *)PyUnicode_AsUTF8(x)
#define JM_BinFromChar(x) PyBytes_FromString(x)
#define JM_BinFromCharSize(x, y) PyBytes_FromStringAndSize(x, (Py_ssize_t) y)

#include <fitz.h>
#include <pdf.h>
#include <time.h>
// freetype includes >> --------------------------------------------------
#include <ft2build.h>
#include FT_FREETYPE_H
#ifdef FT_FONT_FORMATS_H
#include FT_FONT_FORMATS_H
#else
#include FT_XFREE86_H
#endif
#include FT_TRUETYPE_TABLES_H

#ifndef FT_SFNT_HEAD
#define FT_SFNT_HEAD ft_sfnt_head
#endif
// << freetype includes --------------------------------------------------

void JM_delete_widget(fz_context *ctx, pdf_page *page, pdf_annot *annot);
static void JM_get_page_labels(fz_context *ctx, PyObject *liste, pdf_obj *nums);

// additional headers ----------------------------------------------
pdf_obj *pdf_lookup_page_loc(fz_context *ctx, pdf_document *doc, int needle, pdf_obj **parentp, int *indexp);
fz_pixmap *fz_scale_pixmap(fz_context *ctx, fz_pixmap *src, float x, float y, float w, float h, const fz_irect *clip);
int fz_pixmap_size(fz_context *ctx, fz_pixmap *src);
void fz_subsample_pixmap(fz_context *ctx, fz_pixmap *tile, int factor);
void fz_copy_pixmap_rect(fz_context *ctx, fz_pixmap *dest, fz_pixmap *src, fz_irect b, const fz_default_colorspaces *default_cs);
static const float JM_font_ascender(fz_context *ctx, fz_font *font);
static const float JM_font_descender(fz_context *ctx, fz_font *font);

// end of additional headers --------------------------------------------

PyObject *JM_mupdf_warnings_store;
static int JM_mupdf_show_errors;
static int JM_mupdf_show_warnings;



fz_context *gctx;
static int JM_UNIQUE_ID = 0;

struct DeviceWrapper {
    fz_device *device;
    fz_display_list *list;
};


//----------------------------------------------------------------------------
// general
//----------------------------------------------------------------------------
#define EPSILON 1e-5

//----------------------------------------------------------------------------
// annotation types
//----------------------------------------------------------------------------
#define PDF_ANNOT_TEXT 0
#define PDF_ANNOT_LINK 1
#define PDF_ANNOT_FREE_TEXT 2
#define PDF_ANNOT_LINE 3
#define PDF_ANNOT_SQUARE 4
#define PDF_ANNOT_CIRCLE 5
#define PDF_ANNOT_POLYGON 6
#define PDF_ANNOT_POLY_LINE 7
#define PDF_ANNOT_HIGHLIGHT 8
#define PDF_ANNOT_UNDERLINE 9
#define PDF_ANNOT_SQUIGGLY 10
#define PDF_ANNOT_STRIKE_OUT 11
#define PDF_ANNOT_REDACT 12
#define PDF_ANNOT_STAMP 13
#define PDF_ANNOT_CARET 14
#define PDF_ANNOT_INK 15
#define PDF_ANNOT_POPUP 16
#define PDF_ANNOT_FILE_ATTACHMENT 17
#define PDF_ANNOT_SOUND 18
#define PDF_ANNOT_MOVIE 19
#define PDF_ANNOT_RICH_MEDIA 20
#define PDF_ANNOT_WIDGET 21
#define PDF_ANNOT_SCREEN 22
#define PDF_ANNOT_PRINTER_MARK 23
#define PDF_ANNOT_TRAP_NET 24
#define PDF_ANNOT_WATERMARK 25
#define PDF_ANNOT_3D 26
#define PDF_ANNOT_PROJECTION 27
#define PDF_ANNOT_UNKNOWN -1

//------------------------
// redaction annot options
//------------------------
#define PDF_REDACT_IMAGE_NONE 0
#define PDF_REDACT_IMAGE_REMOVE 1
#define PDF_REDACT_IMAGE_PIXELS 2

//----------------------------------------------------------------------------
// annotation flag bits
//----------------------------------------------------------------------------
#define PDF_ANNOT_IS_INVISIBLE 1 << (1-1)
#define PDF_ANNOT_IS_HIDDEN 1 << (2-1)
#define PDF_ANNOT_IS_PRINT 1 << (3-1)
#define PDF_ANNOT_IS_NO_ZOOM 1 << (4-1)
#define PDF_ANNOT_IS_NO_ROTATE 1 << (5-1)
#define PDF_ANNOT_IS_NO_VIEW 1 << (6-1)
#define PDF_ANNOT_IS_READ_ONLY 1 << (7-1)
#define PDF_ANNOT_IS_LOCKED 1 << (8-1)
#define PDF_ANNOT_IS_TOGGLE_NO_VIEW 1 << (9-1)
#define PDF_ANNOT_IS_LOCKED_CONTENTS 1 << (10-1)


//----------------------------------------------------------------------------
// annotation line ending styles
//----------------------------------------------------------------------------
#define PDF_ANNOT_LE_NONE 0
#define PDF_ANNOT_LE_SQUARE 1
#define PDF_ANNOT_LE_CIRCLE 2
#define PDF_ANNOT_LE_DIAMOND 3
#define PDF_ANNOT_LE_OPEN_ARROW 4
#define PDF_ANNOT_LE_CLOSED_ARROW 5
#define PDF_ANNOT_LE_BUTT 6
#define PDF_ANNOT_LE_R_OPEN_ARROW 7
#define PDF_ANNOT_LE_R_CLOSED_ARROW 8
#define PDF_ANNOT_LE_SLASH 9


//----------------------------------------------------------------------------
// annotation field (widget) types
//----------------------------------------------------------------------------
#define PDF_WIDGET_TYPE_UNKNOWN 0
#define PDF_WIDGET_TYPE_BUTTON 1
#define PDF_WIDGET_TYPE_CHECKBOX 2
#define PDF_WIDGET_TYPE_COMBOBOX 3
#define PDF_WIDGET_TYPE_LISTBOX 4
#define PDF_WIDGET_TYPE_RADIOBUTTON 5
#define PDF_WIDGET_TYPE_SIGNATURE 6
#define PDF_WIDGET_TYPE_TEXT 7


//----------------------------------------------------------------------------
// annotation text widget subtypes
//----------------------------------------------------------------------------
#define PDF_WIDGET_TX_FORMAT_NONE 0
#define PDF_WIDGET_TX_FORMAT_NUMBER 1
#define PDF_WIDGET_TX_FORMAT_SPECIAL 2
#define PDF_WIDGET_TX_FORMAT_DATE 3
#define PDF_WIDGET_TX_FORMAT_TIME 4


//----------------------------------------------------------------------------
// annotation widget flags
//----------------------------------------------------------------------------
// Common to all field types
#define PDF_FIELD_IS_READ_ONLY 1
#define PDF_FIELD_IS_REQUIRED 1 << 1
#define PDF_FIELD_IS_NO_EXPORT 1 << 2


// Text fields
#define PDF_TX_FIELD_IS_MULTILINE  1 << 12
#define PDF_TX_FIELD_IS_PASSWORD  1 << 13
#define PDF_TX_FIELD_IS_FILE_SELECT  1 << 20
#define PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK  1 << 22
#define PDF_TX_FIELD_IS_DO_NOT_SCROLL  1 << 23
#define PDF_TX_FIELD_IS_COMB  1 << 24
#define PDF_TX_FIELD_IS_RICH_TEXT  1 << 25


// Button fields
#define PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF  1 << 14
#define PDF_BTN_FIELD_IS_RADIO  1 << 15
#define PDF_BTN_FIELD_IS_PUSHBUTTON  1 << 16
#define PDF_BTN_FIELD_IS_RADIOS_IN_UNISON  1 << 25


// Choice fields
#define PDF_CH_FIELD_IS_COMBO  1 << 17
#define PDF_CH_FIELD_IS_EDIT  1 << 18
#define PDF_CH_FIELD_IS_SORT  1 << 19
#define PDF_CH_FIELD_IS_MULTI_SELECT  1 << 21
#define PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK  1 << 22
#define PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE  1 << 26


// Signature fields errors
#define PDF_SIGNATURE_ERROR_OKAY 0
#define PDF_SIGNATURE_ERROR_NO_SIGNATURES 1
#define PDF_SIGNATURE_ERROR_NO_CERTIFICATE 2
#define PDF_SIGNATURE_ERROR_DIGEST_FAILURE 3
#define PDF_SIGNATURE_ERROR_SELF_SIGNED 4
#define PDF_SIGNATURE_ERROR_SELF_SIGNED_IN_CHAIN 5
#define PDF_SIGNATURE_ERROR_NOT_TRUSTED 6
#define PDF_SIGNATURE_ERROR_UNKNOWN 7


//----------------------------------------------------------------------------
// colorspace identifiers
//----------------------------------------------------------------------------
#define CS_RGB  1
#define CS_GRAY 2
#define CS_CMYK 3

//----------------------------------------------------------------------------
// PDF encryption algorithms
//----------------------------------------------------------------------------
#define PDF_ENCRYPT_KEEP 0
#define PDF_ENCRYPT_NONE 1
#define PDF_ENCRYPT_RC4_40 2
#define PDF_ENCRYPT_RC4_128 3
#define PDF_ENCRYPT_AES_128 4
#define PDF_ENCRYPT_AES_256 5
#define PDF_ENCRYPT_UNKNOWN 6

//----------------------------------------------------------------------------
// PDF permission codes
//----------------------------------------------------------------------------
#define PDF_PERM_PRINT 1 << 2
#define PDF_PERM_MODIFY 1 << 3
#define PDF_PERM_COPY 1 << 4
#define PDF_PERM_ANNOTATE 1 << 5
#define PDF_PERM_FORM 1 << 8
#define PDF_PERM_ACCESSIBILITY 1 << 9
#define PDF_PERM_ASSEMBLE 1 << 10
#define PDF_PERM_PRINT_HQ 1 << 11

//----------------------------------------------------------------------------
// PDF Blend Modes
//----------------------------------------------------------------------------
#define PDF_BM_Color "Color"
#define PDF_BM_ColorBurn "ColorBurn"
#define PDF_BM_ColorDodge "ColorDodge"
#define PDF_BM_Darken "Darken"
#define PDF_BM_Difference "Difference"
#define PDF_BM_Exclusion "Exclusion"
#define PDF_BM_HardLight "HardLight"
#define PDF_BM_Hue "Hue"
#define PDF_BM_Lighten "Lighten"
#define PDF_BM_Luminosity "Luminosity"
#define PDF_BM_Multiply "Multiply"
#define PDF_BM_Normal "Normal"
#define PDF_BM_Overlay "Overlay"
#define PDF_BM_Saturation "Saturation"
#define PDF_BM_Screen "Screen"
#define PDF_BM_SoftLight "Softlight"


// General text flags
#define TEXT_FONT_SUPERSCRIPT 1
#define TEXT_FONT_ITALIC 2
#define TEXT_FONT_SERIFED 4
#define TEXT_FONT_MONOSPACED 8
#define TEXT_FONT_BOLD 16

// UCDN Script codes
#define UCDN_SCRIPT_COMMON 0
#define UCDN_SCRIPT_LATIN 1
#define UCDN_SCRIPT_GREEK 2
#define UCDN_SCRIPT_CYRILLIC 3
#define UCDN_SCRIPT_ARMENIAN 4
#define UCDN_SCRIPT_HEBREW 5
#define UCDN_SCRIPT_ARABIC 6
#define UCDN_SCRIPT_SYRIAC 7
#define UCDN_SCRIPT_THAANA 8
#define UCDN_SCRIPT_DEVANAGARI 9
#define UCDN_SCRIPT_BENGALI 10
#define UCDN_SCRIPT_GURMUKHI 11
#define UCDN_SCRIPT_GUJARATI 12
#define UCDN_SCRIPT_ORIYA 13
#define UCDN_SCRIPT_TAMIL 14
#define UCDN_SCRIPT_TELUGU 15
#define UCDN_SCRIPT_KANNADA 16
#define UCDN_SCRIPT_MALAYALAM 17
#define UCDN_SCRIPT_SINHALA 18
#define UCDN_SCRIPT_THAI 19
#define UCDN_SCRIPT_LAO 20
#define UCDN_SCRIPT_TIBETAN 21
#define UCDN_SCRIPT_MYANMAR 22
#define UCDN_SCRIPT_GEORGIAN 23
#define UCDN_SCRIPT_HANGUL 24
#define UCDN_SCRIPT_ETHIOPIC 25
#define UCDN_SCRIPT_CHEROKEE 26
#define UCDN_SCRIPT_CANADIAN_ABORIGINAL 27
#define UCDN_SCRIPT_OGHAM 28
#define UCDN_SCRIPT_RUNIC 29
#define UCDN_SCRIPT_KHMER 30
#define UCDN_SCRIPT_MONGOLIAN 31
#define UCDN_SCRIPT_HIRAGANA 32
#define UCDN_SCRIPT_KATAKANA 33
#define UCDN_SCRIPT_BOPOMOFO 34
#define UCDN_SCRIPT_HAN 35
#define UCDN_SCRIPT_YI 36
#define UCDN_SCRIPT_OLD_ITALIC 37
#define UCDN_SCRIPT_GOTHIC 38
#define UCDN_SCRIPT_DESERET 39
#define UCDN_SCRIPT_INHERITED 40
#define UCDN_SCRIPT_TAGALOG 41
#define UCDN_SCRIPT_HANUNOO 42
#define UCDN_SCRIPT_BUHID 43
#define UCDN_SCRIPT_TAGBANWA 44
#define UCDN_SCRIPT_LIMBU 45
#define UCDN_SCRIPT_TAI_LE 46
#define UCDN_SCRIPT_LINEAR_B 47
#define UCDN_SCRIPT_UGARITIC 48
#define UCDN_SCRIPT_SHAVIAN 49
#define UCDN_SCRIPT_OSMANYA 50
#define UCDN_SCRIPT_CYPRIOT 51
#define UCDN_SCRIPT_BRAILLE 52
#define UCDN_SCRIPT_BUGINESE 53
#define UCDN_SCRIPT_COPTIC 54
#define UCDN_SCRIPT_NEW_TAI_LUE 55
#define UCDN_SCRIPT_GLAGOLITIC 56
#define UCDN_SCRIPT_TIFINAGH 57
#define UCDN_SCRIPT_SYLOTI_NAGRI 58
#define UCDN_SCRIPT_OLD_PERSIAN 59
#define UCDN_SCRIPT_KHAROSHTHI 60
#define UCDN_SCRIPT_BALINESE 61
#define UCDN_SCRIPT_CUNEIFORM 62
#define UCDN_SCRIPT_PHOENICIAN 63
#define UCDN_SCRIPT_PHAGS_PA 64
#define UCDN_SCRIPT_NKO 65
#define UCDN_SCRIPT_SUNDANESE 66
#define UCDN_SCRIPT_LEPCHA 67
#define UCDN_SCRIPT_OL_CHIKI 68
#define UCDN_SCRIPT_VAI 69
#define UCDN_SCRIPT_SAURASHTRA 70
#define UCDN_SCRIPT_KAYAH_LI 71
#define UCDN_SCRIPT_REJANG 72
#define UCDN_SCRIPT_LYCIAN 73
#define UCDN_SCRIPT_CARIAN 74
#define UCDN_SCRIPT_LYDIAN 75
#define UCDN_SCRIPT_CHAM 76
#define UCDN_SCRIPT_TAI_THAM 77
#define UCDN_SCRIPT_TAI_VIET 78
#define UCDN_SCRIPT_AVESTAN 79
#define UCDN_SCRIPT_EGYPTIAN_HIEROGLYPHS 80
#define UCDN_SCRIPT_SAMARITAN 81
#define UCDN_SCRIPT_LISU 82
#define UCDN_SCRIPT_BAMUM 83
#define UCDN_SCRIPT_JAVANESE 84
#define UCDN_SCRIPT_MEETEI_MAYEK 85
#define UCDN_SCRIPT_IMPERIAL_ARAMAIC 86
#define UCDN_SCRIPT_OLD_SOUTH_ARABIAN 87
#define UCDN_SCRIPT_INSCRIPTIONAL_PARTHIAN 88
#define UCDN_SCRIPT_INSCRIPTIONAL_PAHLAVI 89
#define UCDN_SCRIPT_OLD_TURKIC 90
#define UCDN_SCRIPT_KAITHI 91
#define UCDN_SCRIPT_BATAK 92
#define UCDN_SCRIPT_BRAHMI 93
#define UCDN_SCRIPT_MANDAIC 94
#define UCDN_SCRIPT_CHAKMA 95
#define UCDN_SCRIPT_MEROITIC_CURSIVE 96
#define UCDN_SCRIPT_MEROITIC_HIEROGLYPHS 97
#define UCDN_SCRIPT_MIAO 98
#define UCDN_SCRIPT_SHARADA 99
#define UCDN_SCRIPT_SORA_SOMPENG 100
#define UCDN_SCRIPT_TAKRI 101
#define UCDN_SCRIPT_UNKNOWN 102
#define UCDN_SCRIPT_BASSA_VAH 103
#define UCDN_SCRIPT_CAUCASIAN_ALBANIAN 104
#define UCDN_SCRIPT_DUPLOYAN 105
#define UCDN_SCRIPT_ELBASAN 106
#define UCDN_SCRIPT_GRANTHA 107
#define UCDN_SCRIPT_KHOJKI 108
#define UCDN_SCRIPT_KHUDAWADI 109
#define UCDN_SCRIPT_LINEAR_A 110
#define UCDN_SCRIPT_MAHAJANI 111
#define UCDN_SCRIPT_MANICHAEAN 112
#define UCDN_SCRIPT_MENDE_KIKAKUI 113
#define UCDN_SCRIPT_MODI 114
#define UCDN_SCRIPT_MRO 115
#define UCDN_SCRIPT_NABATAEAN 116
#define UCDN_SCRIPT_OLD_NORTH_ARABIAN 117
#define UCDN_SCRIPT_OLD_PERMIC 118
#define UCDN_SCRIPT_PAHAWH_HMONG 119
#define UCDN_SCRIPT_PALMYRENE 120
#define UCDN_SCRIPT_PAU_CIN_HAU 121
#define UCDN_SCRIPT_PSALTER_PAHLAVI 122
#define UCDN_SCRIPT_SIDDHAM 123
#define UCDN_SCRIPT_TIRHUTA 124
#define UCDN_SCRIPT_WARANG_CITI 125
#define UCDN_SCRIPT_AHOM 126
#define UCDN_SCRIPT_ANATOLIAN_HIEROGLYPHS 127
#define UCDN_SCRIPT_HATRAN 128
#define UCDN_SCRIPT_MULTANI 129
#define UCDN_SCRIPT_OLD_HUNGARIAN 130
#define UCDN_SCRIPT_SIGNWRITING 131
#define UCDN_SCRIPT_ADLAM 132
#define UCDN_SCRIPT_BHAIKSUKI 133
#define UCDN_SCRIPT_MARCHEN 134
#define UCDN_SCRIPT_NEWA 135
#define UCDN_SCRIPT_OSAGE 136
#define UCDN_SCRIPT_TANGUT 137
#define UCDN_SCRIPT_MASARAM_GONDI 138
#define UCDN_SCRIPT_NUSHU 139
#define UCDN_SCRIPT_SOYOMBO 140
#define UCDN_SCRIPT_ZANABAZAR_SQUARE 141
#define UCDN_SCRIPT_DOGRA 142
#define UCDN_SCRIPT_GUNJALA_GONDI 143
#define UCDN_SCRIPT_HANIFI_ROHINGYA 144
#define UCDN_SCRIPT_MAKASAR 145
#define UCDN_SCRIPT_MEDEFAIDRIN 146
#define UCDN_SCRIPT_OLD_SOGDIAN 147
#define UCDN_SCRIPT_SOGDIAN 148
#define UCDN_SCRIPT_ELYMAIC 149
#define UCDN_SCRIPT_NANDINAGARI 150
#define UCDN_SCRIPT_NYIAKENG_PUACHUE_HMONG 151
#define UCDN_SCRIPT_WANCHO 152



  #define SWIG_From_double   PyFloat_FromDouble 


SWIGINTERNINLINE PyObject*
  SWIG_From_int  (int value)
{
  return PyInt_FromLong((long) value);
}


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_InternalNewPointerObj((char *)(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
      return PyBytes_FromStringAndSize(carray, (Py_ssize_t)(size));
#else
      return PyUnicode_DecodeUTF8(carray, (Py_ssize_t)(size), "surrogateescape");
#endif
#else
      return PyString_FromStringAndSize(carray, (Py_ssize_t)(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


// Global Constants - Python dictionary keys
PyObject *dictkey_align;
PyObject *dictkey_bbox;
PyObject *dictkey_blocks;
PyObject *dictkey_bpc;
PyObject *dictkey_c;
PyObject *dictkey_chars;
PyObject *dictkey_color;
PyObject *dictkey_colorspace;
PyObject *dictkey_content;
PyObject *dictkey_creationDate;
PyObject *dictkey_cs_name;
PyObject *dictkey_da;
PyObject *dictkey_dashes;
PyObject *dictkey_desc;
PyObject *dictkey_dir;
PyObject *dictkey_effect;
PyObject *dictkey_ext;
PyObject *dictkey_filename;
PyObject *dictkey_fill;
PyObject *dictkey_flags;
PyObject *dictkey_font;
PyObject *dictkey_height;
PyObject *dictkey_id;
PyObject *dictkey_image;
PyObject *dictkey_length;
PyObject *dictkey_lines;
PyObject *dictkey_matrix;
PyObject *dictkey_modDate;
PyObject *dictkey_name;
PyObject *dictkey_number;
PyObject *dictkey_origin;
PyObject *dictkey_size;
PyObject *dictkey_smask;
PyObject *dictkey_spans;
PyObject *dictkey_stroke;
PyObject *dictkey_style;
PyObject *dictkey_subject;
PyObject *dictkey_text;
PyObject *dictkey_title;
PyObject *dictkey_type;
PyObject *dictkey_ufilename;
PyObject *dictkey_width;
PyObject *dictkey_wmode;
PyObject *dictkey_xref;
PyObject *dictkey_xres;
PyObject *dictkey_yres;




//-----------------------------------------------------------------------------
// Functions converting betwenn PySequences and fitz geometry objects
//-----------------------------------------------------------------------------
static int
JM_INT_ITEM(PyObject *obj, Py_ssize_t idx, int *result)
{
    PyObject *temp = PySequence_ITEM(obj, idx);
    if (!temp) return 1;
    *result = (int) PyLong_AsLong(temp);
    Py_DECREF(temp);
    if (PyErr_Occurred()) {
        PyErr_Clear();
        return 1;
    }
    return 0;
}

static int
JM_FLOAT_ITEM(PyObject *obj, Py_ssize_t idx, double *result)
{
    PyObject *temp = PySequence_ITEM(obj, idx);
    if (!temp) return 1;
    *result = PyFloat_AsDouble(temp);
    Py_DECREF(temp);
    if (PyErr_Occurred()) {
        PyErr_Clear();
        return 1;
    }
    return 0;
}


static fz_point
JM_normalize_vector(float x, float y)
{
    double px = x, py = y, len = (double) (x * x + y * y);

    if (len != 0) {
        len = sqrt(len);
        px /= len;
        py /= len;
    }
    return fz_make_point((float) px, (float) py);
}


//-----------------------------------------------------------------------------
// PySequence to fz_rect. Default: infinite rect
//-----------------------------------------------------------------------------
static fz_rect
JM_rect_from_py(PyObject *r)
{
    if (!r || !PySequence_Check(r) || PySequence_Size(r) != 4)
        return fz_infinite_rect;
    Py_ssize_t i;
    double f[4];

    for (i = 0; i < 4; i++)
        if (JM_FLOAT_ITEM(r, i, &f[i]) == 1) return fz_infinite_rect;

    return fz_make_rect((float) f[0], (float) f[1], (float) f[2], (float) f[3]);
}

//-----------------------------------------------------------------------------
// PySequence from fz_rect
//-----------------------------------------------------------------------------
static PyObject *
JM_py_from_rect(fz_rect r)
{
    return Py_BuildValue("ffff", r.x0, r.y0, r.x1, r.y1);
}

//-----------------------------------------------------------------------------
// PySequence to fz_irect. Default: infinite irect
//-----------------------------------------------------------------------------
static fz_irect
JM_irect_from_py(PyObject *r)
{
    if (!PySequence_Check(r) || PySequence_Size(r) != 4)
        return fz_infinite_irect;
    int x[4];
    Py_ssize_t i;

    for (i = 0; i < 4; i++)
        if (JM_INT_ITEM(r, i, &x[i]) == 1) return fz_infinite_irect;

    return fz_make_irect(x[0], x[1], x[2], x[3]);
}

//-----------------------------------------------------------------------------
// PySequence from fz_irect
//-----------------------------------------------------------------------------
static PyObject *
JM_py_from_irect(fz_irect r)
{
    return Py_BuildValue("iiii", r.x0, r.y0, r.x1, r.y1);
}


//-----------------------------------------------------------------------------
// PySequence to fz_point. Default: (0, 0)
//-----------------------------------------------------------------------------
static fz_point
JM_point_from_py(PyObject *p)
{
    fz_point p0 = fz_make_point(0, 0);
    double x, y;

    if (!p || !PySequence_Check(p) || PySequence_Size(p) != 2)
        return p0;

    if (JM_FLOAT_ITEM(p, 0, &x) == 1) return p0;
    if (JM_FLOAT_ITEM(p, 1, &y) == 1) return p0;

    return fz_make_point((float) x, (float) y);
}

//-----------------------------------------------------------------------------
// PySequence from fz_point
//-----------------------------------------------------------------------------
static PyObject *
JM_py_from_point(fz_point p)
{
    return Py_BuildValue("ff", p.x, p.y);
}


//-----------------------------------------------------------------------------
// PySequence to fz_matrix. Default: fz_identity
//-----------------------------------------------------------------------------
static fz_matrix
JM_matrix_from_py(PyObject *m)
{
    Py_ssize_t i;
    double a[6];

    if (!m || !PySequence_Check(m) || PySequence_Size(m) != 6)
        return fz_identity;

    for (i = 0; i < 6; i++)
        if (JM_FLOAT_ITEM(m, i, &a[i]) == 1) return fz_identity;

    return fz_make_matrix((float) a[0], (float) a[1], (float) a[2], (float) a[3], (float) a[4], (float) a[5]);
}

//-----------------------------------------------------------------------------
// PySequence from fz_matrix
//-----------------------------------------------------------------------------
static PyObject *
JM_py_from_matrix(fz_matrix m)
{
    return Py_BuildValue("ffffff", m.a, m.b, m.c, m.d, m.e, m.f);
}

//-----------------------------------------------------------------------------
// fz_quad from PySequence. Four floats are treated as rect.
// Else must be four pairs of floats.
//-----------------------------------------------------------------------------
static fz_quad
JM_quad_from_py(PyObject *r)
{
    fz_quad q = fz_make_quad(0, 0, 0, 0, 0, 0, 0, 0);
    fz_point p[4];
    double test, x, y;
    Py_ssize_t i;
    PyObject *obj = NULL;

    if (!r || !PySequence_Check(r) || PySequence_Size(r) != 4)
        return q;

    if (JM_FLOAT_ITEM(r, 0, &test) == 0)
        return fz_quad_from_rect(JM_rect_from_py(r));

    for (i = 0; i < 4; i++) {
        obj = PySequence_ITEM(r, i);  // next point item
        if (!obj || !PySequence_Check(obj) || PySequence_Size(obj) != 2)
            goto exit_result;  // invalid: cancel the rest

        if (JM_FLOAT_ITEM(obj, 0, &x) == 1) goto exit_result;
        if (JM_FLOAT_ITEM(obj, 1, &y) == 1) goto exit_result;
        p[i] = fz_make_point((float) x, (float) y);

        Py_CLEAR(obj);
    }
    q.ul = p[0];
    q.ur = p[1];
    q.ll = p[2];
    q.lr = p[3];
    return q;

    exit_result:;
    Py_CLEAR(obj);
    return q;
}

//-----------------------------------------------------------------------------
// PySequence from fz_quad.
//-----------------------------------------------------------------------------
static PyObject *
JM_py_from_quad(fz_quad q)
{
    return Py_BuildValue("((f,f),(f,f),(f,f),(f,f))",
                          q.ul.x, q.ul.y, q.ur.x, q.ur.y,
                          q.ll.x, q.ll.y, q.lr.x, q.lr.y);
}



fz_buffer *JM_object_to_buffer(fz_context *ctx, pdf_obj *val, int a, int b);
PyObject *JM_EscapeStrFromBuffer(fz_context *ctx, fz_buffer *buff);
pdf_obj *JM_pdf_obj_from_str(fz_context *ctx, pdf_document *doc, char *src);

int LIST_APPEND_DROP(PyObject *list, PyObject *item)
{
    if (!list || !PyList_Check(list) || !item) return -2;
    int rc = PyList_Append(list, item);
    Py_DECREF(item);
    return rc;
}

int DICT_SETITEM_DROP(PyObject *dict, PyObject *key, PyObject *value)
{
    if (!dict || !PyDict_Check(dict) || !key || !value) return -2;
    int rc = PyDict_SetItem(dict, key, value);
    Py_DECREF(value);
    return rc;
}

int DICT_SETITEMSTR_DROP(PyObject *dict, const char *key, PyObject *value)
{
    if (!dict || !PyDict_Check(dict) || !key || !value) return -2;
    int rc = PyDict_SetItemString(dict, key, value);
    Py_DECREF(value);
    return rc;
}

//----------------------------------
// Set a PDF dict key to some value
//----------------------------------
static pdf_obj
*JM_set_object_value(fz_context *ctx, pdf_obj *obj, const char *key, char *value)
{
    fz_buffer *res = NULL;
    pdf_obj *new_obj = NULL, *testkey = NULL;
    PyObject *skey = PyUnicode_FromString(key);  // Python version of dict key
    PyObject *slash = PyUnicode_FromString("/");  // PDF path separator
    PyObject *list = NULL, *newval=NULL, *newstr=NULL, *nullval=NULL;
    const char eyecatcher[] = "fitz: replace me!";
    fz_try(ctx)
    {
        pdf_document *pdf = pdf_get_bound_document(ctx, obj);
        // split PDF key at path seps and take last key part
        list = PyUnicode_Split(skey, slash, -1);
        Py_ssize_t len = PySequence_Size(list);
        Py_ssize_t i = len - 1;
        Py_DECREF(skey);
        skey = PySequence_GetItem(list, i);

        PySequence_DelItem(list, i);  // del the last sub-key
        len =  PySequence_Size(list);  // remaining length
        testkey = pdf_dict_getp(ctx, obj, key);  // check if key already exists
        if (!testkey) {
            /*-----------------------------------------------------------------
            No, it will be created here. But we cannot allow this happening if
            indirect objects are referenced. So we check all higher level
            sub-paths for indirect references.
            -----------------------------------------------------------------*/
            while (len > 0) {
                PyObject *t = PyUnicode_Join(slash, list);  // next high level
                if (pdf_is_indirect(ctx, pdf_dict_getp(ctx, obj, JM_StrAsChar(t)))) {
                    Py_DECREF(t);
                    fz_throw(ctx, FZ_ERROR_GENERIC, "path to '%s' has indirects", JM_StrAsChar(skey));
                }
                PySequence_DelItem(list, len - 1);  // del last sub-key
                len = PySequence_Size(list);  // remaining length
                Py_DECREF(t);
            }
        }
        // Insert our eyecatcher. Will create all sub-paths in the chain, or
        // respectively remove old value of key-path.
        pdf_dict_putp_drop(ctx, obj, key, pdf_new_text_string(ctx, eyecatcher));
        testkey = pdf_dict_getp(ctx, obj, key);
        if (!pdf_is_string(ctx, testkey)) {
            fz_throw(ctx, FZ_ERROR_GENERIC, "cannot insert value for '%s'", key);
        }
        const char *temp = pdf_to_text_string(ctx, testkey);
        if (strcmp(temp, eyecatcher) != 0) {
            fz_throw(ctx, FZ_ERROR_GENERIC, "cannot insert value for '%s'", key);
        }
        // read the result as a string
        res = JM_object_to_buffer(ctx, obj, 1, 0);
        PyObject *objstr = JM_EscapeStrFromBuffer(ctx, res);

        // replace 'eyecatcher' by desired 'value'
        nullval = PyUnicode_FromFormat("/%s(%s)", JM_StrAsChar(skey), eyecatcher);
        newval = PyUnicode_FromFormat("/%s %s", JM_StrAsChar(skey), value);
        newstr = PyUnicode_Replace(objstr, nullval, newval, 1);

        // make PDF object from resulting string
        new_obj = JM_pdf_obj_from_str(gctx, pdf, JM_StrAsChar(newstr));
    }
    fz_always(ctx) {
        fz_drop_buffer(ctx, res);
        Py_CLEAR(skey);
        Py_CLEAR(slash);
        Py_CLEAR(list);
        Py_CLEAR(newval);
        Py_CLEAR(newstr);
        Py_CLEAR(nullval);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return new_obj;
}


static void
JM_get_page_labels(fz_context *ctx, PyObject *liste, pdf_obj *nums)
{
    int pno, i, n = pdf_array_len(ctx, nums);
    char *c = NULL;
    pdf_obj *val;
    fz_buffer *res = NULL;
    for (i = 0; i < n; i += 2) {
        pdf_obj *key = pdf_resolve_indirect(ctx, pdf_array_get(ctx, nums, i));
        pno = pdf_to_int(ctx, key);
        val = pdf_resolve_indirect(ctx, pdf_array_get(ctx, nums, i + 1));
        res = JM_object_to_buffer(ctx, val, 1, 0);
        fz_buffer_storage(ctx, res, &c);
        LIST_APPEND_DROP(liste, Py_BuildValue("is", pno, c));
        fz_drop_buffer(ctx, res);
    }
}


PyObject *JM_EscapeStrFromBuffer(fz_context *ctx, fz_buffer *buff)
{
    if (!buff) return EMPTY_STRING;
    unsigned char *s = NULL;
    size_t len = fz_buffer_storage(ctx, buff, &s);
    PyObject *val = PyUnicode_DecodeRawUnicodeEscape((const char *) s, (Py_ssize_t) len, "replace");
    if (!val) {
        val = EMPTY_STRING;
        PyErr_Clear();
    }
    return val;
}

PyObject *JM_UnicodeFromBuffer(fz_context *ctx, fz_buffer *buff)
{
    unsigned char *s = NULL;
    Py_ssize_t len = (Py_ssize_t) fz_buffer_storage(ctx, buff, &s);
    PyObject *val = PyUnicode_DecodeUTF8((const char *) s, len, "replace");
    if (!val) {
        val = EMPTY_STRING;
        PyErr_Clear();
    }
    return val;
}

PyObject *JM_UnicodeFromStr(const char *c)
{
    if (!c) return EMPTY_STRING;
    PyObject *val = Py_BuildValue("s", c);
    if (!val) {
        val = EMPTY_STRING;
        PyErr_Clear();
    }
    return val;
}

PyObject *JM_EscapeStrFromStr(const char *c)
{
    if (!c) return EMPTY_STRING;
    PyObject *val = PyUnicode_DecodeRawUnicodeEscape(c, (Py_ssize_t) strlen(c), "replace");
    if (!val) {
        val = EMPTY_STRING;
        PyErr_Clear();
    }
    return val;
}


// list of valid unicodes of a fz_font
void JM_valid_chars(fz_context *ctx, fz_font *font, void *arr)
{
	FT_Face face = font->ft_face;
	FT_ULong ucs;
	FT_UInt gid;
	long *table = (long *)arr;
	fz_lock(ctx, FZ_LOCK_FREETYPE);
	ucs = FT_Get_First_Char(face, &gid);
	while (gid > 0)
	{
		if (gid < (FT_ULong)face->num_glyphs && face->num_glyphs > 0)
			table[gid] = (long)ucs;
		ucs = FT_Get_Next_Char(face, ucs, &gid);
	}
	fz_unlock(ctx, FZ_LOCK_FREETYPE);
	return;
}


// redirect MuPDF warnings
void JM_mupdf_warning(void *user, const char *message)
{
    LIST_APPEND_DROP(JM_mupdf_warnings_store, JM_EscapeStrFromStr(message));
    if (JM_mupdf_show_warnings) {
        PySys_WriteStderr("mupdf: %s\n", message);
    }
}

// redirect MuPDF errors
void JM_mupdf_error(void *user, const char *message)
{
    LIST_APPEND_DROP(JM_mupdf_warnings_store, JM_EscapeStrFromStr(message));
    if (JM_mupdf_show_errors) {
        PySys_WriteStderr("mupdf: %s\n", message);
    }
}

// a simple tracer
void JM_TRACE(const char *id)
{
    PySys_WriteStdout("%s\n", id);
}


// put a warning on Python-stdout
void JM_Warning(const char *id)
{
    PySys_WriteStdout("warning: %s\n", id);
}

#if JM_MEMORY == 1
//-----------------------------------------------------------------------------
// The following 3 functions replace MuPDF standard memory allocation.
// This will ensure, that MuPDF memory handling becomes part of Python's
// memory management.
//-----------------------------------------------------------------------------
static void *JM_Py_Malloc(void *opaque, size_t size)
{
    void *mem = PyMem_Malloc((Py_ssize_t) size);
    if (mem) return mem;
    fz_throw(gctx, FZ_ERROR_MEMORY, "malloc of %zu bytes failed", size);
}

static void *JM_Py_Realloc(void *opaque, void *old, size_t size)
{
    void *mem = PyMem_Realloc(old, (Py_ssize_t) size);
    if (mem) return mem;
    fz_throw(gctx, FZ_ERROR_MEMORY, "realloc of %zu bytes failed", size);
}

static void JM_PY_Free(void *opaque, void *ptr)
{
    PyMem_Free(ptr);
}

const fz_alloc_context JM_Alloc_Context =
{
	NULL,
	JM_Py_Malloc,
	JM_Py_Realloc,
	JM_PY_Free
};
#endif

// return Python bool for a given integer
PyObject *JM_BOOL(int v)
{
    if (v == 0)
        Py_RETURN_FALSE;
    Py_RETURN_TRUE;
}

PyObject *JM_fitz_config()
{
#if defined(TOFU)
#define have_TOFU JM_BOOL(0)
#else
#define have_TOFU JM_BOOL(1)
#endif
#if defined(TOFU_CJK)
#define have_TOFU_CJK JM_BOOL(0)
#else
#define have_TOFU_CJK JM_BOOL(1)
#endif
#if defined(TOFU_CJK_EXT)
#define have_TOFU_CJK_EXT JM_BOOL(0)
#else
#define have_TOFU_CJK_EXT JM_BOOL(1)
#endif
#if defined(TOFU_CJK_LANG)
#define have_TOFU_CJK_LANG JM_BOOL(0)
#else
#define have_TOFU_CJK_LANG JM_BOOL(1)
#endif
#if defined(TOFU_EMOJI)
#define have_TOFU_EMOJI JM_BOOL(0)
#else
#define have_TOFU_EMOJI JM_BOOL(1)
#endif
#if defined(TOFU_HISTORIC)
#define have_TOFU_HISTORIC JM_BOOL(0)
#else
#define have_TOFU_HISTORIC JM_BOOL(1)
#endif
#if defined(TOFU_SYMBOL)
#define have_TOFU_SYMBOL JM_BOOL(0)
#else
#define have_TOFU_SYMBOL JM_BOOL(1)
#endif
#if defined(TOFU_SIL)
#define have_TOFU_SIL JM_BOOL(0)
#else
#define have_TOFU_SIL JM_BOOL(1)
#endif
#if defined(TOFU_BASE14)
#define have_TOFU_BASE14 JM_BOOL(0)
#else
#define have_TOFU_BASE14 JM_BOOL(1)
#endif
    PyObject *dict = PyDict_New();
    DICT_SETITEMSTR_DROP(dict, "plotter-g", JM_BOOL(FZ_PLOTTERS_G));
    DICT_SETITEMSTR_DROP(dict, "plotter-rgb", JM_BOOL(FZ_PLOTTERS_RGB));
    DICT_SETITEMSTR_DROP(dict, "plotter-cmyk", JM_BOOL(FZ_PLOTTERS_CMYK));
    DICT_SETITEMSTR_DROP(dict, "plotter-n", JM_BOOL(FZ_PLOTTERS_N));
    DICT_SETITEMSTR_DROP(dict, "pdf", JM_BOOL(FZ_ENABLE_PDF));
    DICT_SETITEMSTR_DROP(dict, "xps", JM_BOOL(FZ_ENABLE_XPS));
    DICT_SETITEMSTR_DROP(dict, "svg", JM_BOOL(FZ_ENABLE_SVG));
    DICT_SETITEMSTR_DROP(dict, "cbz", JM_BOOL(FZ_ENABLE_CBZ));
    DICT_SETITEMSTR_DROP(dict, "img", JM_BOOL(FZ_ENABLE_IMG));
    DICT_SETITEMSTR_DROP(dict, "html", JM_BOOL(FZ_ENABLE_HTML));
    DICT_SETITEMSTR_DROP(dict, "epub", JM_BOOL(FZ_ENABLE_EPUB));
    DICT_SETITEMSTR_DROP(dict, "jpx", JM_BOOL(FZ_ENABLE_JPX));
    DICT_SETITEMSTR_DROP(dict, "js", JM_BOOL(FZ_ENABLE_JS));
    DICT_SETITEMSTR_DROP(dict, "tofu", have_TOFU);
    DICT_SETITEMSTR_DROP(dict, "tofu-cjk", have_TOFU_CJK);
    DICT_SETITEMSTR_DROP(dict, "tofu-cjk-ext", have_TOFU_CJK_EXT);
    DICT_SETITEMSTR_DROP(dict, "tofu-cjk-lang", have_TOFU_CJK_LANG);
    DICT_SETITEMSTR_DROP(dict, "tofu-emoji", have_TOFU_EMOJI);
    DICT_SETITEMSTR_DROP(dict, "tofu-historic", have_TOFU_HISTORIC);
    DICT_SETITEMSTR_DROP(dict, "tofu-symbol", have_TOFU_SYMBOL);
    DICT_SETITEMSTR_DROP(dict, "tofu-sil", have_TOFU_SIL);
    DICT_SETITEMSTR_DROP(dict, "icc", JM_BOOL(FZ_ENABLE_ICC));
    DICT_SETITEMSTR_DROP(dict, "base14", have_TOFU_BASE14);
    DICT_SETITEMSTR_DROP(dict, "py-memory", JM_BOOL(JM_MEMORY));
    return dict;
}

//----------------------------------------------------------------------------
// Update a color float array with values from a Python sequence.
// Any error condition is treated as a no-op.
//----------------------------------------------------------------------------
void JM_color_FromSequence(PyObject *color, int *n, float col[4])
{
    if (!color || (!PySequence_Check(color) && !PyFloat_Check(color))) {
        *n = 1;
        return;
    }
    if (PyFloat_Check(color)) { // maybe just a single float
        float c = (float) PyFloat_AsDouble(color);
        if (!INRANGE(c, 0, 1)) {
            *n = 1;
            return;
        }
        col[0] = c;
        *n = 1;
        return;
    }

    int len = (int) PySequence_Size(color), rc;
    if (!INRANGE(len, 1, 4) || len == 2) {
        *n = 1;
        return;
    }

    double mcol[4] = {0,0,0,0}; // local color storage
    Py_ssize_t i;
    for (i = 0; i < len; i++) {
        rc = JM_FLOAT_ITEM(color, i, &mcol[i]);
        if (!INRANGE(mcol[i], 0, 1) || rc == 1) mcol[i] = 1;
    }

    *n = len;
    for (i = 0; i < len; i++)
        col[i] = (float) mcol[i];
    return;
}

// return extension for fitz image type
const char *JM_image_extension(int type)
{
    switch (type) {
        case(FZ_IMAGE_RAW): return "raw";
        case(FZ_IMAGE_FLATE): return "flate";
        case(FZ_IMAGE_LZW): return "lzw";
        case(FZ_IMAGE_RLD): return "rld";
        case(FZ_IMAGE_BMP): return "bmp";
        case(FZ_IMAGE_GIF): return "gif";
        case(FZ_IMAGE_JBIG2): return "jb2";
        case(FZ_IMAGE_JPEG): return "jpeg";
        case(FZ_IMAGE_JPX): return "jpx";
        case(FZ_IMAGE_JXR): return "jxr";
        case(FZ_IMAGE_PNG): return "png";
        case(FZ_IMAGE_PNM): return "pnm";
        case(FZ_IMAGE_TIFF): return "tiff";
        default: return "n/a";
    }
}

//----------------------------------------------------------------------------
// Turn fz_buffer into a Python bytes object
//----------------------------------------------------------------------------
PyObject *JM_BinFromBuffer(fz_context *ctx, fz_buffer *buffer)
{

#if  PY_VERSION_HEX < 0x03000000
 #define PyBytes_FromString(x) PyString_FromString(x)
 #define PyBytes_FromStringAndSize(c, l) PyString_FromStringAndSize(c, l)
#endif

    if (!buffer) {
        return PyBytes_FromString("");
    }
    unsigned char *c = NULL;
    size_t len = fz_buffer_storage(ctx, buffer, &c);
    return PyBytes_FromStringAndSize((const char *) c, (Py_ssize_t) len);
}

//----------------------------------------------------------------------------
// Turn fz_buffer into a Python bytearray object
//----------------------------------------------------------------------------
PyObject *JM_BArrayFromBuffer(fz_context *ctx, fz_buffer *buffer)
{
    if (!buffer) {
        return PyByteArray_FromStringAndSize("", 0);
    }
    unsigned char *c = NULL;
    size_t len = fz_buffer_storage(ctx, buffer, &c);
    return PyByteArray_FromStringAndSize((const char *) c, (Py_ssize_t) len);
}


//----------------------------------------------------------------------------
// compress char* into a new buffer
//----------------------------------------------------------------------------
fz_buffer *JM_compress_buffer(fz_context *ctx, fz_buffer *inbuffer)
{
    fz_buffer *buf = NULL;
    fz_try(ctx) {
        size_t compressed_length = 0;
        unsigned char *data = fz_new_deflated_data_from_buffer(ctx,
                              &compressed_length, inbuffer, FZ_DEFLATE_BEST);
        if (data == NULL || compressed_length == 0)
            return NULL;
        buf = fz_new_buffer_from_data(ctx, data, compressed_length);
        fz_resize_buffer(ctx, buf, compressed_length);
    }
    fz_catch(ctx) {
        fz_drop_buffer(ctx, buf);
        fz_rethrow(ctx);
    }
    return buf;
}

//----------------------------------------------------------------------------
// update a stream object
// compress stream when beneficial
//----------------------------------------------------------------------------
void JM_update_stream(fz_context *ctx, pdf_document *doc, pdf_obj *obj, fz_buffer *buffer, int compress)
{

    fz_buffer *nres = NULL;
    size_t len = fz_buffer_storage(ctx, buffer, NULL);
    size_t nlen = len;

    if (compress == 1 && len > 30) {  // ignore small stuff
        nres = JM_compress_buffer(ctx, buffer);
        nlen = fz_buffer_storage(ctx, nres, NULL);
    }

    if (nlen < len && nres && compress==1) {  // was it worth the effort?
        pdf_dict_put(ctx, obj, PDF_NAME(Filter), PDF_NAME(FlateDecode));
        pdf_update_stream(ctx, doc, obj, nres, 1);
    } else {
        pdf_update_stream(ctx, doc, obj, buffer, 0);
    }
    fz_drop_buffer(ctx, nres);
}

//-----------------------------------------------------------------------------
// return hex characters for n characters in input 'in'
//-----------------------------------------------------------------------------
void hexlify(int n, unsigned char *in, unsigned char *out)
{
    const unsigned char hdigit[17] = "0123456789abcedf";
    int i, i1, i2;
    for (i = 0; i < n; i++) {
        i1 = in[i]>>4;
        i2 = in[i] - i1*16;
        out[2*i] = hdigit[i1];
        out[2*i + 1] = hdigit[i2];
    }
    out[2*n] = 0;
}

//----------------------------------------------------------------------------
// Make fz_buffer from a PyBytes, PyByteArray, io.BytesIO object
//----------------------------------------------------------------------------
fz_buffer *JM_BufferFromBytes(fz_context *ctx, PyObject *stream)
{
    char *c = NULL;
    PyObject *mybytes = NULL;
    size_t len = 0;
    fz_buffer *res = NULL;
    fz_var(res);
    fz_try(ctx) {
        if (PyBytes_Check(stream)) {
            c = PyBytes_AS_STRING(stream);
            len = (size_t) PyBytes_GET_SIZE(stream);
        } else if (PyByteArray_Check(stream)) {
            c = PyByteArray_AS_STRING(stream);
            len = (size_t) PyByteArray_GET_SIZE(stream);
        } else if (PyObject_HasAttrString(stream, "getvalue")) {
            // we assume here that this delivers what we expect
            mybytes = PyObject_CallMethod(stream, "getvalue", NULL);
            c = PyBytes_AS_STRING(mybytes);
            len = (size_t) PyBytes_GET_SIZE(mybytes);
        }
        // if none of the above, c is NULL and we return an empty buffer
        if (c) {
            res = fz_new_buffer_from_copied_data(ctx, (const unsigned char *) c, len);
        } else {
            res = fz_new_buffer(ctx, 1);
            fz_append_byte(ctx, res, 10);
        }
        fz_terminate_buffer(ctx, res);
    }
    fz_always(ctx) {
        Py_CLEAR(mybytes);
        PyErr_Clear();
    }
    fz_catch(ctx) {
        fz_drop_buffer(ctx, res);
        fz_rethrow(ctx);
    }
    return res;
}


//----------------------------------------------------------------------------
// Deep-copies a specified source page to the target location.
// Modified copy of function of pdfmerge.c: we also copy annotations, but
// we skip **link** annotations. In addition we rotate output.
//----------------------------------------------------------------------------
static void
page_merge(fz_context *ctx, pdf_document *doc_des, pdf_document *doc_src, int page_from, int page_to, int rotate, int links, int copy_annots, pdf_graft_map *graft_map)
{
    pdf_obj *page_ref = NULL;
    pdf_obj *page_dict = NULL;
    pdf_obj *obj = NULL, *ref = NULL;

    // list of object types (per page) we want to copy
    pdf_obj *known_page_objs[] = {
        PDF_NAME(Contents),
        PDF_NAME(Resources),
        PDF_NAME(MediaBox),
        PDF_NAME(CropBox),
        PDF_NAME(BleedBox),
        PDF_NAME(TrimBox),
        PDF_NAME(ArtBox),
        PDF_NAME(Rotate),
        PDF_NAME(UserUnit)
    };
    int i, n = (int) nelem(known_page_objs);  // number of list elements
    fz_var(ref);
    fz_var(page_dict);
    fz_try(ctx) {
        page_ref = pdf_lookup_page_obj(ctx, doc_src, page_from);
        pdf_flatten_inheritable_page_items(ctx, page_ref);

        // make new page dict in dest doc
        page_dict = pdf_new_dict(ctx, doc_des, 4);
        pdf_dict_put(ctx, page_dict, PDF_NAME(Type), PDF_NAME(Page));

        // copy objects of source page into it
        for (i = 0; i < n; i++) {
            obj = pdf_dict_get(ctx, page_ref, known_page_objs[i]);
            if (obj != NULL) {
                pdf_dict_put_drop(ctx, page_dict, known_page_objs[i], pdf_graft_mapped_object(ctx, graft_map, obj));
            }
        }

        // Copy the annotations, but skip types Link, Popup, IRT.
        // Remove dict keys P (parent) and Popup from copied annot.
        if (copy_annots) {
            pdf_obj *old_annots = pdf_dict_get(ctx, page_ref, PDF_NAME(Annots));
            if (old_annots) {
                n = pdf_array_len(ctx, old_annots);
                pdf_obj *new_annots = pdf_dict_put_array(ctx, page_dict, PDF_NAME(Annots), n);
                for (i = 0; i < n; i++) {
                    pdf_obj *o = pdf_array_get(ctx, old_annots, i);
                    if (pdf_dict_gets(ctx, o, "IRT")) continue;
                    pdf_obj *subtype = pdf_dict_get(ctx, o, PDF_NAME(Subtype));
                    if (pdf_name_eq(ctx, subtype, PDF_NAME(Link))) continue;
                    if (pdf_name_eq(ctx, subtype, PDF_NAME(Popup))) continue;
                    pdf_dict_del(ctx, o, PDF_NAME(Popup));
                    pdf_dict_del(ctx, o, PDF_NAME(P));
                    pdf_obj *copy_o = pdf_graft_mapped_object(ctx, graft_map, o);
                    pdf_obj *annot = pdf_new_indirect(ctx, doc_des,
                                     pdf_to_num(ctx, copy_o), 0);
                    pdf_array_push_drop(ctx, new_annots, annot);
                    pdf_drop_obj(ctx, copy_o);
                }
            }
        }
        // rotate the page
        if (rotate != -1) {
            pdf_dict_put_int(ctx, page_dict, PDF_NAME(Rotate), (int64_t) rotate);
        }
        // Now add the page dictionary to dest PDF
        ref = pdf_add_object(ctx, doc_des, page_dict);

        // Insert new page at specified location
        pdf_insert_page(ctx, doc_des, page_to, ref);

    }
    fz_always(ctx) {
        pdf_drop_obj(ctx, ref);
        pdf_drop_obj(ctx, page_dict);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
}

//-----------------------------------------------------------------------------
// Copy a range of pages (spage, epage) from a source PDF to a specified
// location (apage) of the target PDF.
// If spage > epage, the sequence of source pages is reversed.
//-----------------------------------------------------------------------------
void JM_merge_range(fz_context *ctx, pdf_document *doc_des, pdf_document *doc_src, int spage, int epage, int apage, int rotate, int links, int annots, int show_progress, pdf_graft_map *graft_map)
{
    int page, afterpage;
    afterpage = apage;
    int counter = 0;  // copied pages counter
    int total = fz_absi(epage - spage) + 1;  // total pages to copy

    fz_try(ctx) {
        if (spage < epage) {
            for (page = spage; page <= epage; page++, afterpage++) {
                page_merge(ctx, doc_des, doc_src, page, afterpage, rotate, links, annots, graft_map);
                counter++;
                if (show_progress > 0 && counter % show_progress == 0) {
                    PySys_WriteStdout("Inserted %i of %i pages.\n", counter, total);
                }
            }
        } else {
            for (page = spage; page >= epage; page--, afterpage++) {
                page_merge(ctx, doc_des, doc_src, page, afterpage, rotate, links, annots, graft_map);
                counter++;
                if (show_progress > 0 && counter % show_progress == 0) {
                    PySys_WriteStdout("Inserted %i of %i pages.\n", counter, total);
                }
            }
        }
    }

    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
}

//----------------------------------------------------------------------------
// Return list of outline xref numbers. Recursive function. Arguments:
// 'obj' first OL item
// 'xrefs' empty Python list
//----------------------------------------------------------------------------
PyObject *JM_outline_xrefs(fz_context *ctx, pdf_obj *obj, PyObject *xrefs)
{
    pdf_obj *first, *parent, *thisobj;
    if (!obj) return xrefs;
    thisobj = obj;
    while (thisobj) {
        LIST_APPEND_DROP(xrefs, Py_BuildValue("i", pdf_to_num(ctx, thisobj)));
        first = pdf_dict_get(ctx, thisobj, PDF_NAME(First));  // try go down
        if (first) xrefs = JM_outline_xrefs(ctx, first, xrefs);
        thisobj = pdf_dict_get(ctx, thisobj, PDF_NAME(Next));  // try go next
        parent = pdf_dict_get(ctx, thisobj, PDF_NAME(Parent));  // get parent
        if (!thisobj) thisobj = parent;  // goto parent if no next
    }
    return xrefs;
}


//-----------------------------------------------------------------------------
// Return the contents of a font file, identified by xref
//-----------------------------------------------------------------------------
fz_buffer *JM_get_fontbuffer(fz_context *ctx, pdf_document *doc, int xref)
{
    if (xref < 1) return NULL;
    pdf_obj *o, *obj = NULL, *desft, *stream = NULL;
    o = pdf_load_object(ctx, doc, xref);
    desft = pdf_dict_get(ctx, o, PDF_NAME(DescendantFonts));
    char *ext = NULL;
    if (desft) {
        obj = pdf_resolve_indirect(ctx, pdf_array_get(ctx, desft, 0));
        obj = pdf_dict_get(ctx, obj, PDF_NAME(FontDescriptor));
    } else {
        obj = pdf_dict_get(ctx, o, PDF_NAME(FontDescriptor));
    }

    if (!obj) {
        pdf_drop_obj(ctx, o);
        PySys_WriteStdout("invalid font - FontDescriptor missing");
        return NULL;
    }
    pdf_drop_obj(ctx, o);
    o = obj;

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile));
    if (obj) stream = obj;             // ext = "pfa"

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile2));
    if (obj) stream = obj;             // ext = "ttf"

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile3));
    if (obj) {
        stream = obj;

        obj = pdf_dict_get(ctx, obj, PDF_NAME(Subtype));
        if (obj && !pdf_is_name(ctx, obj)) {
            PySys_WriteStdout("invalid font descriptor subtype");
            return NULL;
        }

        if (pdf_name_eq(ctx, obj, PDF_NAME(Type1C)))
            ext = "cff";
        else if (pdf_name_eq(ctx, obj, PDF_NAME(CIDFontType0C)))
            ext = "cid";
        else if (pdf_name_eq(ctx, obj, PDF_NAME(OpenType)))
            ext = "otf";
        else
            PySys_WriteStdout("warning: unhandled font type '%s'", pdf_to_name(ctx, obj));
    }

    if (!stream) {
        PySys_WriteStdout("warning: unhandled font type");
        return NULL;
    }

    return pdf_load_stream(ctx, stream);
}

//-----------------------------------------------------------------------------
// Return the file extension of a font file, identified by xref
//-----------------------------------------------------------------------------
char *JM_get_fontextension(fz_context *ctx, pdf_document *doc, int xref)
{
    if (xref < 1) return "n/a";
    pdf_obj *o, *obj = NULL, *desft;
    o = pdf_load_object(ctx, doc, xref);
    desft = pdf_dict_get(ctx, o, PDF_NAME(DescendantFonts));
    if (desft) {
        obj = pdf_resolve_indirect(ctx, pdf_array_get(ctx, desft, 0));
        obj = pdf_dict_get(ctx, obj, PDF_NAME(FontDescriptor));
    } else {
        obj = pdf_dict_get(ctx, o, PDF_NAME(FontDescriptor));
    }

    pdf_drop_obj(ctx, o);
    if (!obj) return "n/a";           // this is a base-14 font

    o = obj;                           // we have the FontDescriptor

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile));
    if (obj) return "pfa";

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile2));
    if (obj) return "ttf";

    obj = pdf_dict_get(ctx, o, PDF_NAME(FontFile3));
    if (obj) {
        obj = pdf_dict_get(ctx, obj, PDF_NAME(Subtype));
        if (obj && !pdf_is_name(ctx, obj)) {
            PySys_WriteStdout("invalid font descriptor subtype");
            return "n/a";
        }
        if (pdf_name_eq(ctx, obj, PDF_NAME(Type1C)))
            return "cff";
        else if (pdf_name_eq(ctx, obj, PDF_NAME(CIDFontType0C)))
            return "cid";
        else if (pdf_name_eq(ctx, obj, PDF_NAME(OpenType)))
            return "otf";
        else
            PySys_WriteStdout("unhandled font type '%s'", pdf_to_name(ctx, obj));
    }

    return "n/a";
}


//-----------------------------------------------------------------------------
// create PDF object from given string (new in v1.14.0: MuPDF dropped it)
//-----------------------------------------------------------------------------
pdf_obj *JM_pdf_obj_from_str(fz_context *ctx, pdf_document *doc, char *src)
{
    pdf_obj *result = NULL;
    pdf_lexbuf lexbuf;
    fz_stream *stream = fz_open_memory(ctx, (unsigned char *)src, strlen(src));

    pdf_lexbuf_init(ctx, &lexbuf, PDF_LEXBUF_SMALL);

    fz_try(ctx) {
        result = pdf_parse_stm_obj(ctx, doc, stream, &lexbuf);
    }

    fz_always(ctx) {
        pdf_lexbuf_fin(ctx, &lexbuf);
        fz_drop_stream(ctx, stream);
    }

    fz_catch(ctx) {
        fz_rethrow(ctx);
    }

    return result;

}

//----------------------------------------------------------------------------
// return normalized /Rotate value
//----------------------------------------------------------------------------
int JM_norm_rotation(int rotate)
{
    while (rotate < 0) rotate += 360;
    while (rotate >= 360) rotate -= 360;
    if (rotate % 90 != 0) return 0;
    return rotate;
}


//----------------------------------------------------------------------------
// return a PDF page's /Rotate value: one of (0, 90, 180, 270)
//----------------------------------------------------------------------------
int JM_page_rotation(fz_context *ctx, pdf_page *page)
{
    int rotate = 0;
    fz_try(ctx)
    {
        rotate = pdf_to_int(ctx,
                pdf_dict_get_inheritable(ctx, page->obj, PDF_NAME(Rotate)));
        rotate = JM_norm_rotation(rotate);
    }
    fz_catch(ctx) return 0;
    return rotate;
}


//----------------------------------------------------------------------------
// return a PDF page's MediaBox
//----------------------------------------------------------------------------
fz_rect JM_mediabox(fz_context *ctx, pdf_obj *page_obj)
{
    fz_rect mediabox, page_mediabox;

    mediabox = pdf_to_rect(ctx, pdf_dict_get_inheritable(ctx, page_obj,
        PDF_NAME(MediaBox)));
    if (fz_is_empty_rect(mediabox) || fz_is_infinite_rect(mediabox))
    {
        mediabox.x0 = 0;
        mediabox.y0 = 0;
        mediabox.x1 = 612;
        mediabox.y1 = 792;
    }

    page_mediabox.x0 = fz_min(mediabox.x0, mediabox.x1);
    page_mediabox.y0 = fz_min(mediabox.y0, mediabox.y1);
    page_mediabox.x1 = fz_max(mediabox.x0, mediabox.x1);
    page_mediabox.y1 = fz_max(mediabox.y0, mediabox.y1);

    if (page_mediabox.x1 - page_mediabox.x0 < 1 ||
        page_mediabox.y1 - page_mediabox.y0 < 1)
        page_mediabox = fz_unit_rect;

    return page_mediabox;
}


//----------------------------------------------------------------------------
// return a PDF page's CropBox
//----------------------------------------------------------------------------
fz_rect JM_cropbox(fz_context *ctx, pdf_obj *page_obj)
{
    fz_rect mediabox = JM_mediabox(ctx, page_obj);
    fz_rect cropbox = pdf_to_rect(ctx,
                pdf_dict_get_inheritable(ctx, page_obj, PDF_NAME(CropBox)));
    if (fz_is_infinite_rect(cropbox) || fz_is_empty_rect(cropbox))
        return mediabox;
    float y0 = mediabox.y1 - cropbox.y1;
    float y1 = mediabox.y1 - cropbox.y0;
    cropbox.y0 = y0;
    cropbox.y1 = y1;
    return cropbox;
}


//----------------------------------------------------------------------------
// calculate width and height of the UNROTATED page
//----------------------------------------------------------------------------
fz_point JM_cropbox_size(fz_context *ctx, pdf_obj *page_obj)
{
    fz_point size;
    fz_try(ctx)
    {
        fz_rect rect = JM_cropbox(ctx, page_obj);
        float w = (rect.x0 < rect.x1 ? rect.x1 - rect.x0 : rect.x0 - rect.x1);
        float h = (rect.y0 < rect.y1 ? rect.y1 - rect.y0 : rect.y0 - rect.y1);
        size = fz_make_point(w, h);
    }
    fz_catch(ctx) fz_rethrow(ctx);
    return size;
}


//----------------------------------------------------------------------------
// calculate page rotation matrices
//----------------------------------------------------------------------------
fz_matrix JM_rotate_page_matrix(fz_context *ctx, pdf_page *page)
{
    if (!page) return fz_identity;  // no valid pdf page given
    int rotation = JM_page_rotation(ctx, page);
    if (rotation == 0) return fz_identity;  // no rotation
    fz_matrix m;
    fz_point cb_size = JM_cropbox_size(ctx, page->obj);
    float w = cb_size.x;
    float h = cb_size.y;
    if (rotation == 90)
        m = fz_make_matrix(0, 1, -1, 0, h, 0);
    else if (rotation == 180)
        m = fz_make_matrix(-1, 0, 0, -1, w, h);
    else
        m = fz_make_matrix(0, -1, 1, 0, 0, w);
    return m;
}


fz_matrix JM_derotate_page_matrix(fz_context *ctx, pdf_page *page)
{  // just the inverse of rotation
    return fz_invert_matrix(JM_rotate_page_matrix(ctx, page));
}


//-----------------------------------------------------------------------------
// Insert a font in a PDF
//-----------------------------------------------------------------------------
PyObject *
JM_insert_font(fz_context *ctx, pdf_document *pdf, char *bfname, char *fontfile,
    PyObject *fontbuffer, int set_simple, int idx, int wmode, int serif,
    int encoding, int ordering)
{
    pdf_obj *font_obj;
    fz_font *font = NULL;
    fz_buffer *res = NULL;
    const unsigned char *data = NULL;
    int size, ixref = 0, index = 0, simple = 0;
    PyObject *value, *name, *subt, *exto = NULL;

    fz_try(ctx) {
        //-------------------------------------------------------------
        // check for CJK font
        //-------------------------------------------------------------
        if (ordering > -1) {
            data = fz_lookup_cjk_font(ctx, ordering, &size, &index);
        }
        if (data) {
            font = fz_new_font_from_memory(ctx, NULL, data, size, index, 0);
            font_obj = pdf_add_cjk_font(ctx, pdf, font, ordering, wmode, serif);
            exto = JM_UnicodeFromStr("n/a");
            simple = 0;
            goto weiter;
        }

        //-------------------------------------------------------------
        // check for PDF Base-14 font
        //-------------------------------------------------------------
        if (bfname) {
            data = fz_lookup_base14_font(ctx, bfname, &size);
        }
        if (data) {
            font = fz_new_font_from_memory(ctx, bfname, data, size, 0, 0);
            font_obj = pdf_add_simple_font(ctx, pdf, font, encoding);
            exto = JM_UnicodeFromStr("n/a");
            simple = 1;
            goto weiter;
        }

        if (fontfile) {
            font = fz_new_font_from_file(ctx, NULL, fontfile, idx, 0);
        } else {
            res = JM_BufferFromBytes(ctx, fontbuffer);
            if (!res) {
                THROWMSG(ctx, "need one of fontfile, fontbuffer");
            }
            font = fz_new_font_from_buffer(ctx, NULL, res, idx, 0);
        }

        if (!set_simple) {
            font_obj = pdf_add_cid_font(ctx, pdf, font);
            simple = 0;
        } else {
            font_obj = pdf_add_simple_font(ctx, pdf, font, encoding);
            simple = 2;
        }

        weiter: ;
        font_obj = pdf_keep_obj(ctx, font_obj);
        ixref = pdf_to_num(ctx, font_obj);
        if (fz_font_is_monospaced(ctx, font)) {
            float adv = fz_advance_glyph(ctx, font,
                            fz_encode_character(ctx, font, 32), 0);
            int width = (int) floor(adv * 1000.0f + 0.5f);
            pdf_obj *dfonts = pdf_dict_get(ctx, font_obj, PDF_NAME(DescendantFonts));
            if (pdf_is_array(ctx, dfonts)) {
                int i, n = pdf_array_len(ctx, dfonts);
                for (i = 0; i < n; i++) {
                    pdf_obj *dfont = pdf_array_get(ctx, dfonts, i);
                    pdf_obj *warray = pdf_new_array(ctx, pdf, 3);
                    pdf_array_push(ctx, warray, pdf_new_int(ctx, 0));
                    pdf_array_push(ctx, warray, pdf_new_int(ctx, 65535));
                    pdf_array_push(ctx, warray, pdf_new_int(ctx, (int64_t) width));
                    pdf_dict_put_drop(ctx, dfont, PDF_NAME(W), warray);
                }
            }
        }
        name = JM_EscapeStrFromStr(pdf_to_name(ctx,
                    pdf_dict_get(ctx, font_obj, PDF_NAME(BaseFont))));

        subt = JM_UnicodeFromStr(pdf_to_name(ctx,
                    pdf_dict_get(ctx, font_obj, PDF_NAME(Subtype))));

        if (!exto)
            exto = JM_UnicodeFromStr(JM_get_fontextension(ctx, pdf, ixref));

        float asc = fz_font_ascender(ctx, font);
        float dsc = fz_font_descender(ctx, font);
        value = Py_BuildValue("[i,{s:O,s:O,s:O,s:O,s:i,s:f,s:f}]",
                                ixref,
                                "name", name,        // base font name
                                "type", subt,        // subtype
                                "ext", exto,         // file extension
                                "simple", JM_BOOL(simple), // simple font?
                                "ordering", ordering, // CJK font?
                                "ascender", asc,
                                "descender", dsc
                                );
    }
    fz_always(ctx) {
        Py_CLEAR(exto);
        Py_CLEAR(name);
        Py_CLEAR(subt);
        fz_drop_buffer(ctx, res);
        fz_drop_font(ctx, font);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return value;
}


//-----------------------------------------------------------------------------
// compute image isnertion matrix
//-----------------------------------------------------------------------------
fz_matrix
calc_image_matrix(int width, int height, PyObject *tr, int rotate, int keep)
{
    float large, small, fw, fh, trw, trh, f, w, h;
    fz_rect trect = JM_rect_from_py(tr);
    fz_matrix rot = fz_rotate((float) rotate);
    trw = trect.x1 - trect.x0;
    trh = trect.y1 - trect.y0;
    w = trw;
    h = trh;
    if (keep) {
        large = (float) MAX(width, height);
        fw = (float) width / large;
        fh = (float) height / large;
    } else {
        fw = fh = 1;
    }
    small = MIN(fw, fh);
    if (rotate != 0 && rotate != 180) {
        f = fw;
        fw = fh;
        fh = f;
    }
    if (fw < 1) {
        if ((trw / fw) > (trh / fh)) {
            w = trh * small;
            h = trh;
        } else {
            w = trw;
            h = trw / small;
        }
    } else if (fw != fh) {
        if ((trw / fw) > (trh / fh)) {
            w = trh / small;
            h = trh;
        } else {
            w = trw;
            h = trw * small;
        }
    } else {
        w = trw;
        h = trh;
    }
    fz_point tmp = fz_make_point((trect.x0 + trect.x1) / 2,
                                 (trect.y0 + trect.y1) / 2);
    fz_matrix mat = fz_make_matrix(1, 0, 0, 1, -0.5, -0.5);
    mat = fz_concat(mat, rot);
    mat = fz_concat(mat, fz_scale(w, h));
    mat = fz_concat(mat, fz_translate(tmp.x, tmp.y));
    return mat;
}


//-----------------------------------------------------------------------------
// dummy structure for various tools and utilities
//-----------------------------------------------------------------------------
struct Tools {int index;};

typedef struct fz_item fz_item;

struct fz_item
{
	void *key;
	fz_storable *val;
	size_t size;
	fz_item *next;
	fz_item *prev;
	fz_store *store;
	const fz_store_type *type;
};

struct fz_store
{
	int refs;

	/* Every item in the store is kept in a doubly linked list, ordered
	 * by usage (so LRU entries are at the end). */
	fz_item *head;
	fz_item *tail;

	/* We have a hash table that allows to quickly find a subset of the
	 * entries (those whose keys are indirect objects). */
	fz_hash_table *hash;

	/* We keep track of the size of the store, and keep it below max. */
	size_t max;
	size_t size;

	int defer_reap_count;
	int needs_reaping;
};




//-----------------------------------------------------------------------------
// pixmap helper functions
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Clear a pixmap rectangle - my version also supports non-alpha pixmaps
//-----------------------------------------------------------------------------
int
JM_clear_pixmap_rect_with_value(fz_context *ctx, fz_pixmap *dest, int value, fz_irect b)
{
    unsigned char *destp;
    int x, y, w, k, destspan;

    b = fz_intersect_irect(b, fz_pixmap_bbox(ctx, dest));
    w = b.x1 - b.x0;
    y = b.y1 - b.y0;
    if (w <= 0 || y <= 0)
        return 0;

    destspan = dest->stride;
    destp = dest->samples + (unsigned int)(destspan * (b.y0 - dest->y) + dest->n * (b.x0 - dest->x));

    /* CMYK needs special handling (and potentially any other subtractive colorspaces) */
    if (fz_colorspace_n(ctx, dest->colorspace) == 4) {
        value = 255 - value;
        do {
            unsigned char *s = destp;
            for (x = 0; x < w; x++) {
                *s++ = 0;
                *s++ = 0;
                *s++ = 0;
                *s++ = value;
                if (dest->alpha) *s++ = 255;
            }
            destp += destspan;
        } while (--y);
        return 1;
    }

    do {
        unsigned char *s = destp;
        for (x = 0; x < w; x++) {
            for (k = 0; k < dest->n - 1; k++)
                *s++ = value;
            if (dest->alpha) *s++ = 255;
            else *s++ = value;
        }
        destp += destspan;
    } while (--y);
    return 1;
}

//-----------------------------------------------------------------------------
// fill a rect with a color tuple
//-----------------------------------------------------------------------------
int
JM_fill_pixmap_rect_with_color(fz_context *ctx, fz_pixmap *dest, unsigned char col[5], fz_irect b)
{
    unsigned char *destp;
    int x, y, w, i, destspan;

    b = fz_intersect_irect(b, fz_pixmap_bbox(ctx, dest));
    w = b.x1 - b.x0;
    y = b.y1 - b.y0;
    if (w <= 0 || y <= 0)
        return 0;

    destspan = dest->stride;
    destp = dest->samples + (unsigned int)(destspan * (b.y0 - dest->y) + dest->n * (b.x0 - dest->x));

    do {
        unsigned char *s = destp;
        for (x = 0; x < w; x++) {
            for (i = 0; i < dest->n; i++)
                *s++ = col[i];
        }
        destp += destspan;
    } while (--y);
    return 1;
}

//-----------------------------------------------------------------------------
// invert a rectangle - also supports non-alpha pixmaps
//-----------------------------------------------------------------------------
int
JM_invert_pixmap_rect(fz_context *ctx, fz_pixmap *dest, fz_irect b)
{
    unsigned char *destp;
    int x, y, w, i, destspan;

    b = fz_intersect_irect(b, fz_pixmap_bbox(ctx, dest));
    w = b.x1 - b.x0;
    y = b.y1 - b.y0;
    if (w <= 0 || y <= 0)
        return 0;

    destspan = dest->stride;
    destp = dest->samples + (unsigned int)(destspan * (b.y0 - dest->y) + dest->n * (b.x0 - dest->x));
    int n0 = dest->n - dest->alpha;
    do {
        unsigned char *s = destp;
        for (x = 0; x < w; x++) {
            for (i = 0; i < n0; i++)
                *s++ = 255 - *s;
            if (dest->alpha) *s++;
        }
        destp += destspan;
    } while (--y);
    return 1;
}

int
JM_is_jbig2_image(fz_context *ctx, pdf_obj *dict)
{
	return 0;
    pdf_obj *filter;
	int i, n;

	filter = pdf_dict_get(ctx, dict, PDF_NAME(Filter));
	if (pdf_name_eq(ctx, filter, PDF_NAME(JBIG2Decode)))
		return 1;
	n = pdf_array_len(ctx, filter);
	for (i = 0; i < n; i++)
		if (pdf_name_eq(ctx, pdf_array_get(ctx, filter, i), PDF_NAME(JBIG2Decode)))
			return 1;
	return 0;
}

//-----------------------------------------------------------------------------
// Return basic properties of an image provided as bytes or bytearray
// The function creates an fz_image and optionally returns it.
//-----------------------------------------------------------------------------
PyObject *JM_image_profile(fz_context *ctx, PyObject *imagedata, int keep_image)
{
    if (!EXISTS(imagedata)) {
        Py_RETURN_NONE;  // nothing given
    }
    fz_image *image = NULL;
    fz_buffer *res = NULL;
    PyObject *result = NULL;
    unsigned char *c = NULL;
    Py_ssize_t len = 0;
    if (PyBytes_Check(imagedata)) {
        c = PyBytes_AS_STRING(imagedata);
        len = PyBytes_GET_SIZE(imagedata);
    } else if (PyByteArray_Check(imagedata)) {
        c = PyByteArray_AS_STRING(imagedata);
        len = PyByteArray_GET_SIZE(imagedata);
    } else {
        PySys_WriteStderr("bad image data\n");
        Py_RETURN_NONE;
    }

    if (len < 8) {
        PySys_WriteStderr("bad image data\n");
        Py_RETURN_NONE;
    }
    int type = fz_recognize_image_format(ctx, c);
    if (type == FZ_IMAGE_UNKNOWN) {
        Py_RETURN_NONE;
    }

    fz_try(ctx) {
        if (keep_image) {
            res = fz_new_buffer_from_copied_data(ctx, c, (size_t) len);
        } else {
            res = fz_new_buffer_from_shared_data(ctx, c, (size_t) len);
        }
        image = fz_new_image_from_buffer(ctx, res);
        int xres, yres;
        fz_image_resolution(image, &xres, &yres);
        const char *cs_name = fz_colorspace_name(gctx, image->colorspace);
        result = PyDict_New();
        DICT_SETITEM_DROP(result, dictkey_width,
                Py_BuildValue("i", image->w));
        DICT_SETITEM_DROP(result, dictkey_height,
                Py_BuildValue("i", image->h));
        DICT_SETITEM_DROP(result, dictkey_xres,
                Py_BuildValue("i", xres));
        DICT_SETITEM_DROP(result, dictkey_yres,
                Py_BuildValue("i", yres));
        DICT_SETITEM_DROP(result, dictkey_colorspace,
                Py_BuildValue("i", image->n));
        DICT_SETITEM_DROP(result, dictkey_bpc,
                Py_BuildValue("i", image->bpc));
        DICT_SETITEM_DROP(result, dictkey_ext,
                Py_BuildValue("s", JM_image_extension(type)));
        DICT_SETITEM_DROP(result, dictkey_cs_name,
                Py_BuildValue("s", cs_name));

        if (keep_image) {
            DICT_SETITEM_DROP(result, dictkey_image,
                    PyLong_FromVoidPtr((void *) fz_keep_image(ctx, image)));
        }
    }
    fz_always(ctx) {
        if (!keep_image) {
            fz_drop_image(ctx, image);
        } else {
            fz_drop_buffer(ctx, res);  // drop the buffer copy
        }
    }
    fz_catch(ctx) {
        Py_CLEAR(result);
        fz_rethrow(ctx);
    }
    PyErr_Clear();
    return result;
}

//----------------------------------------------------------------------------
// Version of fz_new_pixmap_from_display_list (util.c) to also support
// rendering of only the 'clip' part of the displaylist rectangle
//----------------------------------------------------------------------------
fz_pixmap *
JM_pixmap_from_display_list(fz_context *ctx,
                            fz_display_list *list,
                            PyObject *ctm,
                            fz_colorspace *cs,
                            int alpha,
                            PyObject *clip,
                            fz_separations *seps
                           )
{
    fz_rect rect = fz_bound_display_list(ctx, list);
    fz_matrix matrix = JM_matrix_from_py(ctm);
    fz_pixmap *pix = NULL;
    fz_var(pix);
    fz_device *dev = NULL;
    fz_var(dev);
    fz_rect rclip = JM_rect_from_py(clip);
    rect = fz_intersect_rect(rect, rclip);  // no-op if clip is not given

    rect = fz_transform_rect(rect, matrix);
    fz_irect irect = fz_round_rect(rect);

    pix = fz_new_pixmap_with_bbox(ctx, cs, irect, seps, alpha);
    if (alpha)
        fz_clear_pixmap(ctx, pix);
    else
        fz_clear_pixmap_with_value(ctx, pix, 0xFF);

    fz_try(ctx) {
        if (!fz_is_infinite_rect(rclip)) {
            dev = fz_new_draw_device_with_bbox(ctx, matrix, pix, &irect);
            fz_run_display_list(ctx, list, dev, fz_identity, rclip, NULL);
        } else {
            dev = fz_new_draw_device(ctx, matrix, pix);
            fz_run_display_list(ctx, list, dev, fz_identity, fz_infinite_rect, NULL);
        }

        fz_close_device(ctx, dev);
    }
    fz_always(ctx) {
        fz_drop_device(ctx, dev);
    }
    fz_catch(ctx) {
        fz_drop_pixmap(ctx, pix);
        fz_rethrow(ctx);
    }
    return pix;
}

//----------------------------------------------------------------------------
// Pixmap creation directly using a short-lived displaylist, so we can support
// separations.
//----------------------------------------------------------------------------
fz_pixmap *
JM_pixmap_from_page(fz_context *ctx,
                    fz_document *doc,
                    fz_page *page,
                    PyObject *ctm,
                    fz_colorspace *cs,
                    int alpha,
                    int annots,
                    PyObject *clip
                   )
{
    enum { SPOTS_NONE, SPOTS_OVERPRINT_SIM, SPOTS_FULL };
    int spots;
    if (FZ_ENABLE_SPOT_RENDERING)
        spots = SPOTS_OVERPRINT_SIM;
    else
        spots = SPOTS_NONE;

    fz_separations *seps = NULL;
    fz_pixmap *pix = NULL;
    fz_colorspace *oi = NULL;
    fz_var(oi);
    fz_colorspace *colorspace = cs;
    fz_rect rect;
    fz_irect bbox;
    fz_device *dev = NULL;
    fz_var(dev);
    fz_matrix matrix = JM_matrix_from_py(ctm);
    rect = fz_bound_page(ctx, page);
    fz_rect rclip = JM_rect_from_py(clip);
    rect = fz_intersect_rect(rect, rclip);  // no-op if clip is not given
    rect = fz_transform_rect(rect, matrix);
    bbox = fz_round_rect(rect);

    fz_try(ctx) {
        // Pixmap of the document's /OutputIntents ("output intents")
        oi = fz_document_output_intent(ctx, doc);
        // if present and compatible, use it instead of the parameter
        if (oi) {
            if (fz_colorspace_n(ctx, oi) == fz_colorspace_n(ctx, cs)) {
                colorspace = fz_keep_colorspace(ctx, oi);
            }
        }

        // check if spots rendering is available and if so use separations
        if (spots != SPOTS_NONE) {
            seps = fz_page_separations(ctx, page);
            if (seps) {
                int i, n = fz_count_separations(ctx, seps);
                if (spots == SPOTS_FULL)
                    for (i = 0; i < n; i++)
                        fz_set_separation_behavior(ctx, seps, i, FZ_SEPARATION_SPOT);
                else
                    for (i = 0; i < n; i++)
                        fz_set_separation_behavior(ctx, seps, i, FZ_SEPARATION_COMPOSITE);
            } else if (fz_page_uses_overprint(ctx, page)) {
                /* This page uses overprint, so we need an empty
                 * sep object to force the overprint simulation on. */
                seps = fz_new_separations(ctx, 0);
            } else if (oi && fz_colorspace_n(ctx, oi) != fz_colorspace_n(ctx, colorspace)) {
                /* We have an output intent, and it's incompatible
                 * with the colorspace our device needs. Force the
                 * overprint simulation on, because this ensures that
                 * we 'simulate' the output intent too. */
                seps = fz_new_separations(ctx, 0);
            }
        }

        pix = fz_new_pixmap_with_bbox(ctx, colorspace, bbox, seps, alpha);

        if (alpha) {
            fz_clear_pixmap(ctx, pix);
        } else {
            fz_clear_pixmap_with_value(ctx, pix, 0xFF);
        }

        dev = fz_new_draw_device(ctx, matrix, pix);
        if (annots) {
            fz_run_page(ctx, page, dev, fz_identity, NULL);
        } else {
            fz_run_page_contents(ctx, page, dev, fz_identity, NULL);
        }
        fz_close_device(ctx, dev);
    }
    fz_always(ctx) {
        fz_drop_device(ctx, dev);
        fz_drop_separations(ctx, seps);
        fz_drop_colorspace(ctx, oi);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return pix;
}


//------------------------------------------------------------------------
// return pdf_obj "border style" from Python str
//------------------------------------------------------------------------
pdf_obj *JM_get_border_style(fz_context *ctx, PyObject *style)
{
    pdf_obj *val = PDF_NAME(S);
    if (!style) return val;
    char *s = JM_StrAsChar(style);
    JM_PyErr_Clear;
    if (!s) return val;
    if      (!strncmp(s, "b", 1) || !strncmp(s, "B", 1)) val = PDF_NAME(B);
    else if (!strncmp(s, "d", 1) || !strncmp(s, "D", 1)) val = PDF_NAME(D);
    else if (!strncmp(s, "i", 1) || !strncmp(s, "I", 1)) val = PDF_NAME(I);
    else if (!strncmp(s, "u", 1) || !strncmp(s, "U", 1)) val = PDF_NAME(U);
    return val;
}

//------------------------------------------------------------------------
// Make /DA string of annotation
//------------------------------------------------------------------------
const char *JM_expand_fname(const char **name)
{
    if (!*name) return "Helv";
    if (!strncmp(*name, "Co", 2)) return "Cour";
    if (!strncmp(*name, "co", 2)) return "Cour";
    if (!strncmp(*name, "Ti", 2)) return "TiRo";
    if (!strncmp(*name, "ti", 2)) return "TiRo";
    if (!strncmp(*name, "Sy", 2)) return "Symb";
    if (!strncmp(*name, "sy", 2)) return "Symb";
    if (!strncmp(*name, "Za", 2)) return "ZaDb";
    if (!strncmp(*name, "za", 2)) return "ZaDb";
    return "Helv";
}

void JM_make_annot_DA(fz_context *ctx, pdf_annot *annot, int ncol, float col[4], const char *fontname, float fontsize)
{
    fz_buffer *buf = NULL;
    fz_try(ctx)
    {
        buf = fz_new_buffer(ctx, 50);
       if (ncol == 1)
            fz_append_printf(ctx, buf, "%g g ", col[0]);
        else if (ncol == 3)
            fz_append_printf(ctx, buf, "%g %g %g rg ", col[0], col[1], col[2]);
        else
            fz_append_printf(ctx, buf, "%g %g %g %g k ", col[0], col[1], col[2], col[3]);
        fz_append_printf(ctx, buf, "/%s %g Tf", JM_expand_fname(&fontname), fontsize);
        unsigned char *da = NULL;
        size_t len = fz_buffer_storage(ctx, buf, &da);
        pdf_dict_put_string(ctx, annot->obj, PDF_NAME(DA), (const char *) da, len);
    }
    fz_always(ctx) fz_drop_buffer(ctx, buf);
    fz_catch(ctx) fz_rethrow(ctx);
    return;
}

//------------------------------------------------------------------------
// refreshes the link and annotation tables of a page
//------------------------------------------------------------------------
void JM_refresh_link_table(fz_context *ctx, pdf_page *page)
{
    fz_try(ctx)
    {
        pdf_obj *annots_arr = pdf_dict_get(ctx, page->obj, PDF_NAME(Annots));
        if (annots_arr) {
            fz_rect page_mediabox;
            fz_matrix page_ctm;
            pdf_page_transform(ctx, page, &page_mediabox, &page_ctm);
            page->links = pdf_load_link_annots(ctx, page->doc, annots_arr,
                                            pdf_to_num(ctx, page->obj), page_ctm);
            pdf_load_annots(ctx, page, annots_arr);
        }
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return;
}


PyObject *JM_annot_border(fz_context *ctx, pdf_obj *annot_obj)
{
    PyObject *res = PyDict_New();
    PyObject *dash_py   = PyList_New(0);
    PyObject *effect_py = PyList_New(0);
    PyObject *val;
    int i;
    char *effect2 = NULL, *style = NULL;
    float width = -1.0f;
    int effect1 = -1;

    pdf_obj *o = pdf_dict_get(ctx, annot_obj, PDF_NAME(Border));
    if (pdf_is_array(ctx, o)) {
        width = pdf_to_real(ctx, pdf_array_get(ctx, o, 2));
        if (pdf_array_len(ctx, o) == 4) {
            pdf_obj *dash = pdf_array_get(ctx, o, 3);
            for (i = 0; i < pdf_array_len(ctx, dash); i++) {
                val = Py_BuildValue("i", pdf_to_int(ctx, pdf_array_get(ctx, dash, i)));
                LIST_APPEND_DROP(dash_py, val);
            }
        }
    }

    pdf_obj *bs_o = pdf_dict_get(ctx, annot_obj, PDF_NAME(BS));
    if (bs_o)
    {
        o = pdf_dict_get(ctx, bs_o, PDF_NAME(W));
        if (o) width = pdf_to_real(ctx, o);
        o = pdf_dict_get(ctx, bs_o, PDF_NAME(S));
        if (o) style = (char *) pdf_to_name(ctx, o);
        o = pdf_dict_get(ctx, bs_o, PDF_NAME(D));
        if (o) {
            for (i = 0; i < pdf_array_len(ctx, o); i++) {
                val = Py_BuildValue("i", pdf_to_int(ctx, pdf_array_get(ctx, o, i)));
                LIST_APPEND_DROP(dash_py, val);
            }
        }
    }

    pdf_obj *be_o = pdf_dict_gets(ctx, annot_obj, "BE");
    if (be_o) {
        o = pdf_dict_get(ctx, be_o, PDF_NAME(S));
        if (o) effect2 = (char *) pdf_to_name(ctx, o);
        o = pdf_dict_get(ctx, be_o, PDF_NAME(I));
        if (o) effect1 = pdf_to_int(ctx, o);
    }

    LIST_APPEND_DROP(effect_py, Py_BuildValue("i", effect1));
    LIST_APPEND_DROP(effect_py, Py_BuildValue("s", effect2));
    DICT_SETITEM_DROP(res, dictkey_width, Py_BuildValue("f", width));
    DICT_SETITEM_DROP(res, dictkey_dashes, dash_py);
    DICT_SETITEM_DROP(res, dictkey_style, Py_BuildValue("s", style));
    if (effect1 > -1) PyDict_SetItem(res, dictkey_effect, effect_py);
    Py_CLEAR(effect_py);
    return res;
}

PyObject *JM_annot_set_border(fz_context *ctx, PyObject *border, pdf_document *doc, pdf_obj *annot_obj)
{
    if (!PyDict_Check(border)) {
        JM_Warning("arg must be a dict");
        Py_RETURN_NONE;     // not a dict
    }

    double nwidth = -1;                       // new width
    double owidth = -1;                       // old width
    PyObject *ndashes = NULL;                 // new dashes
    PyObject *odashes = NULL;                 // old dashes
    PyObject *nstyle  = NULL;                 // new style
    PyObject *ostyle  = NULL;                 // old style

    nwidth = PyFloat_AsDouble(PyDict_GetItem(border, dictkey_width));
    ndashes = PyDict_GetItem(border, dictkey_dashes);
    nstyle  = PyDict_GetItem(border, dictkey_style);

    // first get old border properties
    PyObject *oborder = JM_annot_border(ctx, annot_obj);
    owidth = PyFloat_AsDouble(PyDict_GetItem(oborder, dictkey_width));
    odashes = PyDict_GetItem(oborder, dictkey_dashes);
    ostyle = PyDict_GetItem(oborder, dictkey_style);

    // then delete any relevant entries
    pdf_dict_del(ctx, annot_obj, PDF_NAME(BS));
    pdf_dict_del(ctx, annot_obj, PDF_NAME(BE));
    pdf_dict_del(ctx, annot_obj, PDF_NAME(Border));

    Py_ssize_t i, n;
    int d;
    // populate new border array
    if (nwidth < 0) nwidth = owidth;     // no new width: take current
    if (nwidth < 0) nwidth = 0.0f;       // default if no width given
    if (!ndashes) ndashes = odashes;     // no new dashes: take old
    if (!nstyle)  nstyle  = ostyle;      // no new style: take old

    if (ndashes && PySequence_Check(ndashes) && PySequence_Size(ndashes) > 0) {
        n = PySequence_Size(ndashes);
        pdf_obj *darr = pdf_new_array(ctx, doc, n);
        for (i = 0; i < n; i++) {
            d = (int) PyInt_AsLong(PySequence_ITEM(ndashes, i));
            pdf_array_push_int(ctx, darr, (int64_t) d);
        }
        pdf_dict_putl_drop(ctx, annot_obj, darr, PDF_NAME(BS), PDF_NAME(D), NULL);
        nstyle = PyUnicode_FromString("D");
    }

    pdf_dict_putl_drop(ctx, annot_obj, pdf_new_real(ctx, nwidth),
                               PDF_NAME(BS), PDF_NAME(W), NULL);

    pdf_obj *val = JM_get_border_style(ctx, nstyle);

    pdf_dict_putl_drop(ctx, annot_obj, val,
                               PDF_NAME(BS), PDF_NAME(S), NULL);

    PyErr_Clear();
    Py_RETURN_NONE;
}

PyObject *JM_annot_colors(fz_context *ctx, pdf_obj *annot_obj)
{
    PyObject *res = PyDict_New();
    PyObject *bc = PyList_New(0);        // stroke colors
    PyObject *fc = PyList_New(0);        // fill colors
    int i;
    float col;
    pdf_obj *o = pdf_dict_get(ctx, annot_obj, PDF_NAME(C));
    if (pdf_is_array(ctx, o)) {
        int n = pdf_array_len(ctx, o);
        for (i = 0; i < n; i++) {
            col = pdf_to_real(ctx, pdf_array_get(ctx, o, i));
            LIST_APPEND_DROP(bc, Py_BuildValue("f", col));
        }
    }
    DICT_SETITEM_DROP(res, dictkey_stroke, bc);

    o = pdf_dict_gets(ctx, annot_obj, "IC");
    if (pdf_is_array(ctx, o)) {
        int n = pdf_array_len(ctx, o);
        for (i = 0; i < n; i++) {
            col = pdf_to_real(ctx, pdf_array_get(ctx, o, i));
            LIST_APPEND_DROP(fc, Py_BuildValue("f", col));
        }
    }
    DICT_SETITEM_DROP(res, dictkey_fill, fc);

    return res;
}

//------------------------------------------------------------------------
// delete an annotation using mupdf functions, but first delete the /AP
// dict key in annot->obj.
//------------------------------------------------------------------------
void JM_delete_annot(fz_context *ctx, pdf_page *page, pdf_annot *annot)
{
    if (!annot) return;
    fz_try(ctx) {
        // first get any existing popup for the annotation
        pdf_obj *popup = pdf_dict_get(ctx, annot->obj, PDF_NAME(Popup));

        // next delete the /Popup and /AP entries from annot dictionary
        pdf_dict_del(ctx, annot->obj, PDF_NAME(AP));

        pdf_obj *annots = pdf_dict_get(ctx, page->obj, PDF_NAME(Annots));
        int i, n = pdf_array_len(ctx, annots);
        for (i = n - 1; i >= 0; i--) {
            pdf_obj *o = pdf_array_get(ctx, annots, i);
            pdf_obj *p = pdf_dict_get(ctx, o, PDF_NAME(Parent));
            if (!p) continue;
            if (!pdf_objcmp(ctx, p, annot->obj)) {
                pdf_array_delete(ctx, annots, i);
            }
        }
        int type = pdf_annot_type(ctx, annot);
        if (type != PDF_ANNOT_WIDGET) {
            pdf_delete_annot(ctx, page, annot);
        } else {
            JM_delete_widget(ctx, page, annot);
        }
    }
    fz_catch(ctx) {
        fz_warn(ctx, "could not delete annotation");
    }
    return;
}

//------------------------------------------------------------------------
// Return the first annotation whose /IRT key ("In Response To") points to
// annot. Used to remove the response chain of a given annotation.
//------------------------------------------------------------------------
pdf_annot *JM_find_annot_irt(fz_context *ctx, pdf_annot *annot)
{
    pdf_annot *irt_annot = NULL;  // returning this
    pdf_obj *o = NULL;
    pdf_annot **annotptr;
    int found = 0;
    fz_try(ctx) {   // loop thru MuPDF's internal annots array
        pdf_page *page = annot->page;
        for (annotptr = &page->annots; *annotptr; annotptr = &(*annotptr)->next) {
            irt_annot = *annotptr;  // check if this is what we are looking for
            o = pdf_dict_gets(ctx, irt_annot->obj, "IRT");
            if (o) {
                if (!pdf_objcmp(ctx, o, annot->obj)) {
                    found = 1;
                    break;
                }
            }
        }
    }
    fz_catch(ctx) {;}
    if (found) return irt_annot;
    return NULL;
}

//------------------------------------------------------------------------
// return the identifications of a page's annotations (list of /NM entries)
//------------------------------------------------------------------------
PyObject *JM_get_annot_id_list(fz_context *ctx, pdf_page *page)
{
    PyObject *names = PyList_New(0);
    pdf_obj *annot_obj = NULL;
    pdf_obj *annots = pdf_dict_get(ctx, page->obj, PDF_NAME(Annots));
    pdf_obj *name = NULL;
    if (!annots) return names;
    fz_try(ctx) {
        int i, n = pdf_array_len(ctx, annots);
        for (i = 0; i < n; i++) {
            annot_obj = pdf_array_get(ctx, annots, i);
            name = pdf_dict_gets(ctx, annot_obj, "NM");
            if (name) {
                LIST_APPEND_DROP(names, Py_BuildValue("s", pdf_to_text_string(ctx, name)));
            }
        }
    }
    fz_catch(ctx) {
        return names;
    }
    return names;
}


//------------------------------------------------------------------------
// return the xrefs and /NM ids of a page's annots, links and fields
//------------------------------------------------------------------------
PyObject *JM_get_annot_xref_list(fz_context *ctx, pdf_obj *page_obj)
{
    PyObject *names = PyList_New(0);
    pdf_obj *id, *annot_obj = NULL;
    pdf_obj *annots = pdf_dict_get(ctx, page_obj, PDF_NAME(Annots));
    if (!annots) return names;
    fz_try(ctx) {
        int i, n = pdf_array_len(ctx, annots);
        for (i = 0; i < n; i++) {
            annot_obj = pdf_array_get(ctx, annots, i);
            int xref = pdf_to_num(ctx, annot_obj);
            pdf_obj *subtype = pdf_dict_get(ctx, annot_obj, PDF_NAME(Subtype));
            int type = PDF_ANNOT_UNKNOWN;
            if (subtype) {
                const char *name = pdf_to_name(ctx, subtype);
                type = pdf_annot_type_from_string(ctx, name);
            }
            id = pdf_dict_gets(gctx, annot_obj, "NM");
            LIST_APPEND_DROP(names, Py_BuildValue("iis", xref, type,pdf_to_text_string(gctx, id)));
        }
    }
    fz_catch(ctx) {
        return names;
    }
    return names;
}


//------------------------------------------------------------------------
// Add a unique /NM key to an annotation or widget.
// Append a number to 'stem' such that the result is a unique name.
//------------------------------------------------------------------------
static char JM_annot_id_stem[50] = "fitz";
void JM_add_annot_id(fz_context *ctx, pdf_annot *annot, char *stem)
{
    fz_try(ctx) {
        PyObject *names = NULL;
        names = JM_get_annot_id_list(ctx, annot->page);
        int i = 0;
        PyObject *stem_id = NULL;
        while (1) {
            stem_id = PyUnicode_FromFormat("%s-%s%d", JM_annot_id_stem, stem, i);
            if (!PySequence_Contains(names, stem_id)) break;
            i += 1;
            Py_DECREF(stem_id);
        }
        char *response = JM_StrAsChar(stem_id);
        pdf_obj *name = pdf_new_string(ctx, (const char *) response, strlen(response));
        pdf_dict_puts_drop(ctx, annot->obj, "NM", name);
        Py_CLEAR(stem_id);
        Py_CLEAR(names);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
}

//------------------------------------------------------------------------
// retrieve annot by name (/NM key)
//------------------------------------------------------------------------
pdf_annot *JM_get_annot_by_name(fz_context *ctx, pdf_page *page, char *name)
{
    if (!name || strlen(name) == 0) {
        return NULL;
    }
    pdf_annot **annotptr = NULL;
    pdf_annot *annot = NULL;
    int found = 0;
    size_t len = 0;

    fz_try(ctx) {   // loop thru MuPDF's internal annots and widget arrays
        for (annotptr = &page->annots; *annotptr; annotptr = &(*annotptr)->next) {
            annot = *annotptr;
            const char *response = pdf_to_string(ctx, pdf_dict_gets(ctx, annot->obj, "NM"), &len);
            if (strcmp(name, response) == 0) {
                found = 1;
                break;
            }
        }
        if (!found) {
            fz_throw(ctx, FZ_ERROR_GENERIC, "'%s' is not an annot of this page", name);
        }
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return pdf_keep_annot(ctx, annot);
}

//------------------------------------------------------------------------
// retrieve annot by its xref
//------------------------------------------------------------------------
pdf_annot *JM_get_annot_by_xref(fz_context *ctx, pdf_page *page, int xref)
{
    pdf_annot **annotptr = NULL;
    pdf_annot *annot = NULL;
    int found = 0;
    size_t len = 0;

    fz_try(ctx) {   // loop thru MuPDF's internal annots array
        for (annotptr = &page->annots; *annotptr; annotptr = &(*annotptr)->next) {
            annot = *annotptr;
            if (xref == pdf_to_num(ctx, annot->obj)) {
                found = 1;
                break;
            }
        }
        if (!found) {
            fz_throw(ctx, FZ_ERROR_GENERIC, "xref %d is not an annot of this page", xref);
        }
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return pdf_keep_annot(ctx, annot);
}




// Switch for computing glyph of fontsize height
static int small_glyph_heights = 0;

// Switch for returning fontnames including subset prefix
static int subset_fontnames = 0;

// Unset ascender / descender corrections
static int skip_quad_corrections = 0;

// need own versions of ascender / descender
static const float
JM_font_ascender(fz_context *ctx, fz_font *font)
{
    if (skip_quad_corrections) {
        return 0.8f;
    }
    return fz_font_ascender(ctx, font);
}

static const float
JM_font_descender(fz_context *ctx, fz_font *font)
{
    if (skip_quad_corrections) {
        return -0.2f;
    }
    return fz_font_descender(ctx, font);
}


//-----------------------------------------------------------------------------
// Make a text page directly from an fz_page
//-----------------------------------------------------------------------------
fz_stext_page *JM_new_stext_page_from_page(fz_context *ctx, fz_page *page, fz_rect rect, int flags)
{
    if (!page) return NULL;
    fz_stext_page *tp = NULL;
    fz_device *dev = NULL;
    fz_var(dev);
    fz_var(tp);
    fz_stext_options options = { 0 };
    options.flags = flags;
    fz_try(ctx) {
        tp = fz_new_stext_page(ctx, rect);
        dev = fz_new_stext_device(ctx, tp, &options);
        fz_run_page(ctx, page, dev, fz_identity, NULL);
        fz_close_device(ctx, dev);
    }
    fz_always(ctx) {
        fz_drop_device(ctx, dev);
    }
    fz_catch(ctx) {
        fz_drop_stext_page(ctx, tp);
        fz_rethrow(ctx);
    }
    return tp;
}


//---------------------------------------------------------------------------
// APPEND non-ascii runes in unicode escape format to fz_buffer
//---------------------------------------------------------------------------
void JM_append_rune(fz_context *ctx, fz_buffer *buff, int ch)
{
    if (ch >= 32 && ch <= 127 || ch == 10) {
        fz_append_byte(ctx, buff, ch);
    } else if (ch <= 0xffff) {  // 4 hex digits
        fz_append_printf(ctx, buff, "\\u%04x", ch);
    } else {  // 8 hex digits
        fz_append_printf(ctx, buff, "\\U%08x", ch);
    }
}


// re-compute char quad if ascender/descender values make no sense
static fz_quad
JM_char_quad(fz_context *ctx, fz_stext_line *line, fz_stext_char *ch)
{
    if (skip_quad_corrections) {  // no special handling
        return ch->quad;
    }
    if (line->wmode) {  // never touch vertical write mode
        return ch->quad;
    }
    fz_font *font = ch->font;
    float asc = JM_font_ascender(ctx, font);
    float dsc = JM_font_descender(ctx, font);
    if (asc - dsc >= 1 && small_glyph_heights == 0) {  // no problem
       return ch->quad;
    }
    /* ------------------------------
    Re-compute quad with adjusted ascender / descender values:
    Move ch->origin to (0,0) and de-rotate quad, then adjust the corners,
    re-rotate and move back to ch->origin location.
    ------------------------------ */
    float c, s, fsize = ch->size;
    fz_matrix trm1, trm2, xlate1, xlate2;
    fz_quad quad;
    fz_rect bbox = fz_font_bbox(ctx, font);
    float fwidth = bbox.x1 - bbox.x0;
    if (asc < 1e-3) {  // probably Tesseract glyphless font
        dsc = -0.1f;
    }

    // Re-compute asc, dsc if there are problems.
    // In that case, we also do not trust dsc and try correcting it.
    if (asc - dsc < 1) {
        if (bbox.y0 < dsc) {
            dsc = bbox.y0;
        }
        asc = 1 + dsc;
    }

    c = line->dir.x;  // cosine
    s = line->dir.y;  // sine
    trm1 = fz_make_matrix(c, -s, s, c, 0, 0);  // derotate
    trm2 = fz_make_matrix(c, s, -s, c, 0, 0);  // rotate
    xlate1 = fz_make_matrix(1, 0, 0, 1, -ch->origin.x, -ch->origin.y);
    xlate2 = fz_make_matrix(1, 0, 0, 1, ch->origin.x, ch->origin.y);

    quad = fz_transform_quad(ch->quad, xlate1);  // move origin to (0,0)
    quad = fz_transform_quad(quad, trm1);  // de-rotate corners

    // adjust vertical coordinates if meaningful
    if ((quad.ll.y - quad.ul.y) > fsize) {
        quad.ll.y = -fsize * dsc / (asc - dsc);
        quad.ul.y = quad.ll.y - fsize;
        quad.lr.y = quad.ll.y;
        quad.ur.y = quad.ul.y;
    }

    // adjust crazy horizontal coordinates
    if ((quad.lr.x - quad.ll.x) < FLT_EPSILON) {
        quad.lr.x = quad.ll.x + fwidth * fsize;
        quad.ur.x = quad.lr.x;
    }

    quad = fz_transform_quad(quad, trm2);  // rotate back
    quad = fz_transform_quad(quad, xlate2);  // translate back
    return quad;
}


// return rect of char quad
static fz_rect
JM_char_bbox(fz_context *ctx, fz_stext_line *line, fz_stext_char *ch)
{
    fz_rect r = fz_rect_from_quad(JM_char_quad(ctx, line, ch));
    if (!line->wmode) {
        return r;
    }
    if (r.y1 < r.y0 + ch->size) {
        r.y0 = r.y1 - ch->size;
    }
    return r;
}


//-------------------------------------------
// make a buffer from an stext_page's text
//-------------------------------------------
fz_buffer *
JM_new_buffer_from_stext_page(fz_context *ctx, fz_stext_page *page)
{
    fz_stext_block *block;
    fz_stext_line *line;
    fz_stext_char *ch;
    fz_rect rect = page->mediabox;
    fz_buffer *buf = NULL;

    fz_try(ctx)
    {
        buf = fz_new_buffer(ctx, 256);
        for (block = page->first_block; block; block = block->next) {
            if (block->type == FZ_STEXT_BLOCK_TEXT) {
                for (line = block->u.t.first_line; line; line = line->next) {
                    for (ch = line->first_char; ch; ch = ch->next) {
                        if (!fz_contains_rect(rect, JM_char_bbox(ctx, line, ch)) &&
                            !fz_is_infinite_rect(rect)) {
                            continue;
                        }
                        fz_append_rune(ctx, buf, ch->c);
                    }
                    fz_append_byte(ctx, buf, '\n');
                }
                fz_append_byte(ctx, buf, '\n');
            }
        }
    }
    fz_catch(ctx) {
        fz_drop_buffer(ctx, buf);
        fz_rethrow(ctx);
    }
    return buf;
}


static float hdist(fz_point *dir, fz_point *a, fz_point *b)
{
    float dx = b->x - a->x;
    float dy = b->y - a->y;
    return fz_abs(dx * dir->x + dy * dir->y);
}


static float vdist(fz_point *dir, fz_point *a, fz_point *b)
{
    float dx = b->x - a->x;
    float dy = b->y - a->y;
    return fz_abs(dx * dir->y + dy * dir->x);
}


struct highlight
{
    Py_ssize_t len;
    PyObject *quads;
    float hfuzz, vfuzz;
};


static void on_highlight_char(fz_context *ctx, void *arg, fz_stext_line *line, fz_stext_char *ch)
{
    struct highlight *hits = arg;
    float vfuzz = ch->size * hits->vfuzz;
    float hfuzz = ch->size * hits->hfuzz;
    fz_quad ch_quad = JM_char_quad(ctx, line, ch);
    if (hits->len > 0) {
        PyObject *quad = PySequence_ITEM(hits->quads, hits->len - 1);
        fz_quad end = JM_quad_from_py(quad);
        Py_DECREF(quad);
        if (hdist(&line->dir, &end.lr, &ch_quad.ll) < hfuzz
            && vdist(&line->dir, &end.lr, &ch_quad.ll) < vfuzz
            && hdist(&line->dir, &end.ur, &ch_quad.ul) < hfuzz
            && vdist(&line->dir, &end.ur, &ch_quad.ul) < vfuzz)
        {
            end.ur = ch_quad.ur;
            end.lr = ch_quad.lr;
            quad = JM_py_from_quad(end);
            PyList_SetItem(hits->quads, hits->len - 1, quad);
            return;
        }
    }
    LIST_APPEND_DROP(hits->quads, JM_py_from_quad(ch_quad));
    hits->len++;
}


static inline int canon(int c)
{
	/* TODO: proper unicode case folding */
	/* TODO: character equivalence (a matches ä, etc) */
	if (c == 0xA0 || c == 0x2028 || c == 0x2029)
		return ' ';
	if (c == '\r' || c == '\n' || c == '\t')
		return ' ';
	if (c >= 'A' && c <= 'Z')
		return c - 'A' + 'a';
	return c;
}


static inline int chartocanon(int *c, const char *s)
{
	int n = fz_chartorune(c, s);
	*c = canon(*c);
	return n;
}


static const char *match_string(const char *h, const char *n)
{
	int hc, nc;
	const char *e = h;
	h += chartocanon(&hc, h);
	n += chartocanon(&nc, n);
	while (hc == nc)
	{
		e = h;
		if (hc == ' ')
			do
				h += chartocanon(&hc, h);
			while (hc == ' ');
		else
			h += chartocanon(&hc, h);
		if (nc == ' ')
			do
				n += chartocanon(&nc, n);
			while (nc == ' ');
		else
			n += chartocanon(&nc, n);
	}
	return nc == 0 ? e : NULL;
}


static const char *find_string(const char *s, const char *needle, const char **endp)
{
    const char *end;
    while (*s)
    {
        end = match_string(s, needle);
        if (end)
            return *endp = end, s;
        ++s;
    }
    return *endp = NULL, NULL;
}


PyObject *
JM_search_stext_page(fz_context *ctx, fz_stext_page *page, const char *needle)
{
    struct highlight hits;
    fz_stext_block *block;
    fz_stext_line *line;
    fz_stext_char *ch;
    fz_buffer *buffer = NULL;
    const char *haystack, *begin, *end;
    int c, inside;

    if (strlen(needle) == 0) Py_RETURN_NONE;
    PyObject *quads = PyList_New(0);
    hits.len = 0;
    hits.quads = quads;
    hits.hfuzz = 0.2f; /* merge kerns but not large gaps */
    hits.vfuzz = 0.1f;

    fz_try(ctx) {
        buffer = JM_new_buffer_from_stext_page(ctx, page);
        haystack = fz_string_from_buffer(ctx, buffer);
        begin = find_string(haystack, needle, &end);
        if (!begin) goto no_more_matches;

        inside = 0;
        for (block = page->first_block; block; block = block->next) {
            if (block->type != FZ_STEXT_BLOCK_TEXT) {
                continue;
            }
            for (line = block->u.t.first_line; line; line = line->next) {
                for (ch = line->first_char; ch; ch = ch->next) {
try_new_match:
                    if (!inside) {
                        if (haystack >= begin) inside = 1;
                    }
                    if (inside) {
                        if (haystack < end) {
                            on_highlight_char(ctx, &hits, line, ch);
                        } else {
                            inside = 0;
                            begin = find_string(haystack, needle, &end);
                            if (!begin) goto no_more_matches;
                            else goto try_new_match;
                        }
                    }
                    haystack += fz_chartorune(&c, haystack);
                }
                assert(*haystack == '\n');
                ++haystack;
            }
            assert(*haystack == '\n');
            ++haystack;
        }
no_more_matches:;
    }
    fz_always(ctx)
        fz_drop_buffer(ctx, buffer);
    fz_catch(ctx)
        fz_rethrow(ctx);

    return quads;
}


//-----------------------------------------------------------------------------
// Plain text output. An identical copy of fz_print_stext_page_as_text,
// but lines within a block are concatenated by space instead a new-line
// character (which else leads to 2 new-lines).
//-----------------------------------------------------------------------------
void
JM_print_stext_page_as_text(fz_context *ctx, fz_output *out, fz_stext_page *page)
{
    fz_stext_block *block;
    fz_stext_line *line;
    fz_stext_char *ch;
    fz_rect rect = page->mediabox;
    int last_char = 0;

    for (block = page->first_block; block; block = block->next) {
        if (block->type == FZ_STEXT_BLOCK_TEXT) {
            for (line = block->u.t.first_line; line; line = line->next) {
                last_char = 0;
                for (ch = line->first_char; ch; ch = ch->next) {
                    if (fz_is_infinite_rect(rect) ||
                        fz_contains_rect(rect, JM_char_bbox(ctx, line, ch))) {
                        last_char = ch->c;
                        fz_write_rune(ctx, out, ch->c);
                    }
                }
                if (last_char != 10 && last_char) fz_write_string(ctx, out, "\n");
            }
        }
    }
}

//-----------------------------------------------------------------------------
// Functions for wordlist output
//-----------------------------------------------------------------------------
int JM_append_word(fz_context *ctx, PyObject *lines, fz_buffer *buff, fz_rect *wbbox,
                   int block_n, int line_n, int word_n)
{
    PyObject *s = JM_EscapeStrFromBuffer(ctx, buff);
    PyObject *litem = Py_BuildValue("ffffOiii",
                                    wbbox->x0,
                                    wbbox->y0,
                                    wbbox->x1,
                                    wbbox->y1,
                                    s,
                                    block_n, line_n, word_n);
    LIST_APPEND_DROP(lines, litem);
    Py_DECREF(s);
    wbbox->x0 = wbbox->y0 = wbbox->x1 = wbbox->y1 = 0;
    return word_n + 1;                 // word counter
}

//-----------------------------------------------------------------------------
// Functions for dictionary output
//-----------------------------------------------------------------------------

static int detect_super_script(fz_stext_line *line, fz_stext_char *ch)
{
    if (line->wmode == 0 && line->dir.x == 1 && line->dir.y == 0)
        return ch->origin.y < line->first_char->origin.y - ch->size * 0.1f;
    return 0;
}

static int JM_char_font_flags(fz_context *ctx, fz_font *font, fz_stext_line *line, fz_stext_char *ch)
{
    int flags = detect_super_script(line, ch);
    flags += fz_font_is_italic(ctx, font) * TEXT_FONT_ITALIC;
    flags += fz_font_is_serif(ctx, font) * TEXT_FONT_SERIFED;
    flags += fz_font_is_monospaced(ctx, font) * TEXT_FONT_MONOSPACED;
    flags += fz_font_is_bold(ctx, font) * TEXT_FONT_BOLD;
    return flags;
}

static const char *
JM_font_name(fz_context *ctx, fz_font *font)
{
    const char *name = fz_font_name(ctx, font);
    const char *s = strchr(name, '+');
    if (subset_fontnames || s == NULL || s-name != 6) {
        return name;
    }
    return s + 1;
}


static fz_rect
JM_make_spanlist(fz_context *ctx, PyObject *line_dict,
                 fz_stext_line *line, int raw, fz_buffer *buff,
                 fz_rect tp_rect)
{
    PyObject *span = NULL, *char_list = NULL, *char_dict;
    PyObject *span_list = PyList_New(0);
    fz_clear_buffer(ctx, buff);
    fz_stext_char *ch;
    fz_rect span_rect;
    fz_rect line_rect = fz_empty_rect;
    fz_point span_origin;
    typedef struct style_s
    {float size; int flags; const char *font; int color; float asc; float desc;} char_style;

    char_style old_style = { -1, -1, "", -1, 0, 0 }, style;

    for (ch = line->first_char; ch; ch = ch->next) {
//start-trace
        fz_rect r = JM_char_bbox(ctx, line, ch);
        if (!fz_contains_rect(tp_rect, r) &&
            !fz_is_infinite_rect(tp_rect)) {
            continue;
        }

        int flags = JM_char_font_flags(ctx, ch->font, line, ch);
        fz_point origin = ch->origin;
        style.size = ch->size;
        style.flags = flags;
        style.font = JM_font_name(ctx, ch->font);
        style.asc = JM_font_ascender(ctx, ch->font);
        style.desc = JM_font_descender(ctx, ch->font);
        style.color = ch->color;

        if (style.size != old_style.size ||
            style.flags != old_style.flags ||
            style.color != old_style.color ||
            strcmp(style.font, old_style.font) != 0) {

            // style changed -> make new span

            if (old_style.size >= 0) {
                // not first one, output previous
                if (raw) {
                    // put character list in the span
                    DICT_SETITEM_DROP(span, dictkey_chars, char_list);
                    char_list = NULL;
                } else {
                    // put text string in the span
                    DICT_SETITEM_DROP(span, dictkey_text, JM_EscapeStrFromBuffer(ctx, buff));
                    fz_clear_buffer(ctx, buff);
                }

                DICT_SETITEM_DROP(span, dictkey_origin,
                    JM_py_from_point(span_origin));
                DICT_SETITEM_DROP(span, dictkey_bbox,
                    JM_py_from_rect(span_rect));
                line_rect = fz_union_rect(line_rect, span_rect);
                if (!fz_is_empty_rect(span_rect)) {
                    LIST_APPEND_DROP(span_list, span);
                } else {
                    Py_DECREF(span);
                }
                span = NULL;
            }

            span = PyDict_New();
            float asc = style.asc, desc = style.desc;
            if (style.asc < 1e-3) {
                asc = 0.9f;
                desc = -0.1f;
            }

            DICT_SETITEM_DROP(span, dictkey_size, Py_BuildValue("f", style.size));
            DICT_SETITEM_DROP(span, dictkey_flags, Py_BuildValue("i", style.flags));
            DICT_SETITEM_DROP(span, dictkey_font, JM_EscapeStrFromStr(style.font));
            DICT_SETITEM_DROP(span, dictkey_color, Py_BuildValue("i", style.color));
            DICT_SETITEMSTR_DROP(span, "ascender", Py_BuildValue("f", asc));
            DICT_SETITEMSTR_DROP(span, "descender", Py_BuildValue("f", desc));

            old_style = style;
            span_rect = r;
            span_origin = origin;

        }
        span_rect = fz_union_rect(span_rect, r);
        if (origin.y > span_origin.y) {
            span_origin.y = origin.y;
        }

        if (raw) {  // make and append a char dict
            char_dict = PyDict_New();

            DICT_SETITEM_DROP(char_dict, dictkey_origin,
                          JM_py_from_point(ch->origin));

            DICT_SETITEM_DROP(char_dict, dictkey_bbox,
                          JM_py_from_rect(r));

            DICT_SETITEM_DROP(char_dict, dictkey_c,
                          Py_BuildValue("C", ch->c));

            if (!char_list) {
                char_list = PyList_New(0);
            }
            LIST_APPEND_DROP(char_list, char_dict);
        } else {  // add character byte to buffer
            JM_append_rune(ctx, buff, ch->c);
        }
    }
    // all characters processed, now flush remaining span
    if (span) {
        if (raw) {
            DICT_SETITEM_DROP(span, dictkey_chars, char_list);
            char_list = NULL;
        } else {
            DICT_SETITEM_DROP(span, dictkey_text, JM_EscapeStrFromBuffer(ctx, buff));
            fz_clear_buffer(ctx, buff);
        }
        DICT_SETITEM_DROP(span, dictkey_origin, JM_py_from_point(span_origin));
        DICT_SETITEM_DROP(span, dictkey_bbox, JM_py_from_rect(span_rect));

        if (!fz_is_empty_rect(span_rect)) {
            LIST_APPEND_DROP(span_list, span);
            line_rect = fz_union_rect(line_rect, span_rect);
        } else {
            Py_DECREF(span);
        }
        span = NULL;
    }
    if (!fz_is_empty_rect(line_rect)) {
        DICT_SETITEM_DROP(line_dict, dictkey_spans, span_list);
    } else {
        DICT_SETITEM_DROP(line_dict, dictkey_spans, span_list);
    }
//stop-trace
    return line_rect;
}

static void JM_make_image_block(fz_context *ctx, fz_stext_block *block, PyObject *block_dict)
{
    fz_image *image = block->u.i.image;
    fz_buffer *buf = NULL, *freebuf = NULL;
    fz_compressed_buffer *buffer = fz_compressed_image_buffer(ctx, image);
    fz_var(buf);
    fz_var(freebuf);
    int n = fz_colorspace_n(ctx, image->colorspace);
    int w = image->w;
    int h = image->h;
    const char *ext = NULL;
    int type = FZ_IMAGE_UNKNOWN;
    if (buffer)
        type = buffer->params.type;
    if (type < FZ_IMAGE_BMP || type == FZ_IMAGE_JBIG2)
        type = FZ_IMAGE_UNKNOWN;
    PyObject *bytes = NULL;
    fz_var(bytes);
    fz_try(ctx) {
        if (buffer && type != FZ_IMAGE_UNKNOWN) {
            buf = buffer->buffer;
            ext = JM_image_extension(type);
        } else {
            buf = freebuf = fz_new_buffer_from_image_as_png(ctx, image, fz_default_color_params);
            ext = "png";
        }
        bytes = JM_BinFromBuffer(ctx, buf);
    }
    fz_always(ctx) {
        if (!bytes)
            bytes = JM_BinFromChar("");
        DICT_SETITEM_DROP(block_dict, dictkey_width,
                        Py_BuildValue("i", w));
        DICT_SETITEM_DROP(block_dict, dictkey_height,
                        Py_BuildValue("i", h));
        DICT_SETITEM_DROP(block_dict, dictkey_ext,
                        Py_BuildValue("s", ext));
        DICT_SETITEM_DROP(block_dict, dictkey_colorspace,
                        Py_BuildValue("i", n));
        DICT_SETITEM_DROP(block_dict, dictkey_xres,
                        Py_BuildValue("i", image->xres));
        DICT_SETITEM_DROP(block_dict, dictkey_yres,
                        Py_BuildValue("i", image->xres));
        DICT_SETITEM_DROP(block_dict, dictkey_bpc,
                        Py_BuildValue("i", (int) image->bpc));
        DICT_SETITEM_DROP(block_dict, dictkey_matrix,
                        JM_py_from_matrix(block->u.i.transform));
        DICT_SETITEM_DROP(block_dict, dictkey_size,
                        Py_BuildValue("n", (Py_ssize_t) fz_image_size(ctx, image)));
        DICT_SETITEM_DROP(block_dict, dictkey_image, bytes);

        fz_drop_buffer(ctx, freebuf);
    }
    fz_catch(ctx) {;}
    return;
}

static void JM_make_text_block(fz_context *ctx, fz_stext_block *block, PyObject *block_dict, int raw, fz_buffer *buff, fz_rect tp_rect)
{
    fz_stext_line *line;
    PyObject *line_list = PyList_New(0), *line_dict;
    fz_rect block_rect = fz_empty_rect;
    for (line = block->u.t.first_line; line; line = line->next) {
        if (fz_is_empty_rect(fz_intersect_rect(tp_rect, line->bbox)) &&
            !fz_is_infinite_rect(tp_rect)) {
            continue;
        }
        line_dict = PyDict_New();
        fz_rect line_rect = JM_make_spanlist(ctx, line_dict, line, raw, buff, tp_rect);
        block_rect = fz_union_rect(block_rect, line_rect);
        DICT_SETITEM_DROP(line_dict, dictkey_wmode,
                    Py_BuildValue("i", line->wmode));
        DICT_SETITEM_DROP(line_dict, dictkey_dir, JM_py_from_point(line->dir));
        DICT_SETITEM_DROP(line_dict, dictkey_bbox,
                    JM_py_from_rect(line_rect));
        LIST_APPEND_DROP(line_list, line_dict);
    }
    DICT_SETITEM_DROP(block_dict, dictkey_bbox, JM_py_from_rect(block_rect));
    DICT_SETITEM_DROP(block_dict, dictkey_lines, line_list);
    return;
}

void JM_make_textpage_dict(fz_context *ctx, fz_stext_page *tp, PyObject *page_dict, int raw)
{
    fz_stext_block *block;
    fz_buffer *text_buffer = fz_new_buffer(ctx, 128);
    PyObject *block_dict, *block_list = PyList_New(0);
    fz_rect tp_rect = tp->mediabox;
    int block_n = -1;
    for (block = tp->first_block; block; block = block->next) {
        block_n++;
        if (!fz_contains_rect(tp_rect, block->bbox) &&
            !fz_is_infinite_rect(tp_rect) &&
            block->type == FZ_STEXT_BLOCK_IMAGE) {
            continue;
        }
        if (!fz_is_infinite_rect(tp_rect) &&
            fz_is_empty_rect(fz_intersect_rect(tp_rect, block->bbox))) {
            continue;
        }

        block_dict = PyDict_New();
        DICT_SETITEM_DROP(block_dict, dictkey_number, Py_BuildValue("i", block_n));
        DICT_SETITEM_DROP(block_dict, dictkey_type, Py_BuildValue("i", block->type));
        if (block->type == FZ_STEXT_BLOCK_IMAGE) {
            DICT_SETITEM_DROP(block_dict, dictkey_bbox, JM_py_from_rect(block->bbox));
            JM_make_image_block(ctx, block, block_dict);
        } else {
            JM_make_text_block(ctx, block, block_dict, raw, text_buffer, tp_rect);
        }

        LIST_APPEND_DROP(block_list, block_dict);
    }
    DICT_SETITEM_DROP(page_dict, dictkey_blocks, block_list);
    fz_drop_buffer(ctx, text_buffer);
}


fz_buffer *JM_object_to_buffer(fz_context *ctx, pdf_obj *what, int compress, int ascii)
{
    fz_buffer *res=NULL;
    fz_output *out=NULL;
    fz_try(ctx) {
        res = fz_new_buffer(ctx, 512);
        out = fz_new_output_with_buffer(ctx, res);
        pdf_print_obj(ctx, out, what, compress, ascii);
    }
    fz_always(ctx) {
        fz_drop_output(ctx, out);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    fz_terminate_buffer(ctx, res);
    return res;
}

//-----------------------------------------------------------------------------
// Merge the /Resources object created by a text pdf device into the page.
// The device may have created multiple /ExtGState/Alp? and /Font/F? objects.
// These need to be renamed (renumbered) to not overwrite existing page
// objects from previous executions.
// Returns the next available numbers n, m for objects /Alp<n>, /F<m>.
//-----------------------------------------------------------------------------
PyObject *JM_merge_resources(fz_context *ctx, pdf_page *page, pdf_obj *temp_res)
{
    // page objects /Resources, /Resources/ExtGState, /Resources/Font
    pdf_obj *resources = pdf_dict_get(ctx, page->obj, PDF_NAME(Resources));
    pdf_obj *main_extg = pdf_dict_get(ctx, resources, PDF_NAME(ExtGState));
    pdf_obj *main_fonts = pdf_dict_get(ctx, resources, PDF_NAME(Font));

    // text pdf device objects /ExtGState, /Font
    pdf_obj *temp_extg = pdf_dict_get(ctx, temp_res, PDF_NAME(ExtGState));
    pdf_obj *temp_fonts = pdf_dict_get(ctx, temp_res, PDF_NAME(Font));


    int max_alp = -1, max_fonts = -1, i, n;
    char text[20];

    // Handle /Alp objects
    if (pdf_is_dict(ctx, temp_extg))  // any created at all?
    {
        n = pdf_dict_len(ctx, temp_extg);
        if (pdf_is_dict(ctx, main_extg)) {  // does page have /ExtGState yet?
            for (i = 0; i < pdf_dict_len(ctx, main_extg); i++) {
                // get highest number of objects named /Alpxxx
                char *alp = (char *) pdf_to_name(ctx, pdf_dict_get_key(ctx, main_extg, i));
                if (strncmp(alp, "Alp", 3) != 0) continue;
                int j = fz_atoi(alp + 3);
                if (j > max_alp) max_alp = j;
            }
        }
        else  // create a /ExtGState for the page
            main_extg = pdf_dict_put_dict(ctx, resources, PDF_NAME(ExtGState), n);

        max_alp += 1;
        for (i = 0; i < n; i++)  // copy over renumbered /Alp objects
        {
            char *alp = (char *) pdf_to_name(ctx, pdf_dict_get_key(ctx, temp_extg, i));
            int j = fz_atoi(alp + 3) + max_alp;
            fz_snprintf(text, sizeof(text), "Alp%d", j);  // new name
            pdf_obj *val = pdf_dict_get_val(ctx, temp_extg, i);
            pdf_dict_puts(ctx, main_extg, text, val);
        }
    }


    if (pdf_is_dict(ctx, main_fonts)) { // has page any fonts yet?
        for (i = 0; i < pdf_dict_len(ctx, main_fonts); i++) { // get max font number
            char *font = (char *) pdf_to_name(ctx, pdf_dict_get_key(ctx, main_fonts, i));
            if (strncmp(font, "F", 1) != 0) continue;
            int j = fz_atoi(font + 1);
            if (j > max_fonts) max_fonts = j;
        }
    }
    else  // create a Resources/Font for the page
        main_fonts = pdf_dict_put_dict(ctx, resources, PDF_NAME(Font), 2);

    max_fonts += 1;
    for (i = 0; i < pdf_dict_len(ctx, temp_fonts); i++) { // copy renumbered fonts
        char *font = (char *) pdf_to_name(ctx, pdf_dict_get_key(ctx, temp_fonts, i));
        int j = fz_atoi(font + 1) + max_fonts;
        fz_snprintf(text, sizeof(text), "F%d", j);
        pdf_obj *val = pdf_dict_get_val(ctx, temp_fonts, i);
        pdf_dict_puts(ctx, main_fonts, text, val);
    }
    return Py_BuildValue("ii", max_alp, max_fonts); // next available numbers
}


//-----------------------------------------------------------------------------
// version of fz_show_string, which also covers UCDN script
//-----------------------------------------------------------------------------
fz_matrix JM_show_string(fz_context *ctx, fz_text *text, fz_font *user_font, fz_matrix trm, const char *s, int wmode, int bidi_level, fz_bidi_direction markup_dir, fz_text_language language, int script)
{
    fz_font *font;
    int gid, ucs;
    float adv;

    while (*s) {
        s += fz_chartorune(&ucs, s);
        gid = fz_encode_character_with_fallback(ctx, user_font, ucs, script, language, &font);
        fz_show_glyph(ctx, text, font, trm, gid, ucs, wmode, bidi_level, markup_dir, language);
        adv = fz_advance_glyph(ctx, font, gid, wmode);
        if (wmode == 0)
            trm = fz_pre_translate(trm, adv, 0);
        else
            trm = fz_pre_translate(trm, 0, -adv);
    }
    return trm;
}


//-----------------------------------------------------------------------------
// return a fz_font from a number of parameters
//-----------------------------------------------------------------------------
fz_font *JM_get_font(fz_context *ctx,
    char *fontname,
    char *fontfile,
    PyObject *fontbuffer,
    int script,
    int lang,
    int ordering,
    int is_bold,
    int is_italic,
    int is_serif)
{
    const unsigned char *data = NULL;
    int size, index=0;
    fz_buffer *res = NULL;
    fz_font *font = NULL;
    fz_try(ctx) {
        if (fontfile) goto have_file;
        if (EXISTS(fontbuffer)) goto have_buffer;
        if (ordering > -1) goto have_cjk;
        if (fontname) goto have_base14;
        goto have_noto;

        // Base-14 font
        have_base14:;
        data = fz_lookup_base14_font(ctx, fontname, &size);
        if (data) font = fz_new_font_from_memory(ctx, fontname, data, size, 0, 0);
        if(font) goto fertig;

        data = fz_lookup_builtin_font(ctx, fontname, is_bold, is_italic, &size);
        if (data) font = fz_new_font_from_memory(ctx, fontname, data, size, 0, 0);
        goto fertig;

        // CJK font
        have_cjk:;
        data = fz_lookup_cjk_font(ctx, ordering, &size, &index);
        if (data) font = fz_new_font_from_memory(ctx, NULL, data, size, index, 0);
        goto fertig;

        // fontfile
        have_file:;
        font = fz_new_font_from_file(ctx, NULL, fontfile, index, 0);
        goto fertig;

        // fontbuffer
        have_buffer:;
        res = JM_BufferFromBytes(ctx, fontbuffer);
        font = fz_new_font_from_buffer(ctx, NULL, res, index, 0);
        goto fertig;

        // Check for NOTO font
        have_noto:;
        data = fz_lookup_noto_font(ctx, script, lang, &size, &index);
        if (data) font = fz_new_font_from_memory(ctx, NULL, data, size, index, 0);
        if (font) goto fertig;
        font = fz_load_fallback_font(ctx, script, lang, is_serif, is_bold, is_italic);
        goto fertig;

        fertig:;
        if (!font) THROWMSG(ctx, "could not create font");
    }
    fz_always(ctx) {
        fz_drop_buffer(ctx, res);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return font;
}



#define SETATTR(a, v) PyObject_SetAttrString(Widget, a, v)
#define GETATTR(a) PyObject_GetAttrString(Widget, a)
#define CALLATTR(m, p) PyObject_CallMethod(Widget, m, p)

static void
SETATTR_DROP(PyObject *mod, const char *attr, PyObject *value)
{
    if (!value)
        PyObject_DelAttrString(mod, attr);
    else
    {
        PyObject_SetAttrString(mod, attr, value);
        Py_DECREF(value);
    }
}

//-----------------------------------------------------------------------------
// Functions dealing with PDF form fields (widgets)
//-----------------------------------------------------------------------------
enum
{
	SigFlag_SignaturesExist = 1,
	SigFlag_AppendOnly = 2
};


// make new PDF action object from JavaScript source
// Parameters are a PDF document and a Python string.
// Returns a PDF action object.
//-----------------------------------------------------------------------------
pdf_obj *
JM_new_javascript(fz_context *ctx, pdf_document *pdf, PyObject *value)
{
    fz_buffer *res = NULL;
    if (!PyObject_IsTrue(value))  // no argument given
        return NULL;

    char *data = JM_StrAsChar(value);
    if (!data)  // not convertible to char*
        return NULL;

    res = fz_new_buffer_from_copied_data(ctx, data, strlen(data));
    pdf_obj *source = pdf_add_stream(ctx, pdf, res, NULL, 0);
    pdf_obj *newaction = pdf_add_new_dict(ctx, pdf, 4);
    pdf_dict_put(ctx, newaction, PDF_NAME(S), pdf_new_name(ctx, "JavaScript"));
    pdf_dict_put(ctx, newaction, PDF_NAME(JS), source);
    fz_drop_buffer(ctx, res);
    return pdf_keep_obj(ctx, newaction);
}


// JavaScript extractor
// Returns either the script source or None. Parameter is a PDF action
// dictionary, which must have keys /S and /JS. The value of /S must be
// '/JavaScript'. The value of /JS is returned.
//-----------------------------------------------------------------------------
PyObject *
JM_get_script(fz_context *ctx, pdf_obj *key)
{
    pdf_obj *js = NULL;
    fz_buffer *res = NULL;
    PyObject *script = NULL;
    if (!key) Py_RETURN_NONE;

    if (!strcmp(pdf_to_name(ctx,
                pdf_dict_get(ctx, key, PDF_NAME(S))), "JavaScript")) {
        js = pdf_dict_get(ctx, key, PDF_NAME(JS));
    }
    if (!js) Py_RETURN_NONE;

    if (pdf_is_string(ctx, js)) {
        script = JM_UnicodeFromStr(pdf_to_text_string(ctx, js));
    } else if (pdf_is_stream(ctx, js)) {
        res = pdf_load_stream(ctx, js);
        script = JM_EscapeStrFromBuffer(ctx, res);
        fz_drop_buffer(ctx, res);
    } else {
        Py_RETURN_NONE;
    }
    if (PyObject_IsTrue(script)) { // do not return an empty script
        return script;
    }
    Py_CLEAR(script);
    Py_RETURN_NONE;
}


// Create a JavaScript PDF action.
// Usable for all object types which support PDF actions, even if the
// argument name suggests annotations. Up to 2 key values can be specified, so
// JavaScript actions can be stored for '/A' and '/AA/?' keys.
//-----------------------------------------------------------------------------
void JM_put_script(fz_context *ctx, pdf_obj *annot_obj, pdf_obj *key1, pdf_obj *key2, PyObject *value)
{
    PyObject *script = NULL;
    pdf_obj *key1_obj = pdf_dict_get(ctx, annot_obj, key1);
    pdf_document *pdf = pdf_get_bound_document(ctx, annot_obj);  // owning PDF

    // if no new script given, just delete corresponding key
    if (!value || !PyObject_IsTrue(value)) {
        if (!key2) {
            pdf_dict_del(ctx, annot_obj, key1);
        } else if (key1_obj) {
            pdf_dict_del(ctx, key1_obj, key2);
        }
        return;
    }

    // read any existing script as a PyUnicode string
    if (!key2 || !key1_obj) {
        script = JM_get_script(ctx, key1_obj);
    } else {
        script = JM_get_script(ctx, pdf_dict_get(ctx, key1_obj, key2));
    }

    // replace old script, if different from new one
    if (!PyObject_RichCompareBool(value, script, Py_EQ)) {
        pdf_obj *newaction = JM_new_javascript(ctx, pdf, value);
        if (!key2) {
            pdf_dict_put_drop(ctx, annot_obj, key1, newaction);
        } else {
            pdf_dict_putl_drop(ctx, annot_obj, newaction, key1, key2, NULL);
        }
    }
    Py_XDECREF(script);
    return;
}

/*
// Execute a JavaScript action for annot or field.
//-----------------------------------------------------------------------------
PyObject *
JM_exec_script(fz_context *ctx, pdf_obj *annot_obj, pdf_obj *key1, pdf_obj *key2)
{
    PyObject *script = NULL;
    char *code = NULL;
    fz_try(ctx) {
        pdf_document *pdf = pdf_get_bound_document(ctx, annot_obj);
        char buf[100];
        if (!key2) {
            script = JM_get_script(ctx, key1_obj);
        } else {
            script = JM_get_script(ctx, pdf_dict_get(ctx, key1_obj, key2));
        }
        code = JM_StrAsChar(script);
        fz_snprintf(buf, sizeof buf, "%d/A", pdf_to_num(ctx, annot_obj));
        pdf_js_execute(pdf->js, buf, code);
    }
    fz_always(ctx) {
        Py_XDECREF(string);
    }
    fz_catch(ctx) {
        Py_RETURN_FALSE;
    }
    Py_RETURN_TRUE;
}
*/

// String from widget type
//-----------------------------------------------------------------------------
char *JM_field_type_text(int wtype)
{
    switch(wtype) {
        case(PDF_WIDGET_TYPE_BUTTON):
            return "Button";
        case(PDF_WIDGET_TYPE_CHECKBOX):
            return "CheckBox";
        case(PDF_WIDGET_TYPE_RADIOBUTTON):
            return "RadioButton";
        case(PDF_WIDGET_TYPE_TEXT):
            return "Text";
        case(PDF_WIDGET_TYPE_LISTBOX):
            return "ListBox";
        case(PDF_WIDGET_TYPE_COMBOBOX):
            return "ComboBox";
        case(PDF_WIDGET_TYPE_SIGNATURE):
            return "Signature";
        default:
            return "unknown";
    }
}

// Set the field type
//-----------------------------------------------------------------------------
void JM_set_field_type(fz_context *ctx, pdf_document *doc, pdf_obj *obj, int type)
{
	int setbits = 0;
	int clearbits = 0;
	pdf_obj *typename = NULL;

	switch(type) {
	case PDF_WIDGET_TYPE_BUTTON:
		typename = PDF_NAME(Btn);
		setbits = PDF_BTN_FIELD_IS_PUSHBUTTON;
		break;
	case PDF_WIDGET_TYPE_CHECKBOX:
		typename = PDF_NAME(Btn);
		clearbits = PDF_BTN_FIELD_IS_PUSHBUTTON;
		setbits = PDF_BTN_FIELD_IS_RADIO;
		break;
	case PDF_WIDGET_TYPE_RADIOBUTTON:
		typename = PDF_NAME(Btn);
		clearbits = (PDF_BTN_FIELD_IS_PUSHBUTTON|PDF_BTN_FIELD_IS_RADIO);
		break;
	case PDF_WIDGET_TYPE_TEXT:
		typename = PDF_NAME(Tx);
		break;
	case PDF_WIDGET_TYPE_LISTBOX:
		typename = PDF_NAME(Ch);
		clearbits = PDF_CH_FIELD_IS_COMBO;
		break;
	case PDF_WIDGET_TYPE_COMBOBOX:
		typename = PDF_NAME(Ch);
		setbits = PDF_CH_FIELD_IS_COMBO;
		break;
	case PDF_WIDGET_TYPE_SIGNATURE:
		typename = PDF_NAME(Sig);
		break;
	}

	if (typename)
		pdf_dict_put_drop(ctx, obj, PDF_NAME(FT), typename);

	if (setbits != 0 || clearbits != 0) {
		int bits = pdf_dict_get_int(ctx, obj, PDF_NAME(Ff));
		bits &= ~clearbits;
		bits |= setbits;
		pdf_dict_put_int(ctx, obj, PDF_NAME(Ff), bits);
	}
}

// Copied from MuPDF v1.14
// Create widget
//-----------------------------------------------------------------------------
pdf_annot *JM_create_widget(fz_context *ctx, pdf_document *doc, pdf_page *page, int type, char *fieldname)
{
	pdf_obj *form = NULL;
	int old_sigflags = pdf_to_int(ctx, pdf_dict_getp(ctx, pdf_trailer(ctx, doc), "Root/AcroForm/SigFlags"));
	pdf_annot *annot = pdf_create_annot_raw(ctx, page, PDF_ANNOT_WIDGET);

	fz_try(ctx) {
		JM_set_field_type(ctx, doc, annot->obj, type);
		pdf_dict_put_text_string(ctx, annot->obj, PDF_NAME(T), fieldname);

		if (type == PDF_WIDGET_TYPE_SIGNATURE) {
			int sigflags = (old_sigflags | (SigFlag_SignaturesExist|SigFlag_AppendOnly));
			pdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc), pdf_new_int(ctx, sigflags), PDF_NAME(Root), PDF_NAME(AcroForm), PDF_NAME(SigFlags), NULL);
		}

		/*
		pdf_create_annot will have linked the new widget into the page's
		annot array. We also need it linked into the document's form
		*/
		form = pdf_dict_getp(ctx, pdf_trailer(ctx, doc), "Root/AcroForm/Fields");
		if (!form) {
			form = pdf_new_array(ctx, doc, 1);
			pdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc),
                               form,
                               PDF_NAME(Root),
                               PDF_NAME(AcroForm),
                               PDF_NAME(Fields),
                               NULL);
		}

		pdf_array_push(ctx, form, annot->obj); // Cleanup relies on this statement being last
	}
	fz_catch(ctx) {
		pdf_delete_annot(ctx, page, annot);

		if (type == PDF_WIDGET_TYPE_SIGNATURE) {
			pdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc), pdf_new_int(ctx, old_sigflags), PDF_NAME(Root), PDF_NAME(AcroForm), PDF_NAME(SigFlags), NULL);
        }

		fz_rethrow(ctx);
	}

	return annot;
}


void
JM_delete_widget(fz_context *ctx, pdf_page *page, pdf_annot *annot)
{
    pdf_document *doc = annot->page->doc;
    pdf_annot **annotptr;
    pdf_obj *annot_arr, *obj;
    int i;

    if (annot == NULL)
        return;

    // Remove widget from page's list
    for (annotptr = &page->widgets; *annotptr; annotptr = &(*annotptr)->next) {
        if (*annotptr == annot)
            break;
    }

    // Check whether passed annotation was of this page
    if (*annotptr == NULL)
        return;

    *annotptr = pdf_next_widget(gctx, (pdf_widget *) annot);

    // If the removed field was the last in the list adjust the end pointer
    if (*annotptr == NULL)
        page->widget_tailp = annotptr;

    annot_arr = pdf_dict_get(ctx, page->obj, PDF_NAME(Annots));
    i = pdf_array_find(ctx, annot_arr, annot->obj);
    if (i >= 0)
        pdf_array_delete(ctx, annot_arr, i);

    // remove any Popup for the field
    obj = pdf_dict_get(ctx, annot->obj, PDF_NAME(Popup));
    if (obj) {
        i = pdf_array_find(ctx, annot_arr, obj);
        if (i >= 0)
            pdf_array_delete(ctx, annot_arr, i);
    }

    // remove field from AcroForm
    obj = pdf_dict_getp(ctx, pdf_trailer(ctx, doc), "Root/AcroForm/Fields");
    if (pdf_is_array(ctx, obj)) {
        i = pdf_array_find(ctx, obj, annot->obj);
        if (i >= 0)
            pdf_array_delete(ctx, obj, i);
    }

    pdf_drop_annot(ctx, annot);
    doc->dirty = 1;
}


// PushButton get state
//-----------------------------------------------------------------------------
PyObject *JM_pushbtn_state(fz_context *ctx, pdf_annot *annot)
{   // pushed buttons do not reflect status changes in the PDF
    // always reflect them as untouched
    Py_RETURN_FALSE;
}

// CheckBox get state
//-----------------------------------------------------------------------------
PyObject *JM_checkbox_state(fz_context *ctx, pdf_annot *annot)
{
    pdf_obj *leafv = pdf_dict_get_inheritable(ctx, annot->obj, PDF_NAME(V));
    pdf_obj *leafas = pdf_dict_get_inheritable(ctx, annot->obj, PDF_NAME(AS));
    if (!leafv) Py_RETURN_FALSE;
    if (leafv == PDF_NAME(Off)) Py_RETURN_FALSE;
    if (leafv == pdf_new_name(ctx, "Yes"))
        Py_RETURN_TRUE;
    if (pdf_is_string(ctx, leafv) && !strcmp(pdf_to_text_string(ctx, leafv), "Off"))
        Py_RETURN_FALSE;
    if (pdf_is_string(ctx, leafv) && !strcmp(pdf_to_text_string(ctx, leafv), "Yes"))
        Py_RETURN_TRUE;
    if (leafas && leafas == PDF_NAME(Off)) Py_RETURN_FALSE;
    Py_RETURN_TRUE;
}

// RadioBox get state
//-----------------------------------------------------------------------------
PyObject *JM_radiobtn_state(fz_context *ctx, pdf_annot *annot)
{   // MuPDF treats radio buttons like check boxes - hence so do we
    return JM_checkbox_state(ctx, annot);
}

// Text field retrieve value
//-----------------------------------------------------------------------------
PyObject *JM_text_value(fz_context *ctx, pdf_annot *annot)
{
    const char *text = NULL;
    fz_var(text);
    fz_try(ctx)
        text = pdf_field_value(ctx, annot->obj);
    fz_catch(ctx) Py_RETURN_NONE;
    return JM_UnicodeFromStr(text);
}

// ListBox retrieve value
//-----------------------------------------------------------------------------
PyObject *JM_listbox_value(fz_context *ctx, pdf_annot *annot)
{
    int i = 0, n = 0;
    // may be single value or array
    pdf_obj *optarr = pdf_dict_get(ctx, annot->obj, PDF_NAME(V));
    if (pdf_is_string(ctx, optarr))         // a single string
        return PyString_FromString(pdf_to_text_string(ctx, optarr));

    // value is an array (may have len 0)
    n = pdf_array_len(ctx, optarr);
    PyObject *liste = PyList_New(0);

    // extract a list of strings
    // each entry may again be an array: take second entry then
    for (i = 0; i < n; i++) {
        pdf_obj *elem = pdf_array_get(ctx, optarr, i);
        if (pdf_is_array(ctx, elem))
            elem = pdf_array_get(ctx, elem, 1);
        LIST_APPEND_DROP(liste, JM_UnicodeFromStr(pdf_to_text_string(ctx, elem)));
    }
    return liste;
}

// ComboBox retrieve value
//-----------------------------------------------------------------------------
PyObject *JM_combobox_value(fz_context *ctx, pdf_annot *annot)
{   // combobox treated like listbox
    return JM_listbox_value(ctx, annot);
}

// Signature field retrieve value
PyObject *JM_signature_value(fz_context *ctx, pdf_annot *annot)
{   // signatures are currently not supported
    Py_RETURN_NONE;
}

// retrieve ListBox / ComboBox choice values
//-----------------------------------------------------------------------------
PyObject *JM_choice_options(fz_context *ctx, pdf_annot *annot)
{   // return list of choices for list or combo boxes
    pdf_document *pdf = pdf_get_bound_document(ctx, annot->obj);
    PyObject *val;
    int n = pdf_choice_widget_options(ctx, (pdf_widget *) annot, 0, NULL);
    if (n == 0) Py_RETURN_NONE;                     // wrong widget type

    pdf_obj *optarr = pdf_dict_get(ctx, annot->obj, PDF_NAME(Opt));
    int i, m;
    PyObject *liste = PyList_New(0);

    for (i = 0; i < n; i++) {
        m = pdf_array_len(ctx, pdf_array_get(ctx, optarr, i));
        if (m == 2) {
            val = Py_BuildValue("ss",
            pdf_to_text_string(ctx, pdf_array_get(ctx, pdf_array_get(ctx, optarr, i), 0)),
            pdf_to_text_string(ctx, pdf_array_get(ctx, pdf_array_get(ctx, optarr, i), 1)));
            LIST_APPEND_DROP(liste, val);
        } else {
            val = JM_UnicodeFromStr(pdf_to_text_string(ctx, pdf_array_get(ctx, optarr, i)));
            LIST_APPEND_DROP(liste, val);
        }
    }
    return liste;
}


// set ListBox / ComboBox values
//-----------------------------------------------------------------------------
void JM_set_choice_options(fz_context *ctx, pdf_annot *annot, PyObject *liste)
{
    if (!liste) return;
    if (!PySequence_Check(liste)) return;
    Py_ssize_t i, n = PySequence_Size(liste);
    if (n < 1) return;
    pdf_document *pdf = pdf_get_bound_document(ctx, annot->obj);
    char *opt = NULL;
    pdf_obj *optarr = pdf_new_array(ctx, pdf, n);
    PyObject *val = NULL;
    for (i = 0; i < n; i++) {
        val = PySequence_ITEM(liste, i);
        opt = JM_StrAsChar(val);
        pdf_array_push_text_string(ctx, optarr, (const char *) opt);
        Py_CLEAR(val);
    }

    pdf_dict_put(ctx, annot->obj, PDF_NAME(Opt), optarr);
    return;
}


//-----------------------------------------------------------------------------
// Populate a Python Widget object with the values from a PDF form field.
// Called by "Page.firstWidget" and "Widget.next".
//-----------------------------------------------------------------------------
void JM_get_widget_properties(fz_context *ctx, pdf_annot *annot, PyObject *Widget)
{
    pdf_document *pdf = annot->page->doc;
    pdf_widget *tw = (pdf_widget *) annot;
    pdf_obj *obj = NULL, *js = NULL, *o = NULL;
    fz_buffer *res = NULL;
    Py_ssize_t i = 0, n = 0;
    fz_try(ctx) {
        int field_type = pdf_widget_type(gctx, tw);
        SETATTR_DROP(Widget, "field_type", Py_BuildValue("i", field_type));
        if (field_type == PDF_WIDGET_TYPE_SIGNATURE) {
            if (pdf_signature_is_signed(ctx, pdf, annot->obj)) {
                SETATTR("is_signed", Py_True);
            } else {
                SETATTR("is_signed", Py_False);
            }
        } else {
            SETATTR("is_signed", Py_None);
        }
        SETATTR_DROP(Widget, "border_style",
                JM_UnicodeFromStr(pdf_field_border_style(ctx, annot->obj)));
        SETATTR_DROP(Widget, "field_type_string",
                JM_UnicodeFromStr(JM_field_type_text(field_type)));

        char *field_name = pdf_field_name(ctx, annot->obj);
        SETATTR_DROP(Widget, "field_name", JM_UnicodeFromStr(field_name));
        JM_Free(field_name);

        const char *label = NULL;
        obj = pdf_dict_get(ctx, annot->obj, PDF_NAME(TU));
        if (obj) label = pdf_to_text_string(ctx, obj);
        SETATTR_DROP(Widget, "field_label", JM_UnicodeFromStr(label));

        SETATTR_DROP(Widget, "field_value",
                JM_UnicodeFromStr(pdf_field_value(ctx, annot->obj)));

        SETATTR_DROP(Widget, "field_display",
                Py_BuildValue("i", pdf_field_display(ctx, annot->obj)));

        float border_width = pdf_to_real(ctx, pdf_dict_getl(ctx, annot->obj,
                                PDF_NAME(BS), PDF_NAME(W), NULL));
        if (border_width == 0) border_width = 1;
        SETATTR_DROP(Widget, "border_width",
                Py_BuildValue("f", border_width));

        obj = pdf_dict_getl(ctx, annot->obj,
                                PDF_NAME(BS), PDF_NAME(D), NULL);
        if (pdf_is_array(ctx, obj)) {
            n = (Py_ssize_t) pdf_array_len(ctx, obj);
            PyObject *d = PyList_New(n);
            for (i = 0; i < n; i++) {
                PyList_SET_ITEM(d, i, Py_BuildValue("i", pdf_to_int(ctx,
                                pdf_array_get(ctx, obj, (int) i))));
            }
            SETATTR_DROP(Widget, "border_dashes", d);
        }

        SETATTR_DROP(Widget, "text_maxlen",
                Py_BuildValue("i", pdf_text_widget_max_len(ctx, tw)));

        SETATTR_DROP(Widget, "text_format",
                Py_BuildValue("i", pdf_text_widget_format(ctx, tw)));

        obj = pdf_dict_getl(ctx, annot->obj, PDF_NAME(MK), PDF_NAME(BG), NULL);
        if (pdf_is_array(ctx, obj)) {
            n = (Py_ssize_t) pdf_array_len(ctx, obj);
            PyObject *col = PyList_New(n);
            for (i = 0; i < n; i++) {
                PyList_SET_ITEM(col, i, Py_BuildValue("f",
                pdf_to_real(ctx, pdf_array_get(ctx, obj, (int) i))));
            }
            SETATTR_DROP(Widget, "fill_color", col);
        }

        obj = pdf_dict_getl(ctx, annot->obj, PDF_NAME(MK), PDF_NAME(BC), NULL);
        if (pdf_is_array(ctx, obj)) {
            n = (Py_ssize_t) pdf_array_len(ctx, obj);
            PyObject *col = PyList_New(n);
            for (i = 0; i < n; i++) {
                PyList_SET_ITEM(col, i, Py_BuildValue("f",
                pdf_to_real(ctx, pdf_array_get(ctx, obj, (int) i))));
            }
            SETATTR_DROP(Widget, "border_color", col);
        }

        SETATTR_DROP(Widget, "choice_values", JM_choice_options(ctx, annot));

        const char *da = pdf_to_text_string(ctx, pdf_dict_get_inheritable(ctx,
                                        annot->obj, PDF_NAME(DA)));
        SETATTR_DROP(Widget, "_text_da", JM_UnicodeFromStr(da));

        obj = pdf_dict_getl(ctx, annot->obj, PDF_NAME(MK), PDF_NAME(CA), NULL);
        if (obj) {
            SETATTR_DROP(Widget, "button_caption",
                    JM_UnicodeFromStr((char *)pdf_to_text_string(ctx, obj)));
        }

        SETATTR_DROP(Widget, "field_flags",
                Py_BuildValue("i", pdf_field_flags(ctx, annot->obj)));

        // call Py method to reconstruct text color, font name, size
        PyObject *call = CALLATTR("_parse_da", NULL);
        Py_XDECREF(call);

        // extract JavaScript action texts
        SETATTR_DROP(Widget, "script",
            JM_get_script(ctx, pdf_dict_get(ctx, annot->obj, PDF_NAME(A))));

        SETATTR_DROP(Widget, "script_stroke",
            JM_get_script(ctx, pdf_dict_getl(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(K), NULL)));

        SETATTR_DROP(Widget, "script_format",
            JM_get_script(ctx, pdf_dict_getl(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(F), NULL)));

        SETATTR_DROP(Widget, "script_change",
            JM_get_script(ctx, pdf_dict_getl(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(V), NULL)));

        SETATTR_DROP(Widget, "script_calc",
            JM_get_script(ctx, pdf_dict_getl(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(C), NULL)));
    }
    fz_always(ctx) PyErr_Clear();
    fz_catch(ctx) fz_rethrow(ctx);
    return;
}


//-----------------------------------------------------------------------------
// Update the PDF form field with the properties from a Python Widget object.
// Called by "Page.addWidget" and "Annot.updateWidget".
//-----------------------------------------------------------------------------
void JM_set_widget_properties(fz_context *ctx, pdf_annot *annot, PyObject *Widget)
{
    pdf_document *pdf = annot->page->doc;
    pdf_page *page = annot->page;
    fz_rect rect;
    pdf_obj *fill_col = NULL, *border_col = NULL;
    pdf_obj *dashes = NULL;
    Py_ssize_t i, n = 0;
    int d;
    int result = 0;
    PyObject *value = GETATTR("field_type");
    int field_type = (int) PyInt_AsLong(value);
    Py_DECREF(value);

    // rectangle --------------------------------------------------------------
    value = GETATTR("rect");
    rect = JM_rect_from_py(value);
    Py_XDECREF(value);
    fz_matrix rot_mat = JM_rotate_page_matrix(ctx, page);
    rect = fz_transform_rect(rect, rot_mat);
    pdf_set_annot_rect(ctx, annot, rect);

    // fill color -------------------------------------------------------------
    value = GETATTR("fill_color");
    if (value && PySequence_Check(value)) {
        n = PySequence_Size(value);
        fill_col = pdf_new_array(ctx, pdf, n);
        double col = 0;
        for (i = 0; i < n; i++) {
            JM_FLOAT_ITEM(value, i, &col);
            pdf_array_push_real(ctx, fill_col, col);
        }
        pdf_field_set_fill_color(ctx, annot->obj, fill_col);
        pdf_drop_obj(ctx, fill_col);
    }
    Py_XDECREF(value);

    // dashes -----------------------------------------------------------------
    value = GETATTR("border_dashes");
    if (value && PySequence_Check(value)) {
        n = PySequence_Size(value);
        dashes = pdf_new_array(ctx, pdf, n);
        for (i = 0; i < n; i++) {
            pdf_array_push_int(ctx, dashes,
                               (int64_t) PyInt_AsLong(PySequence_ITEM(value, i)));
        }
        pdf_dict_putl_drop(ctx, annot->obj, dashes,
                                PDF_NAME(BS),
                                PDF_NAME(D),
                                NULL);
    }
    Py_XDECREF(value);

    // border color -----------------------------------------------------------
    value = GETATTR("border_color");
    if (value && PySequence_Check(value)) {
        n = PySequence_Size(value);
        border_col = pdf_new_array(ctx, pdf, n);
        double col = 0;
        for (i = 0; i < n; i++) {
            JM_FLOAT_ITEM(value, i, &col);
            pdf_array_push_real(ctx, border_col, col);
        }
        pdf_dict_putl_drop(ctx, annot->obj, border_col,
                                PDF_NAME(MK),
                                PDF_NAME(BC),
                                NULL);
    }
    Py_XDECREF(value);

    // entry ignored - may be used later
    /*
    int text_format = (int) PyInt_AsLong(GETATTR("text_format"));
    */

    // field label -----------------------------------------------------------
    value = GETATTR("field_label");
    if (value != Py_None) {
        char *label = JM_StrAsChar(value);
        pdf_dict_put_text_string(ctx, annot->obj, PDF_NAME(TU), label);
    }
    Py_XDECREF(value);

    // field name -------------------------------------------------------------
    value = GETATTR("field_name");
    if (value != Py_None) {
        char *name = JM_StrAsChar(value);
        char *old_name = pdf_field_name(ctx, annot->obj);
        if (strcmp(name, old_name) != 0) {
            pdf_dict_put_text_string(ctx, annot->obj, PDF_NAME(T), name);
        }
        JM_Free(old_name);
    }
    Py_XDECREF(value);

    // max text len -----------------------------------------------------------
    if (field_type == PDF_WIDGET_TYPE_TEXT)
    {
        value = GETATTR("text_maxlen");
        int text_maxlen = (int) PyInt_AsLong(value);
        if (text_maxlen) {
            pdf_dict_put_int(ctx, annot->obj, PDF_NAME(MaxLen), text_maxlen);
        }
        Py_XDECREF(value);
    }
    value = GETATTR("field_display");
    d = (int) PyInt_AsLong(value);
    Py_XDECREF(value);
    pdf_field_set_display(ctx, annot->obj, d);

    // choice values ----------------------------------------------------------
    if (field_type == PDF_WIDGET_TYPE_LISTBOX ||
        field_type == PDF_WIDGET_TYPE_COMBOBOX) {
        value = GETATTR("choice_values");
        JM_set_choice_options(ctx, annot, value);
        Py_XDECREF(value);
    }

    // border style -----------------------------------------------------------
    value = GETATTR("border_style");
    pdf_obj *val = JM_get_border_style(ctx, value);
    Py_XDECREF(value);
    pdf_dict_putl_drop(ctx, annot->obj, val,
                            PDF_NAME(BS),
                            PDF_NAME(S),
                            NULL);

    // border width -----------------------------------------------------------
    value = GETATTR("border_width");
    float border_width = (float) PyFloat_AsDouble(value);
    Py_XDECREF(value);
    pdf_dict_putl_drop(ctx, annot->obj, pdf_new_real(ctx, border_width),
                            PDF_NAME(BS),
                            PDF_NAME(W),
                            NULL);

    // /DA string -------------------------------------------------------------
    value = GETATTR("_text_da");
    char *da = JM_StrAsChar(value);
    Py_XDECREF(value);
    pdf_dict_put_text_string(ctx, annot->obj, PDF_NAME(DA), da);
    pdf_dict_del(ctx, annot->obj, PDF_NAME(DS)); /* not supported by MuPDF */
    pdf_dict_del(ctx, annot->obj, PDF_NAME(RC)); /* not supported by MuPDF */

    // field flags ------------------------------------------------------------
    int field_flags = 0, Ff = 0;
    if (field_type != PDF_WIDGET_TYPE_CHECKBOX) {
        value = GETATTR("field_flags");
        field_flags = (int) PyInt_AsLong(value);
        if (!PyErr_Occurred()) {
            Ff = pdf_field_flags(ctx, annot->obj);
            Ff |= field_flags;
        }
        Py_XDECREF(value);
    }
    pdf_dict_put_int(ctx, annot->obj, PDF_NAME(Ff), Ff);

    // button caption ---------------------------------------------------------
    value = GETATTR("button_caption");
    char *ca = JM_StrAsChar(value);
    if (ca) {
        pdf_field_set_button_caption(ctx, annot->obj, ca);
    }
    Py_XDECREF(value);

    // script (/A) -------------------------------------------------------
    value = GETATTR("script");
    JM_put_script(ctx, annot->obj, PDF_NAME(A), NULL, value);
    Py_CLEAR(value);

    // script (/AA/K) -------------------------------------------------------
    value = GETATTR("script_stroke");
    JM_put_script(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(K), value);
    Py_CLEAR(value);

    // script (/AA/F) -------------------------------------------------------
    value = GETATTR("script_format");
    JM_put_script(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(F), value);
    Py_CLEAR(value);

    // script (/AA/V) -------------------------------------------------------
    value = GETATTR("script_change");
    JM_put_script(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(V), value);
    Py_CLEAR(value);

    // script (/AA/C) -------------------------------------------------------
    value = GETATTR("script_calc");
    JM_put_script(ctx, annot->obj, PDF_NAME(AA), PDF_NAME(C), value);
    Py_CLEAR(value);

    // field value ------------------------------------------------------------
    value = GETATTR("field_value");
    char *text = NULL;
    switch(field_type)
    {
    case PDF_WIDGET_TYPE_CHECKBOX:
    case PDF_WIDGET_TYPE_RADIOBUTTON:
        if (PyObject_RichCompareBool(value, Py_True, Py_EQ)) {
            pdf_obj *onstate = pdf_button_field_on_state(ctx, annot->obj);
            const char *on = pdf_to_name(ctx, onstate);
            result = pdf_set_field_value(ctx, pdf, annot->obj, on, 1);
            pdf_dict_put_name(ctx, annot->obj, PDF_NAME(V), on);
        } else {
            result = pdf_set_field_value(ctx, pdf, annot->obj, "Off", 1);
            pdf_dict_put(ctx, annot->obj, PDF_NAME(V), PDF_NAME(Off));
        }
        break;
    default:
        text = JM_StrAsChar(value);
        if (text) {
            result = pdf_set_field_value(ctx, pdf, annot->obj, (const char *)text, 1);
        }
    }
    Py_CLEAR(value);
    PyErr_Clear();
    pdf_dirty_annot(ctx, annot);
    annot->is_hot = 1;
    annot->is_active = 1;
    pdf_update_appearance(ctx, annot);
}
#undef SETATTR
#undef GETATTR
#undef CALLATTR


//-----------------------------------------------------------------------------
// perform some cleaning if we have /EmbeddedFiles:
// (1) remove any /Limits if /Names exists
// (2) remove any empty /Collection
// (3) set /PageMode/UseAttachments
//-----------------------------------------------------------------------------
void JM_embedded_clean(fz_context *ctx, pdf_document *pdf)
{
    pdf_obj *root = pdf_dict_get(ctx, pdf_trailer(ctx, pdf), PDF_NAME(Root));

    // remove any empty /Collection entry
    pdf_obj *coll = pdf_dict_get(ctx, root, PDF_NAME(Collection));
    if (coll && pdf_dict_len(ctx, coll) == 0)
        pdf_dict_del(ctx, root, PDF_NAME(Collection));

    pdf_obj *efiles = pdf_dict_getl(ctx, root,
                                    PDF_NAME(Names),
                                    PDF_NAME(EmbeddedFiles),
                                    PDF_NAME(Names),
                                    NULL);
    if (efiles) {
        pdf_dict_put_name(ctx, root, PDF_NAME(PageMode), "UseAttachments");
    }
    return;
}

//-----------------------------------------------------------------------------
// embed a new file in a PDF (not only /EmbeddedFiles entries)
//-----------------------------------------------------------------------------
pdf_obj *JM_embed_file(fz_context *ctx,
                       pdf_document *pdf,
                       fz_buffer *buf,
                       char *filename,
                       char *ufilename,
                       char *desc,
                       int compress)
{
    size_t len = 0;
    pdf_obj *ef, *f, *params, *val = NULL;
    fz_var(val);
    fz_try(ctx) {
        val = pdf_new_dict(ctx, pdf, 6);
        pdf_dict_put_dict(ctx, val, PDF_NAME(CI), 4);
        ef = pdf_dict_put_dict(ctx, val, PDF_NAME(EF), 4);
        pdf_dict_put_text_string(ctx, val, PDF_NAME(F), filename);
        pdf_dict_put_text_string(ctx, val, PDF_NAME(UF), ufilename);
        pdf_dict_put_text_string(ctx, val, PDF_NAME(Desc), desc);
        pdf_dict_put(ctx, val, PDF_NAME(Type), PDF_NAME(Filespec));
        f = pdf_add_stream(ctx, pdf,
                           fz_new_buffer_from_copied_data(ctx, "  ", 1),
                           NULL, 0);
        pdf_dict_put_drop(ctx, ef, PDF_NAME(F), f);
        JM_update_stream(ctx, pdf, f, buf, compress);
        len = fz_buffer_storage(ctx, buf, NULL);
        pdf_dict_put_int(ctx, f, PDF_NAME(DL), len);
        pdf_dict_put_int(ctx, f, PDF_NAME(Length), len);
        params = pdf_dict_put_dict(ctx, f, PDF_NAME(Params), 4);
        pdf_dict_put_int(ctx, params, PDF_NAME(Size), len);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return val;
}


//----------------------------------------------------------------------------
// Helpers for document page selection - main logic was imported
// from pdf_clean_file.c. But instead of analyzing a string-based spec of
// selected pages, we accept a Python sequence.
//----------------------------------------------------------------------------
typedef struct globals_s
{
    pdf_document *doc;
    fz_context *ctx;
} globals;

int string_in_names_list(fz_context *ctx, pdf_obj *p, pdf_obj *names_list)
{
    int n = pdf_array_len(ctx, names_list);
    int i;
    const char *str = pdf_to_text_string(ctx, p);

    for (i = 0; i < n ; i += 2)
    {
        if (!strcmp(pdf_to_text_string(ctx, pdf_array_get(ctx, names_list, i)), str))
            return 1;
    }
    return 0;
}

//----------------------------------------------------------------------------
// Recreate page tree to only retain specified pages.
//----------------------------------------------------------------------------
void retainpage(fz_context *ctx, pdf_document *doc, pdf_obj *parent, pdf_obj *kids, int page)
{
    pdf_obj *pageref = pdf_lookup_page_obj(ctx, doc, page);

    pdf_flatten_inheritable_page_items(ctx, pageref);

    pdf_dict_put(ctx, pageref, PDF_NAME(Parent), parent);

    /* Store page object in new kids array */
    pdf_array_push(ctx, kids, pageref);
}

int dest_is_valid_page(fz_context *ctx, pdf_obj *obj, int *page_object_nums, int pagecount)
{
    int i;
    int num = pdf_to_num(ctx, obj);

    if (num == 0)
        return 0;
    for (i = 0; i < pagecount; i++)
    {
        if (page_object_nums[i] == num)
            return 1;
    }
    return 0;
}

int dest_is_valid(fz_context *ctx, pdf_obj *o, int page_count, int *page_object_nums, pdf_obj *names_list)
{
    pdf_obj *p;

    p = pdf_dict_get(ctx, o, PDF_NAME(A));
    if (pdf_name_eq(ctx, pdf_dict_get(ctx, p, PDF_NAME(S)), PDF_NAME(GoTo)) &&
        !string_in_names_list(ctx, pdf_dict_get(ctx, p, PDF_NAME(D)), names_list))
        return 0;

    p = pdf_dict_get(ctx, o, PDF_NAME(Dest));
    if (p == NULL)
    {}
    else if (pdf_is_string(ctx, p))
    {
        return string_in_names_list(ctx, p, names_list);
    }
    else if (!dest_is_valid_page(ctx, pdf_array_get(ctx, p, 0), page_object_nums, page_count))
        return 0;

    return 1;
}

int strip_outlines(fz_context *ctx, pdf_document *doc, pdf_obj *outlines, int page_count, int *page_object_nums, pdf_obj *names_list);

int strip_outline(fz_context *ctx, pdf_document *doc, pdf_obj *outlines, int page_count, int *page_object_nums, pdf_obj *names_list, pdf_obj **pfirst, pdf_obj **plast)
{
    pdf_obj *prev = NULL;
    pdf_obj *first = NULL;
    pdf_obj *current;
    int count = 0;

    for (current = outlines; current != NULL; )
    {
        int nc;

        /*********************************************************************/
        // Strip any children to start with. This takes care of
        // First / Last / Count for us.
        /*********************************************************************/
        nc = strip_outlines(ctx, doc, current, page_count, page_object_nums, names_list);

        if (!dest_is_valid(ctx, current, page_count, page_object_nums, names_list))
        {
            if (nc == 0)
            {
                /*************************************************************/
                // Outline with invalid dest and no children. Drop it by
                // pulling the next one in here.
                /*************************************************************/
                pdf_obj *next = pdf_dict_get(ctx, current, PDF_NAME(Next));
                if (next == NULL)
                {
                    // There is no next one to pull in
                    if (prev != NULL)
                        pdf_dict_del(ctx, prev, PDF_NAME(Next));
                }
                else if (prev != NULL)
                {
                    pdf_dict_put(ctx, prev, PDF_NAME(Next), next);
                    pdf_dict_put(ctx, next, PDF_NAME(Prev), prev);
                }
                else
                {
                    pdf_dict_del(ctx, next, PDF_NAME(Prev));
                }
                current = next;
            }
            else
            {
                // Outline with invalid dest, but children. Just drop the dest.
                pdf_dict_del(ctx, current, PDF_NAME(Dest));
                pdf_dict_del(ctx, current, PDF_NAME(A));
                current = pdf_dict_get(ctx, current, PDF_NAME(Next));
            }
        }
        else
        {
            // Keep this one
            if (first == NULL)
                first = current;
            prev = current;
            current = pdf_dict_get(ctx, current, PDF_NAME(Next));
            count++;
        }
    }

    *pfirst = first;
    *plast = prev;

    return count;
}

int strip_outlines(fz_context *ctx, pdf_document *doc, pdf_obj *outlines, int page_count, int *page_object_nums, pdf_obj *names_list)
{
    int nc;
    pdf_obj *first;
    pdf_obj *last;

    if (outlines == NULL)
        return 0;

    first = pdf_dict_get(ctx, outlines, PDF_NAME(First));
    if (first == NULL)
        nc = 0;
    else
        nc = strip_outline(ctx, doc, first, page_count, page_object_nums,
                           names_list, &first, &last);

    if (nc == 0)
    {
        pdf_dict_del(ctx, outlines, PDF_NAME(First));
        pdf_dict_del(ctx, outlines, PDF_NAME(Last));
        pdf_dict_del(ctx, outlines, PDF_NAME(Count));
    }
    else
    {
        int old_count = pdf_to_int(ctx, pdf_dict_get(ctx, outlines, PDF_NAME(Count)));
        pdf_dict_put(ctx, outlines, PDF_NAME(First), first);
        pdf_dict_put(ctx, outlines, PDF_NAME(Last), last);
        pdf_dict_put_drop(ctx, outlines, PDF_NAME(Count), pdf_new_int(ctx, old_count > 0 ? nc : -nc));
    }
    return nc;
}

//----------------------------------------------------------------------------
//   This is called by PyMuPDF:
//   liste = page numbers to retain
//----------------------------------------------------------------------------
void retainpages(fz_context *ctx, globals *glo, PyObject *liste)
{
    pdf_obj *oldroot, *root, *pages, *kids, *countobj, *olddests;
    Py_ssize_t argc = PySequence_Size(liste);
    pdf_document *doc = glo->doc;
    pdf_obj *names_list = NULL;
    pdf_obj *outlines;
    pdf_obj *ocproperties;
    int pagecount = pdf_count_pages(ctx, doc);

    int i;
    int *page_object_nums;

/******************************************************************************/
//    Keep only pages/type and (reduced) dest entries to avoid
//    references to dropped pages
/******************************************************************************/
    oldroot = pdf_dict_get(ctx, pdf_trailer(ctx, doc), PDF_NAME(Root));
    pages = pdf_dict_get(ctx, oldroot, PDF_NAME(Pages));
    olddests = pdf_load_name_tree(ctx, doc, PDF_NAME(Dests));
    outlines = pdf_dict_get(ctx, oldroot, PDF_NAME(Outlines));
    ocproperties = pdf_dict_get(ctx, oldroot, PDF_NAME(OCProperties));

    root = pdf_new_dict(ctx, doc, 3);
    pdf_dict_put(ctx, root, PDF_NAME(Type), pdf_dict_get(ctx, oldroot, PDF_NAME(Type)));
    pdf_dict_put(ctx, root, PDF_NAME(Pages), pdf_dict_get(ctx, oldroot, PDF_NAME(Pages)));
    if (outlines)
        pdf_dict_put(ctx, root, PDF_NAME(Outlines), outlines);
    if (ocproperties)
        pdf_dict_put(ctx, root, PDF_NAME(OCProperties), ocproperties);

    pdf_update_object(ctx, doc, pdf_to_num(ctx, oldroot), root);

    // Create a new kids array with only the pages we want to keep
    kids = pdf_new_array(ctx, doc, 1);

    // Retain pages specified
    Py_ssize_t page;
    fz_try(ctx) {
        for (page = 0; page < argc; page++) {
            i = (int) PyInt_AsLong(PySequence_ITEM(liste, page));
            if (i < 0 || i >= pagecount)
                THROWMSG(ctx, "invalid page number(s)");
            retainpage(ctx, doc, pages, kids, i);
        }
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }

    // Update page count and kids array
    countobj = pdf_new_int(ctx, pdf_array_len(ctx, kids));
    pdf_dict_put_drop(ctx, pages, PDF_NAME(Count), countobj);
    pdf_dict_put_drop(ctx, pages, PDF_NAME(Kids), kids);

    pagecount = pdf_count_pages(ctx, doc);
    page_object_nums = fz_calloc(ctx, pagecount, sizeof(*page_object_nums));
    for (i = 0; i < pagecount; i++)
    {
        pdf_obj *pageref = pdf_lookup_page_obj(ctx, doc, i);
        page_object_nums[i] = pdf_to_num(ctx, pageref);
    }

/******************************************************************************/
// If we had an old Dests tree (now reformed as an olddests dictionary),
// keep any entries in there that point to valid pages.
// This may mean we keep more than we need, but it is safe at least.
/******************************************************************************/
    if (olddests)
    {
        pdf_obj *names = pdf_new_dict(ctx, doc, 1);
        pdf_obj *dests = pdf_new_dict(ctx, doc, 1);
        int len = pdf_dict_len(ctx, olddests);

        names_list = pdf_new_array(ctx, doc, 32);

        for (i = 0; i < len; i++)
        {
            pdf_obj *key = pdf_dict_get_key(ctx, olddests, i);
            pdf_obj *val = pdf_dict_get_val(ctx, olddests, i);
            pdf_obj *dest = pdf_dict_get(ctx, val, PDF_NAME(D));

            dest = pdf_array_get(ctx, dest ? dest : val, 0);
            if (dest_is_valid_page(ctx, dest, page_object_nums, pagecount))
            {
                pdf_obj *key_str = pdf_new_string(ctx, pdf_to_name(ctx, key), strlen(pdf_to_name(ctx, key)));
                pdf_array_push_drop(ctx, names_list, key_str);
                pdf_array_push(ctx, names_list, val);
            }
        }

        pdf_dict_put(ctx, dests, PDF_NAME(Names), names_list);
        pdf_dict_put(ctx, names, PDF_NAME(Dests), dests);
        pdf_dict_put(ctx, root, PDF_NAME(Names), names);

        pdf_drop_obj(ctx, names);
        pdf_drop_obj(ctx, dests);
        pdf_drop_obj(ctx, olddests);
    }

/*****************************************************************************/
// Edit each pages /Annot list to remove any links pointing to nowhere.
/*****************************************************************************/
    for (i = 0; i < pagecount; i++)
    {
        pdf_obj *pageref = pdf_lookup_page_obj(ctx, doc, i);

        pdf_obj *annots = pdf_dict_get(ctx, pageref, PDF_NAME(Annots));

        int len = pdf_array_len(ctx, annots);
        int j;

        for (j = 0; j < len; j++)
        {
            pdf_obj *o = pdf_array_get(ctx, annots, j);

            if (!pdf_name_eq(ctx, pdf_dict_get(ctx, o, PDF_NAME(Subtype)), PDF_NAME(Link)))
                continue;

            if (!dest_is_valid(ctx, o, pagecount, page_object_nums, names_list))
            {
                // Remove this annotation
                pdf_array_delete(ctx, annots, j);
                len--;
                j--;
            }
        }
    }

    if (strip_outlines(ctx, doc, outlines, pagecount, page_object_nums, names_list) == 0)
    {
        pdf_dict_del(ctx, root, PDF_NAME(Outlines));
    }

    fz_free(ctx, page_object_nums);
    pdf_drop_obj(ctx, names_list);
    pdf_drop_obj(ctx, root);
}

void remove_dest_range(fz_context *ctx, pdf_document *pdf, PyObject *numbers)
{
    int i, j, pno, len, pagecount = pdf_count_pages(ctx, pdf);
    PyObject *n1 = NULL;
    fz_try(ctx) {
        for (i = 0; i < pagecount; i++) {
            n1 = PyLong_FromLong((long) i);
            if (PySequence_Contains(numbers, n1)) {
                Py_DECREF(n1);
                continue;
            }
            Py_DECREF(n1);

            pdf_obj *pageref = pdf_lookup_page_obj(ctx, pdf, i);
            pdf_obj *annots = pdf_dict_get(ctx, pageref, PDF_NAME(Annots));
            pdf_obj *target;
            if (!annots) continue;
            len = pdf_array_len(ctx, annots);
            for (j = len - 1; j >= 0; j -= 1) {
                pdf_obj *o = pdf_array_get(ctx, annots, j);
                if (!pdf_name_eq(ctx, pdf_dict_get(ctx, o, PDF_NAME(Subtype)), PDF_NAME(Link)))
                    continue;
                pdf_obj *action = pdf_dict_get(ctx, o, PDF_NAME(A));
                pdf_obj *dest =  pdf_dict_get(ctx, o, PDF_NAME(Dest));
                if (action) {
                    if (!pdf_name_eq(ctx, pdf_dict_get(ctx, action,
                        PDF_NAME(S)), PDF_NAME(GoTo)))
                        continue;
                    dest = pdf_dict_get(ctx, action, PDF_NAME(D));
                }
                pno = -1;
                if (pdf_is_array(ctx, dest)) {
                    target = pdf_array_get(ctx, dest, 0);
                    pno = pdf_lookup_page_number(ctx, pdf, target);
                }
                else if (pdf_is_string(ctx, dest)) {
                    pno = pdf_lookup_anchor(ctx, pdf,
                                            pdf_to_text_string(ctx, dest),
                                            NULL, NULL);
                }
                if (pno < 0) { // page lookup did not work
                    continue;
                }
                n1 = PyLong_FromLong((long) pno);
                if (PySequence_Contains(numbers, n1)) {
                    pdf_array_delete(ctx, annots, j);
                }
                Py_DECREF(n1);
            }
        }
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return;
}


//-----------------------------------------------------------------------------
// Read and concatenate a PDF page's /Conents object(s) in a buffer
//-----------------------------------------------------------------------------
fz_buffer *JM_read_contents(fz_context * ctx, pdf_obj * pageref)
{
    fz_buffer *res = NULL, *nres = NULL;
    int i;
    fz_try(ctx) {
        pdf_obj *contents = pdf_dict_get(ctx, pageref, PDF_NAME(Contents));
        if (pdf_is_array(ctx, contents)) {
            res = fz_new_buffer(ctx, 1024);
            for (i = 0; i < pdf_array_len(ctx, contents); i++) {
                nres = pdf_load_stream(ctx, pdf_array_get(ctx, contents, i));
                fz_append_buffer(ctx, res, nres);
                fz_drop_buffer(ctx, nres);
            }
        }
        else if (contents) {
            res = pdf_load_stream(ctx, contents);
        }
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return res;
}

//-----------------------------------------------------------------------------
// Make an XObject from a PDF page
// For a positive xref assume that that object can be used instead
//-----------------------------------------------------------------------------
pdf_obj *JM_xobject_from_page(fz_context * ctx, pdf_document * pdfout, fz_page * fsrcpage, int xref, pdf_graft_map *gmap)
{
    pdf_obj *xobj1, *resources = NULL, *o, *spageref;
    fz_try(ctx) {
        if (xref > 0) {
            xobj1 = pdf_new_indirect(ctx, pdfout, xref, 0);
        } else {
            fz_buffer *res = NULL;
            fz_rect mediabox;
            pdf_page *srcpage = pdf_page_from_fz_page(ctx, fsrcpage);
            spageref = srcpage->obj;
            mediabox = pdf_to_rect(ctx, pdf_dict_get_inheritable(ctx, spageref, PDF_NAME(MediaBox)));
            // Deep-copy resources object of source page
            o = pdf_dict_get_inheritable(ctx, spageref, PDF_NAME(Resources));
            if (gmap) // use graftmap when possible
                resources = pdf_graft_mapped_object(ctx, gmap, o);
            else
                resources = pdf_graft_object(ctx, pdfout, o);

            // get spgage contents source
            res = JM_read_contents(ctx, spageref);

            //-------------------------------------------------------------
            // create XObject representing the source page
            //-------------------------------------------------------------
            xobj1 = pdf_new_xobject(ctx, pdfout, mediabox, fz_identity, NULL, res);
            // store spage contents
            JM_update_stream(ctx, pdfout, xobj1, res, 1);
            fz_drop_buffer(ctx, res);

            // store spage resources
            pdf_dict_put_drop(ctx, xobj1, PDF_NAME(Resources), resources);
        }
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return xobj1;
}

//-----------------------------------------------------------------------------
// Insert a buffer as a new separate /Contents object of a page.
// 1. Create a new stream object from buffer 'newcont'
// 2. If /Contents already is an array, then just prepend or append this object
// 3. Else, create new array and put old content obj and this object into it.
//    If the page had no /Contents before, just create a 1-item array.
//-----------------------------------------------------------------------------
int JM_insert_contents(fz_context * ctx, pdf_document * pdf,
                        pdf_obj * pageref, fz_buffer * newcont, int overlay)
{
    int xref = 0;
    fz_try(ctx) {
        pdf_obj *contents = pdf_dict_get(ctx, pageref, PDF_NAME(Contents));
        pdf_obj *newconts = pdf_add_stream(ctx, pdf, newcont, NULL, 0);
        xref = pdf_to_num(ctx, newconts);
        if (pdf_is_array(ctx, contents)) {
            if (overlay) // append new object
                pdf_array_push(ctx, contents, newconts);
            else // prepend new object
                pdf_array_insert(ctx, contents, newconts, 0);
        } else {
            pdf_obj *carr = pdf_new_array(ctx, pdf, 5);
            if (overlay) {
                if (contents)
                    pdf_array_push(ctx, carr, contents);
                pdf_array_push(ctx, carr, newconts);
            } else {
                pdf_array_push_drop(ctx, carr, newconts);
                if (contents)
                    pdf_array_push(ctx, carr, contents);
            }
            pdf_dict_put(ctx, pageref, PDF_NAME(Contents), carr);
        }
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return xref;
}

static PyObject *img_info = NULL;

static fz_image *
JM_image_filter(fz_context *ctx, void *opaque, fz_matrix ctm, const char *name, fz_image *image)
{
    fz_quad q = fz_transform_quad(fz_quad_from_rect(fz_unit_rect), ctm);
    PyObject *temp = Py_BuildValue("sN", name, JM_py_from_quad(q));
    LIST_APPEND_DROP(img_info, temp);
    return NULL;
}

void
JM_filter_content_stream(
    fz_context * ctx,
    pdf_document * doc,
    pdf_obj * in_stm,
    pdf_obj * in_res,
    fz_matrix transform,
    pdf_filter_options * filter,
    int struct_parents,
    fz_buffer **out_buf,
    pdf_obj **out_res)
{
    pdf_processor *proc_buffer = NULL;
    pdf_processor *proc_filter = NULL;

    fz_var(proc_buffer);
    fz_var(proc_filter);

    *out_buf = NULL;
    *out_res = NULL;

    fz_try(ctx) {
		*out_buf = fz_new_buffer(ctx, 1024);
		proc_buffer = pdf_new_buffer_processor(ctx, *out_buf, filter->ascii);
		if (filter->sanitize) {
			*out_res = pdf_new_dict(ctx, doc, 1);
			proc_filter = pdf_new_filter_processor(ctx, doc, proc_buffer, in_res, *out_res, struct_parents, transform, filter);
			pdf_process_contents(ctx, proc_filter, doc, in_res, in_stm, NULL);
			pdf_close_processor(ctx, proc_filter);
		} else {
			*out_res = pdf_keep_obj(ctx, in_res);
			pdf_process_contents(ctx, proc_buffer, doc, in_res, in_stm, NULL);
		}
		pdf_close_processor(ctx, proc_buffer);
    }
    fz_always(ctx) {
        pdf_drop_processor(ctx, proc_filter);
        pdf_drop_processor(ctx, proc_buffer);
    }
    fz_catch(ctx) {
        fz_drop_buffer(ctx, *out_buf);
        *out_buf = NULL;
        pdf_drop_obj(ctx, *out_res);
        *out_res = NULL;
        fz_rethrow(ctx);
    }
}

PyObject *
JM_image_reporter(fz_context *ctx, pdf_page *page)
{
    pdf_document *doc = page->doc;
    pdf_filter_options filter;
    memset(&filter, 0, sizeof filter);
    filter.opaque = page;
    filter.text_filter = NULL;
    filter.image_filter = JM_image_filter;
    filter.end_page = NULL;
    filter.recurse = 0;
    filter.instance_forms = 1;
    filter.sanitize = 1;
    filter.ascii = 1;

    pdf_obj *contents, *old_res;
    pdf_obj *struct_parents_obj;
    pdf_obj *new_res;
    fz_buffer *buffer;
    int struct_parents;
    fz_matrix ctm = fz_identity;
    pdf_page_transform(gctx, page, NULL, &ctm);
    struct_parents_obj = pdf_dict_get(ctx, page->obj, PDF_NAME(StructParents));
    struct_parents = -1;
    if (pdf_is_number(ctx, struct_parents_obj))
        struct_parents = pdf_to_int(ctx, struct_parents_obj);

    contents = pdf_page_contents(ctx, page);
    old_res = pdf_page_resources(ctx, page);
    img_info = PyList_New(0);
    JM_filter_content_stream(ctx, doc, contents, old_res, ctm, &filter, struct_parents, &buffer, &new_res);
    fz_drop_buffer(ctx, buffer);
    pdf_drop_obj(ctx, new_res);
    PyObject *rc = PySequence_Tuple(img_info);
    Py_CLEAR(img_info);
    return rc;
}




//------------------------------------------------------------------------
// Store ID in PDF trailer
//------------------------------------------------------------------------
void JM_ensure_identity(fz_context *ctx, pdf_document *pdf)
{
    unsigned char rnd[16];
    pdf_obj *id;
    id = pdf_dict_get(ctx, pdf_trailer(ctx, pdf), PDF_NAME(ID));
    if (!id) {
        fz_memrnd(ctx, rnd, nelem(rnd));
        id = pdf_dict_put_array(ctx, pdf_trailer(ctx, pdf), PDF_NAME(ID), 2);
        pdf_array_push_drop(ctx, id, pdf_new_string(ctx, (char *) rnd + 0, nelem(rnd)));
        pdf_array_push_drop(ctx, id, pdf_new_string(ctx, (char *) rnd + 0, nelem(rnd)));
    }
}


//------------------------------------------------------------------------
// Ensure OCProperties, return /OCProperties key
//------------------------------------------------------------------------
pdf_obj *
JM_ensure_ocproperties(fz_context *ctx, pdf_document *pdf)
{
    pdf_obj *D, *ocp;
    fz_try(ctx) {
        ocp = pdf_dict_get(ctx, pdf_dict_get(gctx, pdf_trailer(ctx, pdf), PDF_NAME(Root)), PDF_NAME(OCProperties));
        if (ocp) goto finished;
        pdf_obj *root = pdf_dict_get(ctx, pdf_trailer(ctx, pdf), PDF_NAME(Root));
        ocp = pdf_dict_put_dict(ctx, root, PDF_NAME(OCProperties), 2);
        pdf_dict_put_array(ctx, ocp, PDF_NAME(OCGs), 0);
        D = pdf_dict_put_dict(ctx, ocp, PDF_NAME(D), 5);
        pdf_dict_put_array(ctx, D, PDF_NAME(ON), 0);
        pdf_dict_put_array(ctx, D, PDF_NAME(OFF), 0);
        pdf_dict_put_array(ctx, D, PDF_NAME(Order), 0);
        pdf_dict_put_array(ctx, D, PDF_NAME(RBGroups), 0);
    finished:;
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return ocp;
}


//------------------------------------------------------------------------
// Add OC configuration to the PDF catalog
//------------------------------------------------------------------------
void
JM_add_layer_config(fz_context *ctx, pdf_document *pdf, char *name, char *creator, PyObject *ON)
{
    pdf_obj *D, *ocp, *configs;
    fz_try(ctx) {
        ocp = JM_ensure_ocproperties(ctx, pdf);
        configs = pdf_dict_get(ctx, ocp, PDF_NAME(Configs));
        if (!pdf_is_array(ctx, configs)) {
            configs = pdf_dict_put_array(ctx,ocp, PDF_NAME(Configs), 1);
        }
        D = pdf_new_dict(ctx, pdf, 5);
        pdf_dict_put_text_string(ctx, D, PDF_NAME(Name), name);
        if (creator) {
            pdf_dict_put_text_string(ctx, D, PDF_NAME(Creator), creator);
        }
        pdf_dict_put(ctx, D, PDF_NAME(BaseState), PDF_NAME(OFF));
        pdf_obj *onarray = pdf_dict_put_array(ctx, D, PDF_NAME(ON), 5);
        if (!EXISTS(ON) || !PySequence_Check(ON) || !PySequence_Size(ON)) {
            ;
        } else {
            pdf_obj *ocgs = pdf_dict_get(ctx, ocp, PDF_NAME(OCGs));
            int i, n = PySequence_Size(ON);
            for (i = 0; i < n; i++) {
                int xref = 0;
                if (JM_INT_ITEM(ON, (Py_ssize_t) i, &xref) == 1) continue;
                pdf_obj *ind = pdf_new_indirect(ctx, pdf, xref, 0);
                if (pdf_array_contains(ctx, ocgs, ind)) {
                    pdf_array_push_drop(ctx, onarray, ind);
                } else {
                    pdf_drop_obj(ctx, ind);
                }
            }
        }
        pdf_array_push_drop(ctx, configs, D);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
}


//------------------------------------------------------------------------
// Get OCG arrays from OC configuration
// Returns dict {"basestate":name, "on":list, "off":list, "rbg":list}
//------------------------------------------------------------------------
static PyObject *
JM_get_ocg_arrays_imp(fz_context *ctx, pdf_obj *arr)
{
    int i, n;
    PyObject *list = PyList_New(0), *item = NULL;
    pdf_obj *obj = NULL;
    if (pdf_is_array(ctx, arr)) {
        n = pdf_array_len(ctx, arr);
        for (i = 0; i < n; i++) {
            obj = pdf_array_get(ctx, arr, i);
            item = Py_BuildValue("i", pdf_to_num(ctx, obj));
            if (!PySequence_Contains(list, item)) {
                LIST_APPEND_DROP(list, item);
            } else {
                Py_DECREF(item);
            }
        }
    }
    return list;
}

PyObject *
JM_get_ocg_arrays(fz_context *ctx, pdf_obj *conf)
{
    PyObject *rc = PyDict_New(), *list = NULL, *list1 = NULL;
    int i, n;
    pdf_obj *arr = NULL, *obj = NULL;
    fz_try(ctx) {
        arr = pdf_dict_get(ctx, conf, PDF_NAME(ON));
        list = JM_get_ocg_arrays_imp(ctx, arr);
        if (PySequence_Size(list)) {
            PyDict_SetItemString(rc, "on", list);
        }
        Py_DECREF(list);
        arr = pdf_dict_get(ctx, conf, PDF_NAME(OFF));
        list = JM_get_ocg_arrays_imp(ctx, arr);
        if (PySequence_Size(list)) {
            PyDict_SetItemString(rc, "off", list);
        }
        Py_DECREF(list);
        list = PyList_New(0);
        arr = pdf_dict_get(ctx, conf, PDF_NAME(RBGroups));
        if (pdf_is_array(ctx, arr)) {
            n = pdf_array_len(ctx, arr);
            for (i = 0; i < n; i++) {
                obj = pdf_array_get(ctx, arr, i);
                list1 = JM_get_ocg_arrays_imp(ctx, obj);
                LIST_APPEND_DROP(list, list1);
            }
        }
        if (PySequence_Size(list)) {
            PyDict_SetItemString(rc, "rbgroups", list);
        }
        Py_DECREF(list);
        obj = pdf_dict_get(ctx, conf, PDF_NAME(BaseState));

        if (obj) {
            PyObject *state = NULL;
            state = Py_BuildValue("s", pdf_to_name(ctx, obj));
            PyDict_SetItemString(rc, "basestate", state);
            Py_DECREF(state);
        }
    }
    fz_always(ctx) {
    }
    fz_catch(ctx) {
        Py_CLEAR(rc);
        PyErr_Clear();
        fz_rethrow(ctx);
    }
    return rc;
}


//------------------------------------------------------------------------
// Set OCG arrays from dict of Python lists
// Works with dict like {"basestate":name, "on":list, "off":list, "rbg":list}
//------------------------------------------------------------------------
static void
JM_set_ocg_arrays_imp(fz_context *ctx, pdf_obj *arr, PyObject *list)
{
    int i, n = PySequence_Size(list);
    pdf_obj *obj = NULL;
    pdf_document *pdf = pdf_get_bound_document(ctx, arr);
    for (i = 0; i < n; i++) {
        int xref = 0;
        if (JM_INT_ITEM(list, i, &xref) == 1) continue;
        obj = pdf_new_indirect(ctx, pdf, xref, 0);
        pdf_array_push_drop(ctx, arr, obj);
    }
    return;
}

static void
JM_set_ocg_arrays(fz_context *ctx, pdf_obj *conf, const char *basestate,
                  PyObject *on, PyObject *off, PyObject *rbgroups)
{
    int i, n;
    pdf_obj *arr = NULL, *obj = NULL, *indobj = NULL;
    fz_try(ctx) {
        if (basestate) {
            pdf_dict_put_name(ctx, conf, PDF_NAME(BaseState), basestate);
        }

        if (on != Py_None) {
            pdf_dict_del(ctx, conf, PDF_NAME(ON));
            if (PySequence_Size(on)) {
                arr = pdf_dict_put_array(ctx, conf, PDF_NAME(ON), 1);
                JM_set_ocg_arrays_imp(ctx, arr, on);
            }
        }

        if (off != Py_None) {
            pdf_dict_del(ctx, conf, PDF_NAME(OFF));
            if (PySequence_Size(off)) {
                arr = pdf_dict_put_array(ctx, conf, PDF_NAME(OFF), 1);
                JM_set_ocg_arrays_imp(ctx, arr, off);
            }
        }

        if (rbgroups != Py_None) {
            pdf_dict_del(ctx, conf, PDF_NAME(RBGroups));
            if (PySequence_Size(rbgroups)) {
                arr = pdf_dict_put_array(ctx, conf, PDF_NAME(RBGroups), 1);
                n = PySequence_Size(rbgroups);
                for (i = 0; i < n; i++) {
                    PyObject *item0 = PySequence_ITEM(rbgroups, i);
                    obj = pdf_array_push_array(ctx, arr, 1);
                    JM_set_ocg_arrays_imp(ctx, obj, item0);
                    Py_DECREF(item0);
                }
            }
        }
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return;
}


//------------------------------------------------------------------------
// Return the items of Resources/Properties (used for Marked Content)
// Argument may be e.g. a page object or a Form XObject
//------------------------------------------------------------------------
PyObject *
JM_get_resource_properties(fz_context *ctx, pdf_obj *ref)
{
    PyObject *rc = NULL;
    fz_try(ctx) {
        pdf_obj *properties = pdf_dict_getl(ctx, ref,
                         PDF_NAME(Resources),
                         PDF_NAME(Properties), NULL);
        if (!properties) {
            rc = PyTuple_New(0);
        } else {
            int i, n = pdf_dict_len(ctx, properties);
            if (n < 1) {
                rc = PyTuple_New(0);
                goto finished;
            }
            rc = PyTuple_New(n);
            for (i = 0; i < n; i++) {
                pdf_obj *key = pdf_dict_get_key(ctx, properties, i);
                pdf_obj *val = pdf_dict_get_val(ctx, properties, i);
                const char *c = pdf_to_name(ctx, key);
                int xref = pdf_to_num(ctx, val);
                PyTuple_SET_ITEM(rc, i, Py_BuildValue("si", c, xref));
            }
        }
        finished:;
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return rc;
}


//------------------------------------------------------------------------
// Insert an item into Resources/Properties (used for Marked Content)
// Arguments:
// (1) e.g. page object, Form XObject
// (2) marked content name
// (3) xref of the referenced object (insert as indirect reference)
//------------------------------------------------------------------------
void
JM_set_resource_property(fz_context *ctx, pdf_obj *ref, const char *name, int xref)
{
    pdf_obj *ind = NULL;
    pdf_obj *properties = NULL;
    pdf_document *pdf = pdf_get_bound_document(ctx, ref);
    fz_try(ctx) {
        ind = pdf_new_indirect(ctx, pdf, xref, 0);
        if (!ind) THROWMSG(ctx, "bad xref");
        pdf_obj *resources = pdf_dict_get(ctx, ref, PDF_NAME(Resources));
        if (!resources) {
            resources = pdf_dict_put_dict(ctx, ref, PDF_NAME(Resources), 1);
        }
        properties = pdf_dict_get(ctx, resources, PDF_NAME(Properties));
        if (!properties) {
            properties = pdf_dict_put_dict(ctx, resources, PDF_NAME(Properties), 1);
        }
        pdf_dict_put(ctx, properties, pdf_new_name(ctx, name), ind);
    }
    fz_always(ctx) {
        pdf_drop_obj(ctx, ind);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return;
}


//------------------------------------------------------------------------
// Add OC object reference to a dictionary
//------------------------------------------------------------------------
void
JM_add_oc_object(fz_context *ctx, pdf_document *pdf, pdf_obj *ref, int xref)
{
    pdf_obj *indobj = NULL;
    fz_try(ctx) {
        indobj = pdf_new_indirect(ctx, pdf, xref, 0);
        if (!pdf_is_dict(ctx, indobj)) THROWMSG(ctx, "bad 'oc' reference");
        pdf_obj *type = pdf_dict_get(ctx, indobj, PDF_NAME(Type));
        if (pdf_objcmp(ctx, type, PDF_NAME(OCG)) == 0 ||
            pdf_objcmp(ctx, type, PDF_NAME(OCMD)) == 0) {
            pdf_dict_put(ctx, ref, PDF_NAME(OC), indobj);
        } else {
            THROWMSG(ctx, "bad 'oc' type");
        }
    }
    fz_always(ctx) {
        pdf_drop_obj(ctx, indobj);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
}


//-------------------------------------------------------------------------
// Store info of a font in Python list
//-------------------------------------------------------------------------
int JM_gather_fonts(fz_context *ctx, pdf_document *pdf, pdf_obj *dict,
                    PyObject *fontlist, int stream_xref)
{
    int i, n, rc = 1;
    n = pdf_dict_len(ctx, dict);
    for (i = 0; i < n; i++) {
        pdf_obj *fontdict = NULL;
        pdf_obj *subtype = NULL;
        pdf_obj *basefont = NULL;
        pdf_obj *name = NULL;
        pdf_obj *refname = NULL;
        pdf_obj *encoding = NULL;

        refname = pdf_dict_get_key(ctx, dict, i);
        fontdict = pdf_dict_get_val(ctx, dict, i);
        if (!pdf_is_dict(ctx, fontdict)) {
            fz_warn(ctx, "'%s' is no font dict (%d 0 R)",
                    pdf_to_name(ctx, refname), pdf_to_num(ctx, fontdict));
            continue;
        }

        subtype = pdf_dict_get(ctx, fontdict, PDF_NAME(Subtype));
        basefont = pdf_dict_get(ctx, fontdict, PDF_NAME(BaseFont));
        if (!basefont || pdf_is_null(ctx, basefont))
            name = pdf_dict_get(ctx, fontdict, PDF_NAME(Name));
        else
            name = basefont;
        encoding = pdf_dict_get(ctx, fontdict, PDF_NAME(Encoding));
        if (pdf_is_dict(ctx, encoding))
            encoding = pdf_dict_get(ctx, encoding, PDF_NAME(BaseEncoding));
        int xref = pdf_to_num(ctx, fontdict);
        char *ext = "n/a";
        if (xref) ext = JM_get_fontextension(ctx, pdf, xref);
        PyObject *entry = PyTuple_New(7);
        PyTuple_SET_ITEM(entry, 0, Py_BuildValue("i", xref));
        PyTuple_SET_ITEM(entry, 1, Py_BuildValue("s", ext));
        PyTuple_SET_ITEM(entry, 2, Py_BuildValue("s", pdf_to_name(ctx, subtype)));
        PyTuple_SET_ITEM(entry, 3, JM_EscapeStrFromStr(pdf_to_name(ctx, name)));
        PyTuple_SET_ITEM(entry, 4, Py_BuildValue("s", pdf_to_name(ctx, refname)));
        PyTuple_SET_ITEM(entry, 5, Py_BuildValue("s", pdf_to_name(ctx, encoding)));
        PyTuple_SET_ITEM(entry, 6, Py_BuildValue("i", stream_xref));
        LIST_APPEND_DROP(fontlist, entry);
    }
    return rc;
}

//-------------------------------------------------------------------------
// Store info of an image in Python list
//-------------------------------------------------------------------------
int JM_gather_images(fz_context *ctx, pdf_document *doc, pdf_obj *dict,
                     PyObject *imagelist, int stream_xref)
{
    int i, n, rc = 1;
    n = pdf_dict_len(ctx, dict);
    for (i = 0; i < n; i++) {
        pdf_obj *imagedict, *smask;
        pdf_obj *refname = NULL;
        pdf_obj *type;
        pdf_obj *width;
        pdf_obj *height;
        pdf_obj *bpc = NULL;
        pdf_obj *filter = NULL;
        pdf_obj *cs = NULL;
        pdf_obj *altcs;

        refname = pdf_dict_get_key(ctx, dict, i);
        imagedict = pdf_dict_get_val(ctx, dict, i);
        if (!pdf_is_dict(ctx, imagedict)) {
            fz_warn(ctx, "'%s' is no image dict (%d 0 R)",
                    pdf_to_name(ctx, refname), pdf_to_num(ctx, imagedict));
            continue;
        }

        type = pdf_dict_get(ctx, imagedict, PDF_NAME(Subtype));
        if (!pdf_name_eq(ctx, type, PDF_NAME(Image)))
            continue;

        int xref = pdf_to_num(ctx, imagedict);
        int gen = 0;
        smask = pdf_dict_geta(ctx, imagedict, PDF_NAME(SMask), PDF_NAME(Mask));
        if (smask)
            gen = pdf_to_num(ctx, smask);

        filter = pdf_dict_geta(ctx, imagedict, PDF_NAME(Filter), PDF_NAME(F));
        if (pdf_is_array(ctx, filter)) {
            filter = pdf_array_get(ctx, filter, 0);
        }

        altcs = NULL;
        cs = pdf_dict_geta(ctx, imagedict, PDF_NAME(ColorSpace), PDF_NAME(CS));
        if (pdf_is_array(ctx, cs)) {
            pdf_obj *cses = cs;
            cs = pdf_array_get(ctx, cses, 0);
            if (pdf_name_eq(ctx, cs, PDF_NAME(DeviceN)) ||
                pdf_name_eq(ctx, cs, PDF_NAME(Separation))) {
                altcs = pdf_array_get(ctx, cses, 2);
                if (pdf_is_array(ctx, altcs))
                    altcs = pdf_array_get(ctx, altcs, 0);
            }
        }

        width = pdf_dict_geta(ctx, imagedict, PDF_NAME(Width), PDF_NAME(W));
        height = pdf_dict_geta(ctx, imagedict, PDF_NAME(Height), PDF_NAME(H));
        bpc = pdf_dict_geta(ctx, imagedict, PDF_NAME(BitsPerComponent), PDF_NAME(BPC));

        PyObject *entry = PyTuple_New(10);
        PyTuple_SET_ITEM(entry, 0, Py_BuildValue("i", xref));
        PyTuple_SET_ITEM(entry, 1, Py_BuildValue("i", gen));
        PyTuple_SET_ITEM(entry, 2, Py_BuildValue("i", pdf_to_int(ctx, width)));
        PyTuple_SET_ITEM(entry, 3, Py_BuildValue("i", pdf_to_int(ctx, height)));
        PyTuple_SET_ITEM(entry, 4, Py_BuildValue("i", pdf_to_int(ctx, bpc)));
        PyTuple_SET_ITEM(entry, 5, JM_EscapeStrFromStr(pdf_to_name(ctx, cs)));
        PyTuple_SET_ITEM(entry, 6, JM_EscapeStrFromStr(pdf_to_name(ctx, altcs)));
        PyTuple_SET_ITEM(entry, 7, JM_EscapeStrFromStr(pdf_to_name(ctx, refname)));
        PyTuple_SET_ITEM(entry, 8, JM_EscapeStrFromStr(pdf_to_name(ctx, filter)));
        PyTuple_SET_ITEM(entry, 9, Py_BuildValue("i", stream_xref));
        LIST_APPEND_DROP(imagelist, entry);
    }
    return rc;
}

//-------------------------------------------------------------------------
// Store info of a /Form xobject in Python list
//-------------------------------------------------------------------------
int JM_gather_forms(fz_context *ctx, pdf_document *doc, pdf_obj *dict,
                     PyObject *imagelist, int stream_xref)
{
    int i, rc = 1, n = pdf_dict_len(ctx, dict);
    fz_rect bbox;
    fz_matrix mat;
    pdf_obj *o = NULL, *m = NULL;
    for (i = 0; i < n; i++) {
        pdf_obj *imagedict;
        pdf_obj *refname = NULL;
        pdf_obj *type;

        refname = pdf_dict_get_key(ctx, dict, i);
        imagedict = pdf_dict_get_val(ctx, dict, i);
        if (!pdf_is_dict(ctx, imagedict)) {
            fz_warn(ctx, "'%s' is no form dict (%d 0 R)",
                    pdf_to_name(ctx, refname), pdf_to_num(ctx, imagedict));
            continue;
        }

        type = pdf_dict_get(ctx, imagedict, PDF_NAME(Subtype));
        if (!pdf_name_eq(ctx, type, PDF_NAME(Form)))
            continue;

        o = pdf_dict_get(ctx, imagedict, PDF_NAME(BBox));
        m = pdf_dict_get(ctx, imagedict, PDF_NAME(Matrix));
        if (m) {
            mat = pdf_to_matrix(ctx, m);
        } else {
            mat = fz_identity;
        }
        if (o) {
            bbox = fz_transform_rect(pdf_to_rect(ctx, o), mat);
        } else {
            bbox = fz_infinite_rect;
        }
        int xref = pdf_to_num(ctx, imagedict);

        PyObject *entry = PyTuple_New(4);
        PyTuple_SET_ITEM(entry, 0, Py_BuildValue("i", xref));
        PyTuple_SET_ITEM(entry, 1, Py_BuildValue("s", pdf_to_name(ctx, refname)));
        PyTuple_SET_ITEM(entry, 2, Py_BuildValue("i", stream_xref));
        PyTuple_SET_ITEM(entry, 3, JM_py_from_rect(bbox));
        LIST_APPEND_DROP(imagelist, entry);
    }
    return rc;
}

//-------------------------------------------------------------------------
// Step through /Resources, looking up image, xobject or font information
//-------------------------------------------------------------------------
void JM_scan_resources(fz_context *ctx, pdf_document *pdf, pdf_obj *rsrc,
                 PyObject *liste, int what, int stream_xref,
                 PyObject *tracer)
{
    pdf_obj *font, *xobj, *subrsrc;
    int i, n, sxref;
    if (pdf_mark_obj(ctx, rsrc)) {
        fz_warn(ctx, "Circular dependencies! Consider page cleaning.");
        return;  // Circular dependencies!
    }

    fz_try(ctx) {

        xobj = pdf_dict_get(ctx, rsrc, PDF_NAME(XObject));

        if (what == 1) {  // lookup fonts
            font = pdf_dict_get(ctx, rsrc, PDF_NAME(Font));
            JM_gather_fonts(ctx, pdf, font, liste, stream_xref);
        } else if (what == 2) {  // look up images
            JM_gather_images(ctx, pdf, xobj, liste, stream_xref);
        } else if (what == 3) {  // look up form xobjects
            JM_gather_forms(ctx, pdf, xobj, liste, stream_xref);
        } else {  // should never happen
            goto finished;
        }

        // check if we need to recurse into Form XObjects
        n = pdf_dict_len(ctx, xobj);
        for (i = 0; i < n; i++) {
            pdf_obj *obj = pdf_dict_get_val(ctx, xobj, i);
            if (pdf_is_stream(ctx, obj)) {
                sxref = pdf_to_num(ctx, obj);
            } else {
                sxref = 0;
            }
            subrsrc = pdf_dict_get(ctx, obj, PDF_NAME(Resources));
            if (subrsrc) {
                PyObject *sxref_t = Py_BuildValue("i", sxref);
                if (PySequence_Contains(tracer, sxref_t) == 0) {
                    LIST_APPEND_DROP(tracer, sxref_t);
                    JM_scan_resources(ctx, pdf, subrsrc, liste, what, sxref, tracer);
                } else {
                    Py_DECREF(sxref_t);
                    PyErr_Clear();
                    fz_warn(ctx, "Circular dependencies! Consider page cleaning.");
                    goto finished;
                }
            }
        }
        finished:;
    }
    fz_always(ctx) {
        pdf_unmark_obj(ctx, rsrc);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
}


//-----------------------------------------------------------------------------
// Convert any MuPDF document to a PDF
// Returns bytes object containing the PDF, created via 'write' function.
//-----------------------------------------------------------------------------
PyObject *JM_convert_to_pdf(fz_context *ctx, fz_document *doc, int fp, int tp, int rotate)
{
    pdf_document *pdfout = pdf_create_document(ctx);  // new PDF document
    int i, incr = 1, s = fp, e = tp;
    if (fp > tp) {
        incr = -1;           // count backwards
        s = tp;              // adjust ...
        e = fp;              // ... range
    }
    fz_rect mediabox;
    int rot = JM_norm_rotation(rotate);
    fz_device *dev = NULL;
    fz_buffer *contents = NULL;
    pdf_obj *resources = NULL;
    fz_page *page;
    fz_var(dev);
    fz_var(contents);
    fz_var(resources);
    fz_var(page);
    for (i = fp; INRANGE(i, s, e); i += incr) {  // interpret & write document pages as PDF pages
        fz_try(ctx) {
            page = fz_load_page(ctx, doc, i);
            mediabox = fz_bound_page(ctx, page);
            dev = pdf_page_write(ctx, pdfout, mediabox, &resources, &contents);
            fz_run_page(ctx, page, dev, fz_identity, NULL);
            fz_close_device(ctx, dev);
            fz_drop_device(ctx, dev);
            dev = NULL;
            pdf_obj *page_obj = pdf_add_page(ctx, pdfout, mediabox, rot, resources, contents);
            pdf_insert_page(ctx, pdfout, -1, page_obj);
            pdf_drop_obj(ctx, page_obj);
        }
        fz_always(ctx) {
            pdf_drop_obj(ctx, resources);
            fz_drop_buffer(ctx, contents);
            fz_drop_device(ctx, dev);
            fz_drop_page(ctx, page);
        }
        fz_catch(ctx) {
            fz_rethrow(ctx);
        }
    }
    // PDF created - now write it to Python bytearray
    PyObject *r = NULL;
    fz_output *out = NULL;
    fz_buffer *res = NULL;
    // prepare write options structure
    pdf_write_options opts = { 0 };
    opts.do_garbage         = 4;
    opts.do_compress        = 1;
    opts.do_compress_images = 1;
    opts.do_compress_fonts  = 1;
    opts.do_sanitize        = 1;
    opts.do_incremental     = 0;
    opts.do_ascii           = 0;
    opts.do_decompress      = 0;
    opts.do_linear          = 0;
    opts.do_clean           = 1;
    opts.do_pretty          = 0;

    fz_try(ctx) {
        res = fz_new_buffer(ctx, 8192);
        out = fz_new_output_with_buffer(ctx, res);
        pdf_write_document(ctx, pdfout, out, &opts);
        unsigned char *c = NULL;
        size_t len = fz_buffer_storage(gctx, res, &c);
        r = PyBytes_FromStringAndSize((const char *) c, (Py_ssize_t) len);
    }
    fz_always(ctx) {
        pdf_drop_document(ctx, pdfout);
        fz_drop_output(ctx, out);
        fz_drop_buffer(ctx, res);
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return r;
}


//-------------------------------------
// fz_output for Python file objects
//-------------------------------------
static void
JM_bytesio_write(fz_context *ctx, void *opaque, const void *data, size_t len)
{  // bio.write(bytes object)
    PyObject *bio = opaque, *b, *name, *rc;
    fz_try(ctx){
        b = PyBytes_FromStringAndSize((const char *) data, (Py_ssize_t) len);
        name = PyUnicode_FromString("write");
        rc = PyObject_CallMethodObjArgs(bio, name, b, NULL);
        if (!rc) {
            THROWMSG(ctx, "could not write to Py file obj");
        }
    }
    fz_always(ctx) {
        Py_XDECREF(b);
        Py_XDECREF(name);
        Py_XDECREF(rc);
        PyErr_Clear();
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
}

static void
JM_bytesio_truncate(fz_context *ctx, void *opaque)
{  // bio.truncate(bio.tell()) !!!
    PyObject *bio = opaque, *trunc = NULL, *tell = NULL, *rctell= NULL, *rc = NULL;
    fz_try(ctx) {
        trunc = PyUnicode_FromString("truncate");
        tell = PyUnicode_FromString("tell");
        rctell = PyObject_CallMethodObjArgs(bio, tell, NULL);
        rc = PyObject_CallMethodObjArgs(bio, trunc, rctell, NULL);
        if (!rc) {
            THROWMSG(ctx, "could not truncate Py file obj");
        }
    }
    fz_always(ctx) {
        Py_XDECREF(tell);
        Py_XDECREF(trunc);
        Py_XDECREF(rc);
        Py_XDECREF(rctell);
        PyErr_Clear();
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
}

static int64_t
JM_bytesio_tell(fz_context *ctx, void *opaque)
{  // returns bio.tell() -> int
    PyObject *bio = opaque, *rc = NULL, *name = NULL;
    int64_t pos = 0;
    fz_try(ctx) {
        name = PyUnicode_FromString("tell");
        rc = PyObject_CallMethodObjArgs(bio, name, NULL);
        if (!rc) {
            THROWMSG(ctx, "could not tell Py file obj");
        }
        pos = (int64_t) PyLong_AsUnsignedLongLong(rc);
    }
    fz_always(ctx) {
        Py_XDECREF(name);
        Py_XDECREF(rc);
        PyErr_Clear();
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
    return pos;
}


static void
JM_bytesio_seek(fz_context *ctx, void *opaque, int64_t off, int whence)
{  // bio.seek(off, whence=0)
    PyObject *bio = opaque, *rc = NULL, *name = NULL, *pos = NULL;
    fz_try(ctx) {
        name = PyUnicode_FromString("seek");
        pos = PyLong_FromUnsignedLongLong((unsigned long long) off);
        rc = PyObject_CallMethodObjArgs(bio, name, pos, whence, NULL);
        if (!rc) {
            THROWMSG(ctx, "could not seek Py file obj");
        }
    }
    fz_always(ctx) {
        Py_XDECREF(rc);
        Py_XDECREF(name);
        Py_XDECREF(pos);
        PyErr_Clear();
    }
    fz_catch(ctx) {
        fz_rethrow(ctx);
    }
}

fz_output *
JM_new_output_fileptr(fz_context *ctx, PyObject *bio)
{
    fz_output *out = fz_new_output(ctx, 0, bio, JM_bytesio_write, NULL, NULL);
    out->seek = JM_bytesio_seek;
    out->tell = JM_bytesio_tell;
    out->truncate = JM_bytesio_truncate;
    return out;
}


typedef struct
{
	fz_device super;
	PyObject *out;
} jm_tracedraw_device;

static void
jm_tracedraw_matrix(fz_context *ctx, PyObject *out, fz_matrix ctm)
{
	PyObject *list = PyList_New(0);
    LIST_APPEND_DROP(list, PyUnicode_FromString("matrix"));
    LIST_APPEND_DROP(list, JM_py_from_matrix(ctm));
    LIST_APPEND_DROP(out, list);
}

static void
jm_tracedraw_color(fz_context *ctx, PyObject *out, fz_colorspace *colorspace, const float *color, float alpha)
{
	int i, n;
	if (colorspace)
	{
		n = fz_colorspace_n(ctx, colorspace);
		LIST_APPEND_DROP(out, Py_BuildValue("ss", "colorspace", fz_colorspace_name(ctx, colorspace)));
		PyObject *xlist=PyList_New(0);
		LIST_APPEND_DROP(xlist, Py_BuildValue("s", "color"));
		for (i = 0; i < n; i++)
			LIST_APPEND_DROP(xlist, Py_BuildValue("f", color[i]));
		LIST_APPEND_DROP(out, xlist);
	}
	if (alpha < 1)
		LIST_APPEND_DROP(out, Py_BuildValue("sf", "alpha", alpha));
}

static void
trace_moveto(fz_context *ctx, void *dev_, float x, float y)
{
	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
	PyObject *out = dev->out;
    PyObject *list = PyList_New(0);
    LIST_APPEND_DROP(list, PyUnicode_FromString("m"));
    LIST_APPEND_DROP(list, JM_py_from_point(fz_make_point(x, y)));
    LIST_APPEND_DROP(out, list);
}

static void
trace_lineto(fz_context *ctx, void *dev_, float x, float y)
{
	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
	PyObject *out = dev->out;
    PyObject *list = PyList_New(0);
    LIST_APPEND_DROP(list, PyUnicode_FromString("l"));
    LIST_APPEND_DROP(list, JM_py_from_point(fz_make_point(x, y)));
    LIST_APPEND_DROP(out, list);
}

static void
trace_curveto(fz_context *ctx, void *dev_, float x1, float y1, float x2, float y2, float x3, float y3)
{
	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
	PyObject *out = dev->out;
    PyObject *list = PyList_New(0);
    LIST_APPEND_DROP(list, PyUnicode_FromString("c"));
    LIST_APPEND_DROP(list, JM_py_from_point(fz_make_point(x1, y1)));
    LIST_APPEND_DROP(list, JM_py_from_point(fz_make_point(x2, y2)));
    LIST_APPEND_DROP(list, JM_py_from_point(fz_make_point(x3, y3)));
    LIST_APPEND_DROP(out, list);
}

static void
trace_close(fz_context *ctx, void *dev_)
{
	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
	PyObject *out = dev->out;
    LIST_APPEND_DROP(out, Py_BuildValue("s", "closePath"));
}

static const fz_path_walker trace_path_walker =
	{
		trace_moveto,
		trace_lineto,
		trace_curveto,
		trace_close};

static void
jm_tracedraw_path(fz_context *ctx, jm_tracedraw_device *dev, const fz_path *path)
{
	fz_walk_path(ctx, path, &trace_path_walker, dev);
}

static void
jm_tracedraw_fill_path(fz_context *ctx, fz_device *dev_, const fz_path *path,
						int even_odd, fz_matrix ctm, fz_colorspace *colorspace,
						const float *color, float alpha, fz_color_params color_params)
{
	jm_tracedraw_device *dev = (jm_tracedraw_device *) dev_;
	PyObject *out = dev->out;
	PyObject *list = PyList_New(0);
	LIST_APPEND_DROP(list, PyUnicode_FromString("fill"));
	if (even_odd)
		LIST_APPEND_DROP(list, PyUnicode_FromString("even-odd"));
	else
		LIST_APPEND_DROP(list, PyUnicode_FromString("non-zero"));
	jm_tracedraw_matrix(ctx, list, ctm);
	jm_tracedraw_color(ctx, list, colorspace, color, alpha);
	LIST_APPEND_DROP(out, list);
	jm_tracedraw_path(ctx, dev, path);
	LIST_APPEND_DROP(out, PyUnicode_FromString("efill"));
}

static void
jm_tracedraw_stroke_path(fz_context *ctx, fz_device *dev_, const fz_path *path,
						 const fz_stroke_state *stroke, fz_matrix ctm,
						 fz_colorspace *colorspace, const float *color, float alpha,
						 fz_color_params color_params)
{
	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
	PyObject *out = dev->out;
	int i;
    PyObject *list = PyList_New(0);
    LIST_APPEND_DROP(list, PyUnicode_FromString("stroke"));
	jm_tracedraw_matrix(ctx, list, ctm);
	LIST_APPEND_DROP(list, Py_BuildValue("sf", "w", stroke->linewidth));
	LIST_APPEND_DROP(list, Py_BuildValue("sf", "miter", stroke->miterlimit));
	LIST_APPEND_DROP(list, Py_BuildValue("siii", "lineCap",
					 stroke->start_cap, stroke->dash_cap, stroke->end_cap));
	LIST_APPEND_DROP(list, Py_BuildValue("si", "lineJoin", stroke->linejoin));

	if (stroke->dash_len)
	{
		LIST_APPEND_DROP(list, Py_BuildValue("sf", "dashPhase", stroke->dash_phase));
		PyObject *xlist=PyList_New(0);
		LIST_APPEND_DROP(xlist, Py_BuildValue("s", "dashes"));
		for (i = 0; i < stroke->dash_len; i++)
			LIST_APPEND_DROP(xlist, Py_BuildValue("f", stroke->dash_list[i]));
		LIST_APPEND_DROP(list, xlist);
	}
	jm_tracedraw_color(ctx, list, colorspace, color, alpha);
	LIST_APPEND_DROP(out, list);
	jm_tracedraw_path(ctx, dev, path);
	LIST_APPEND_DROP(out, Py_BuildValue("s", "estroke"));
}

static void
jm_tracedraw_clip_path(fz_context *ctx, fz_device *dev_, const fz_path *path, int even_odd, fz_matrix ctm, fz_rect scissor)
{
	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
	PyObject *out = dev->out;
	PyObject *list = PyList_New(0);
	LIST_APPEND_DROP(list, Py_BuildValue("s", "clip"));

	if (even_odd)
		LIST_APPEND_DROP(list, Py_BuildValue("s", "even-odd"));
	else
		LIST_APPEND_DROP(list, Py_BuildValue("s", "non-zero"));
	jm_tracedraw_matrix(ctx, list, ctm);
	LIST_APPEND_DROP(out, list);
	jm_tracedraw_path(ctx, dev, path);
	LIST_APPEND_DROP(out, Py_BuildValue("s", "eclip"));
}

static void
jm_tracedraw_clip_stroke_path(fz_context *ctx, fz_device *dev_, const fz_path *path, const fz_stroke_state *stroke, fz_matrix ctm, fz_rect scissor)
{
	jm_tracedraw_device *dev = (jm_tracedraw_device *)dev_;
	PyObject *out = dev->out;
	PyObject *list = PyList_New(0);
	LIST_APPEND_DROP(list, Py_BuildValue("s", "clip-stroke"));
	jm_tracedraw_matrix(ctx, list, ctm);
	LIST_APPEND_DROP(out, list);
	jm_tracedraw_path(ctx, dev, path);
	LIST_APPEND_DROP(out, Py_BuildValue("s", "eclip-stroke"));
}

fz_device *JM_new_tracedraw_device(fz_context *ctx, PyObject *out)
{
	jm_tracedraw_device *dev = fz_new_derived_device(ctx, jm_tracedraw_device);

	dev->super.fill_path = jm_tracedraw_fill_path;
	dev->super.stroke_path = jm_tracedraw_stroke_path;
	dev->super.clip_path = NULL; //jm_tracedraw_clip_path;
	dev->super.clip_stroke_path = jm_tracedraw_clip_stroke_path;

	dev->super.fill_text = NULL;
	dev->super.stroke_text = NULL;
	dev->super.clip_text = NULL;
	dev->super.clip_stroke_text = NULL;
	dev->super.ignore_text = NULL;

	dev->super.fill_shade = NULL;
	dev->super.fill_image = NULL;
	dev->super.fill_image_mask = NULL;
	dev->super.clip_image_mask = NULL;

	dev->super.pop_clip = NULL;

	dev->super.begin_mask = NULL;
	dev->super.end_mask = NULL;
	dev->super.begin_group = NULL;
	dev->super.end_group = NULL;

	dev->super.begin_tile = NULL;
	dev->super.end_tile = NULL;

	dev->super.begin_layer = NULL;
	dev->super.end_layer = NULL;

	dev->super.render_flags = NULL;
	dev->super.set_default_colorspaces = NULL;

	dev->out = out;

	return (fz_device *)dev;
}


SWIGINTERN void delete_Document(struct Document *self){
            DEBUGMSG1("Document w/o close");
            fz_document *this_doc = (fz_document *) self;
            fz_drop_document(gctx, this_doc);
            DEBUGMSG2;
        }

SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
  if (PyBytes_Check(obj))
#else
  if (PyUnicode_Check(obj))
#endif
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
    int ret = SWIG_OK;
#if PY_VERSION_HEX>=0x03000000
#if !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    if (!obj)
      return SWIG_TypeError;
    if (alloc)
      *alloc = SWIG_NEWOBJ;
#endif
    if (PyBytes_AsStringAndSize(obj, &cstr, &len) == -1)
      return SWIG_TypeError;
#else
    if (PyString_AsStringAndSize(obj, &cstr, &len) == -1)
      return SWIG_TypeError;
#endif
    if (cptr) {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
	  *alloc = SWIG_NEWOBJ;
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
	*cptr = PyBytes_AsString(obj);
#else
	assert(0); /* Should never reach here with Unicode strings in Python 3 */
#endif
#else
	*cptr = SWIG_Python_str_AsChar(obj);
        if (!*cptr)
          ret = SWIG_TypeError;
#endif
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000 && !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    Py_XDECREF(obj);
#endif
    return ret;
  } else {
#if defined(SWIG_PYTHON_2_UNICODE)
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
#error "Cannot use both SWIG_PYTHON_2_UNICODE and SWIG_PYTHON_STRICT_BYTE_CHAR at once"
#endif
#if PY_VERSION_HEX<0x03000000
    if (PyUnicode_Check(obj)) {
      char *cstr; Py_ssize_t len;
      if (!alloc && cptr) {
        return SWIG_RuntimeError;
      }
      obj = PyUnicode_AsUTF8String(obj);
      if (!obj)
        return SWIG_TypeError;
      if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
        if (cptr) {
          if (alloc) *alloc = SWIG_NEWOBJ;
          *cptr = (char *)memcpy(malloc((len + 1)*sizeof(char)), cstr, sizeof(char)*(len + 1));
        }
        if (psize) *psize = len + 1;

        Py_XDECREF(obj);
        return SWIG_OK;
      } else {
        Py_XDECREF(obj);
      }
    }
#endif
#endif

    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}





#include <float.h>


#include <math.h>


/* Getting isfinite working pre C99 across multiple platforms is non-trivial. Users can provide SWIG_isfinite on older platforms. */
#ifndef SWIG_isfinite
/* isfinite() is a macro for C99 */
# if defined(isfinite)
#  define SWIG_isfinite(X) (isfinite(X))
# elif defined(__cplusplus) && __cplusplus >= 201103L
/* Use a template so that this works whether isfinite() is std::isfinite() or
 * in the global namespace.  The reality seems to vary between compiler
 * versions.
 *
 * Make sure namespace std exists to avoid compiler warnings.
 *
 * extern "C++" is required as this fragment can end up inside an extern "C" { } block
 */
namespace std { }
extern "C++" template<typename T>
inline int SWIG_isfinite_func(T x) {
  using namespace std;
  return isfinite(x);
}
#  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
# elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2))
#  define SWIG_isfinite(X) (__builtin_isfinite(X))
# elif defined(__clang__) && defined(__has_builtin)
#  if __has_builtin(__builtin_isfinite)
#   define SWIG_isfinite(X) (__builtin_isfinite(X))
#  endif
# elif defined(_MSC_VER)
#  define SWIG_isfinite(X) (_finite(X))
# elif defined(__sun) && defined(__SVR4)
#  include <ieeefp.h>
#  define SWIG_isfinite(X) (finite(X))
# endif
#endif


/* Accept infinite as a valid float value unless we are unable to check if a value is finite */
#ifdef SWIG_isfinite
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
#else
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
#endif


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = (double) PyInt_AsLong(obj);
    return SWIG_OK;
#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


SWIGINTERN int
SWIG_AsVal_float (PyObject * obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (SWIG_IsOK(res)) {
    if (SWIG_Float_Overflow_Check(v)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (float)(v);
    }
  }  
  return res;
}

SWIGINTERN struct Document *new_Document(char const *filename,PyObject *stream,char const *filetype,PyObject *rect,float width,float height,float fontsize){
            gctx->error.errcode = 0;       // reset any error code
            gctx->error.message[0] = 0;    // reset any error message
            fz_document *doc = NULL;
            char *c = NULL;
            size_t len = 0;
            fz_stream *data = NULL;
            float w = width, h = height;
            fz_rect r = JM_rect_from_py(rect);
            if (!fz_is_infinite_rect(r)) {
                w = r.x1 - r.x0;
                h = r.y1 - r.y0;
            }

            fz_try(gctx) {
                if (stream != Py_None) { // stream given, **MUST** be bytes!

                    c = PyBytes_AS_STRING(stream); // just a pointer, no new obj
                    len = (size_t) PyBytes_Size(stream);
                    data = fz_open_memory(gctx, (const unsigned char *) c, len);
                    char *magic = (char *)filename;
                    if (!magic) magic = (char *)filetype;
                    doc = fz_open_document_with_stream(gctx, magic, data);
                } else {
                    if (filename) {
                        if (!filetype || strlen(filetype) == 0) {
                            doc = fz_open_document(gctx, filename);
                        } else {
                            const fz_document_handler *handler;
                            handler = fz_recognize_document(gctx, filetype);
                            if (handler && handler->open)
                                doc = handler->open(gctx, filename);
                            else THROWMSG(gctx, "unrecognized file type");
                        }
                    } else {
                        pdf_document *pdf = pdf_create_document(gctx);
                        pdf->dirty = 1;
                        doc = (fz_document *) pdf;
                    }
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            if (w > 0 && h > 0) {
                fz_layout_document(gctx, doc, w, h, fontsize);
            } else if (fz_is_document_reflowable(gctx, doc)) {
                fz_layout_document(gctx, doc, 400, 600, 11);
            }
            return (struct Document *) doc;
        }
SWIGINTERN void Document_close(struct Document *self){
            DEBUGMSG1("Document after close");
            fz_document *doc = (fz_document *) self;
            while(doc->refs > 1) {
                fz_drop_document(gctx, doc);
            }
            fz_drop_document(gctx, doc);
            DEBUGMSG2;
        }
SWIGINTERN struct Page *Document_load_page(struct Document *self,PyObject *page_id){
            fz_page *page = NULL;
            fz_document *doc = (fz_document *) self;
            int pno = 0, chapter = 0;
            PyObject *val = NULL;
            fz_try(gctx) {
                if (PySequence_Check(page_id)) {
                    if (JM_INT_ITEM(page_id, 0, &chapter) == 1) {
                        THROWMSG(gctx, "bad page id");
                    }
                    if (JM_INT_ITEM(page_id, 1, &pno) == 1) {
                        THROWMSG(gctx, "bad page id");
                    }
                    page = fz_load_chapter_page(gctx, doc, chapter, pno);
                } else {
                    pno = (int) PyLong_AsLong(page_id);
                    if (PyErr_Occurred()) {
                        THROWMSG(gctx, "bad page id");
                    }
                    page = fz_load_page(gctx, doc, pno);
                }
            }
            fz_catch(gctx) {
                PyErr_Clear();
                return NULL;
            }
            PyErr_Clear();
            return (struct Page *) page;
        }
SWIGINTERN PyObject *Document__remove_links_to(struct Document *self,PyObject *numbers){
            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                remove_dest_range(gctx, pdf, numbers);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN struct Outline *Document__loadOutline(struct Document *self){
            fz_outline *ol = NULL;
            fz_document *doc = (fz_document *) self;
            fz_try(gctx) {
                ol = fz_load_outline(gctx, doc);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Outline *) ol;
        }
SWIGINTERN void Document__dropOutline(struct Document *self,struct Outline *ol){
            DEBUGMSG1("Outline");
            fz_outline *this_ol = (fz_outline *) ol;
            fz_drop_outline(gctx, this_ol);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *Document__insert_font(struct Document *self,char *fontfile,PyObject *fontbuffer){
            PyObject *value=NULL;
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *)self);

            fz_try(gctx) {
                ASSERT_PDF(pdf);
                if (!fontfile && !EXISTS(fontbuffer)) {
                    THROWMSG(gctx, "need one of fontfile, fontbuffer");
                }
                value = JM_insert_font(gctx, pdf, NULL, fontfile, fontbuffer,
                            0, 0, 0, 0, 0, -1);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return value;
        }
SWIGINTERN PyObject *Document_get_outline_xrefs(struct Document *self){
            PyObject *xrefs = PyList_New(0);
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *)self);
            if (!pdf) {
                return xrefs;
            }
            fz_try(gctx) {
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
                if (!root) goto finished;
                pdf_obj *olroot = pdf_dict_get(gctx, root, PDF_NAME(Outlines));
                if (!olroot) goto finished;
                pdf_obj *first = pdf_dict_get(gctx, olroot, PDF_NAME(First));
                if (!first) goto finished;
                xrefs = JM_outline_xrefs(gctx, first, xrefs);
                finished:;
            }
            fz_catch(gctx) {
                Py_DECREF(xrefs);
                return NULL;
            }
            return xrefs;
        }

#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (int)(v);
    }
  }  
  return res;
}

SWIGINTERN PyObject *Document_xref_get_keys(struct Document *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *)self);
            pdf_obj *obj=NULL;
            PyObject *rc = NULL;
            int i, n;
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1) && xref != -1)
                    THROWMSG(gctx, "bad xref");
                if (xref > 0) {
                    obj = pdf_load_object(gctx, pdf, xref);
                } else {
                    obj = pdf_trailer(gctx, pdf);
                }
                n = pdf_dict_len(gctx, obj);
                rc = PyTuple_New(n);
                if (!n) goto finished;
                for (i = 0; i < n; i++) {
                    const char *key = pdf_to_name(gctx, pdf_dict_get_key(gctx, obj, i));
                    PyTuple_SET_ITEM(rc, i, Py_BuildValue("s", key));
                }
                finished:;
            }
            fz_always(gctx) {
                if (xref > 0) {
                    pdf_drop_obj(gctx, obj);
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            return rc;
        }
SWIGINTERN PyObject *Document_xref_get_key(struct Document *self,int xref,char const *key){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *)self);
            pdf_obj *obj=NULL, *subobj=NULL;
            PyObject *rc = NULL;
            fz_buffer *res = NULL;
            PyObject *text = NULL;
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1) && xref != -1)
                    THROWMSG(gctx, "bad xref");
                if (xref > 0) {
                    obj = pdf_load_object(gctx, pdf, xref);
                } else {
                    obj = pdf_trailer(gctx, pdf);
                }
                if (!obj) {
                    goto not_found;
                }
                subobj = pdf_dict_getp(gctx, obj, key);
                if (!subobj) {
                    goto not_found;
                }
                char *type;
                if (pdf_is_indirect(gctx, subobj)) {
                    type = "xref";
                    text = PyUnicode_FromFormat("%i 0 R", pdf_to_num(gctx, subobj));
                } else if (pdf_is_array(gctx, subobj)) {
                    type = "array";
                } else if (pdf_is_dict(gctx, subobj)) {
                    type = "dict";
                } else if (pdf_is_int(gctx, subobj)) {
                    type = "int";
                    text = PyUnicode_FromFormat("%i", pdf_to_int(gctx, subobj));
                } else if (pdf_is_real(gctx, subobj)) {
                    type = "float";
                } else if (pdf_is_null(gctx, subobj)) {
                    type = "null";
                    text = PyUnicode_FromString("null");
                } else if (pdf_is_bool(gctx, subobj)) {
                    type = "bool";
                    if (pdf_to_bool(gctx, subobj)) {
                        text = PyUnicode_FromString("true");
                    } else {
                        text = PyUnicode_FromString("false");
                    }
                } else if (pdf_is_name(gctx, subobj)) {
                    type = "name";
                    text = PyUnicode_FromFormat("/%s", pdf_to_name(gctx, subobj));
                } else if (pdf_is_string(gctx, subobj)) {
                    type = "string";
                    text = JM_UnicodeFromStr(pdf_to_text_string(gctx, subobj));
                } else {
                    type = "unknown";
                }
                if (!text) {
                    res = JM_object_to_buffer(gctx, subobj, 1, 0);
                    text = JM_UnicodeFromBuffer(gctx, res);
                }
                rc = Py_BuildValue("sO", type, text);
                Py_DECREF(text);
                goto finished;

                not_found:;
                rc = Py_BuildValue("ss", "null", "null");
                finished:;
            }
            fz_always(gctx) {
                if (xref > 0) {
                    pdf_drop_obj(gctx, obj);
                }
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return rc;
        }
SWIGINTERN PyObject *Document_xref_set_key(struct Document *self,int xref,char const *key,char *value){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *)self);
            pdf_obj *obj = NULL, *new_obj = NULL;
            int i, n;
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1) && xref != -1)
                    THROWMSG(gctx, "bad xref");
                if (strlen(value) == 0) {
                    THROWMSG(gctx, "bad 'value'");
                }
                if (strlen(key) == 0) {
                    THROWMSG(gctx, "bad 'key'");
                }
                if (xref != -1) {
                    obj = pdf_load_object(gctx, pdf, xref);
                } else {
                    obj = pdf_trailer(gctx, pdf);
                }
                new_obj = JM_set_object_value(gctx, obj, key, value);
                if (!new_obj) {
                    goto finished;  // did not work: skip update
                }
                if (xref != -1) {
                    pdf_drop_obj(gctx, obj);
                    obj = NULL;
                    pdf_update_object(gctx, pdf, xref, new_obj);
                } else {
                    n = pdf_dict_len(gctx, new_obj);
                    for (i = 0; i < n; i++) {
                        pdf_dict_put(gctx, obj, pdf_dict_get_key(gctx, new_obj, i), pdf_dict_get_val(gctx, new_obj, i));
                    }
                }
                pdf->dirty = 1;
                finished:;
            }
            fz_always(gctx) {
                if (xref != -1) {
                    pdf_drop_obj(gctx, obj);
                }
                pdf_drop_obj(gctx, new_obj);
                PyErr_Clear();
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document__extend_toc_items(struct Document *self,PyObject *items){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *)self);
            pdf_obj *bm, *col, *obj;
            int count, flags;
            PyObject *item=NULL, *itemdict=NULL, *xrefs, *bold, *italic, *collapse, *zoom;
            zoom = PyUnicode_FromString("zoom");
            bold = PyUnicode_FromString("bold");
            italic = PyUnicode_FromString("italic");
            collapse = PyUnicode_FromString("collapse");
            fz_try(gctx) {
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
                if (!root) goto finished;
                pdf_obj *olroot = pdf_dict_get(gctx, root, PDF_NAME(Outlines));
                if (!olroot) goto finished;
                pdf_obj *first = pdf_dict_get(gctx, olroot, PDF_NAME(First));
                if (!first) goto finished;
                xrefs = PyList_New(0);  // pre-allocate an empty list
                xrefs = JM_outline_xrefs(gctx, first, xrefs);
                Py_ssize_t i, n = PySequence_Size(xrefs);
                if (!n) goto finished;
                int xref;

                // update all TOC item dictionaries
                for (i = 0; i < n; i++) {
                    JM_INT_ITEM(xrefs, i, &xref);
                    item = PySequence_ITEM(items, i);
                    itemdict = PySequence_ITEM(item, 3);
                    if (!itemdict || !PyDict_Check(itemdict)) {
                        THROWMSG(gctx, "need non-simple TOC format");
                    }
                    PyDict_SetItem(itemdict, dictkey_xref, PySequence_ITEM(xrefs, i));
                    bm = pdf_load_object(gctx, pdf, xref);
                    flags = pdf_to_int(gctx, (pdf_dict_get(gctx, bm, PDF_NAME(F))));
                    if (flags == 1) {
                        PyDict_SetItem(itemdict, italic, Py_True);
                    } else if (flags == 2) {
                        PyDict_SetItem(itemdict, bold, Py_True);
                    } else if (flags == 3) {
                        PyDict_SetItem(itemdict, italic, Py_True);
                        PyDict_SetItem(itemdict, bold, Py_True);
                    }
                    count = pdf_to_int(gctx, (pdf_dict_get(gctx, bm, PDF_NAME(Count))));
                    if (count < 0) {
                        PyDict_SetItem(itemdict, collapse, Py_True);
                    } else if (count > 0) {
                        PyDict_SetItem(itemdict, collapse, Py_False);
                    }
                    col = pdf_dict_get(gctx, bm, PDF_NAME(C));
                    if (pdf_is_array(gctx, col) && pdf_array_len(gctx, col) == 3) {
                        PyObject *color = PyTuple_New(3);
                        PyTuple_SET_ITEM(color, 0, Py_BuildValue("f", pdf_to_real(gctx, pdf_array_get(gctx, col, 0))));
                        PyTuple_SET_ITEM(color, 1, Py_BuildValue("f", pdf_to_real(gctx, pdf_array_get(gctx, col, 1))));
                        PyTuple_SET_ITEM(color, 2, Py_BuildValue("f", pdf_to_real(gctx, pdf_array_get(gctx, col, 2))));
                        DICT_SETITEM_DROP(itemdict, dictkey_color, color);
                    }
                    float z=0;
                    obj = pdf_dict_get(gctx, bm, PDF_NAME(Dest));
                    if (!obj || !pdf_is_array(gctx, obj)) {
                        obj = pdf_dict_getl(gctx, bm, PDF_NAME(A), PDF_NAME(D), NULL);
                    }
                    if (pdf_is_array(gctx, obj) && pdf_array_len(gctx, obj) == 5) {
                        z = pdf_to_real(gctx, pdf_array_get(gctx, obj, 4));
                    }
                    DICT_SETITEM_DROP(itemdict, zoom, Py_BuildValue("f", z));
                    PyList_SetItem(item, 3, itemdict);
                    PyList_SetItem(items, i, item);
                    pdf_drop_obj(gctx, bm);
                    bm = NULL;
                }
                finished:;
            }
            fz_always(gctx) {
                Py_CLEAR(xrefs);
                Py_CLEAR(bold);
                Py_CLEAR(italic);
                Py_CLEAR(collapse);
                Py_CLEAR(zoom);
                pdf_drop_obj(gctx, bm);
                PyErr_Clear();
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document__embfile_names(struct Document *self,PyObject *namelist){
            fz_document *doc = (fz_document *) self;
            pdf_document *pdf = pdf_specifics(gctx, doc);
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                PyObject *val;
                pdf_obj *names = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                      PDF_NAME(Root),
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);
                if (pdf_is_array(gctx, names)) {
                    int i, n = pdf_array_len(gctx, names);
                    for (i=0; i < n; i+=2) {
                        val = JM_EscapeStrFromStr(pdf_to_text_string(gctx,
                                         pdf_array_get(gctx, names, i)));
                        LIST_APPEND_DROP(namelist, val);
                    }
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document__embfile_del(struct Document *self,int idx){
            fz_try(gctx) {
                fz_document *doc = (fz_document *) self;
                pdf_document *pdf = pdf_document_from_fz_document(gctx, doc);
                pdf_obj *names = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                      PDF_NAME(Root),
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);
                pdf_array_delete(gctx, names, idx + 1);
                pdf_array_delete(gctx, names, idx);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document__embfile_info(struct Document *self,int idx,PyObject *infodict){
            fz_document *doc = (fz_document *) self;
            pdf_document *pdf = pdf_document_from_fz_document(gctx, doc);
            char *name;
            int xref = 0, ci_xref=0;
            fz_try(gctx) {
                pdf_obj *names = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                      PDF_NAME(Root),
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);

                pdf_obj *o = pdf_array_get(gctx, names, 2*idx+1);
                pdf_obj *ci = pdf_dict_get(gctx, o, PDF_NAME(CI));
                if (ci) {
                    ci_xref = pdf_to_num(gctx, ci);
                }
                DICT_SETITEMSTR_DROP(infodict, "collection", Py_BuildValue("i", ci_xref));
                name = (char *) pdf_to_text_string(gctx,
                                          pdf_dict_get(gctx, o, PDF_NAME(F)));
                DICT_SETITEM_DROP(infodict, dictkey_filename, JM_EscapeStrFromStr(name));

                name = (char *) pdf_to_text_string(gctx,
                                    pdf_dict_get(gctx, o, PDF_NAME(UF)));
                DICT_SETITEM_DROP(infodict, dictkey_ufilename, JM_EscapeStrFromStr(name));

                name = (char *) pdf_to_text_string(gctx,
                                    pdf_dict_get(gctx, o, PDF_NAME(Desc)));
                DICT_SETITEM_DROP(infodict, dictkey_desc, JM_UnicodeFromStr(name));

                int len = -1, DL = -1;
                pdf_obj *fileentry = pdf_dict_getl(gctx, o, PDF_NAME(EF), PDF_NAME(F), NULL);
                xref = pdf_to_num(gctx, fileentry);
                o = pdf_dict_get(gctx, fileentry, PDF_NAME(Length));
                if (o) len = pdf_to_int(gctx, o);

                o = pdf_dict_get(gctx, fileentry, PDF_NAME(DL));
                if (o) {
                    DL = pdf_to_int(gctx, o);
                } else {
                    o = pdf_dict_getl(gctx, fileentry, PDF_NAME(Params),
                                   PDF_NAME(Size), NULL);
                    if (o) DL = pdf_to_int(gctx, o);
                }
                DICT_SETITEM_DROP(infodict, dictkey_size, Py_BuildValue("i", DL));
                DICT_SETITEM_DROP(infodict, dictkey_length, Py_BuildValue("i", len));
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *Document__embfile_upd(struct Document *self,int idx,PyObject *buffer,char *filename,char *ufilename,char *desc){
            fz_document *doc = (fz_document *) self;
            pdf_document *pdf = pdf_document_from_fz_document(gctx, doc);
            fz_buffer *res = NULL;
            fz_var(res);
            int xref = 0;
            fz_try(gctx) {
                pdf_obj *names = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                      PDF_NAME(Root),
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);

                pdf_obj *entry = pdf_array_get(gctx, names, 2*idx+1);

                pdf_obj *filespec = pdf_dict_getl(gctx, entry, PDF_NAME(EF),
                                                  PDF_NAME(F), NULL);
                if (!filespec) THROWMSG(gctx, "bad PDF: /EF object not found");
                res = JM_BufferFromBytes(gctx, buffer);
                if (EXISTS(buffer) && !res) THROWMSG(gctx, "bad type: 'buffer'");
                if (res)
                {
                    JM_update_stream(gctx, pdf, filespec, res, 1);
                    // adjust /DL and /Size parameters
                    int64_t len = (int64_t) fz_buffer_storage(gctx, res, NULL);
                    pdf_obj *l = pdf_new_int(gctx, len);
                    pdf_dict_put(gctx, filespec, PDF_NAME(DL), l);
                    pdf_dict_putl(gctx, filespec, l, PDF_NAME(Params), PDF_NAME(Size), NULL);
                }
                xref = pdf_to_num(gctx, filespec);
                if (filename)
                    pdf_dict_put_text_string(gctx, entry, PDF_NAME(F), filename);

                if (ufilename)
                    pdf_dict_put_text_string(gctx, entry, PDF_NAME(UF), ufilename);

                if (desc)
                    pdf_dict_put_text_string(gctx, entry, PDF_NAME(Desc), desc);
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx)
                return NULL;
            pdf->dirty = 1;
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *Document__embeddedFileGet(struct Document *self,int idx){
            fz_document *doc = (fz_document *) self;
            PyObject *cont = NULL;
            pdf_document *pdf = pdf_document_from_fz_document(gctx, doc);
            fz_buffer *buf = NULL;
            fz_var(buf);
            fz_try(gctx) {
                pdf_obj *names = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                      PDF_NAME(Root),
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);

                pdf_obj *entry = pdf_array_get(gctx, names, 2*idx+1);
                pdf_obj *filespec = pdf_dict_getl(gctx, entry, PDF_NAME(EF),
                                                  PDF_NAME(F), NULL);
                buf = pdf_load_stream(gctx, filespec);
                cont = JM_BinFromBuffer(gctx, buf);
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, buf);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return cont;
        }
SWIGINTERN PyObject *Document__embfile_add(struct Document *self,char const *name,PyObject *buffer,char *filename,char *ufilename,char *desc){
            fz_document *doc = (fz_document *) self;
            pdf_document *pdf = pdf_document_from_fz_document(gctx, doc);
            fz_buffer *data = NULL;
            unsigned char *buffdata;
            fz_var(data);
            int entry = 0;
            size_t size = 0;
            pdf_obj *names = NULL;
            int xref = 0; // xref of file entry
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                data = JM_BufferFromBytes(gctx, buffer);
                if (!data) THROWMSG(gctx, "bad type: 'buffer'");
                size = fz_buffer_storage(gctx, data, &buffdata);

                names = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                      PDF_NAME(Root),
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);
                if (!pdf_is_array(gctx, names)) {
                    pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf),
                                                 PDF_NAME(Root));
                    names = pdf_new_array(gctx, pdf, 6);  // an even number!
                    pdf_dict_putl_drop(gctx, root, names,
                                      PDF_NAME(Names),
                                      PDF_NAME(EmbeddedFiles),
                                      PDF_NAME(Names),
                                      NULL);
                }

                pdf_obj *fileentry = JM_embed_file(gctx, pdf, data,
                                                   filename,
                                                   ufilename,
                                                   desc, 1);
                xref = pdf_to_num(gctx, pdf_dict_getl(gctx, fileentry,
                                    PDF_NAME(EF), PDF_NAME(F), NULL));
                pdf_array_push(gctx, names, pdf_new_text_string(gctx, name));
                pdf_array_push_drop(gctx, names, fileentry);
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, data);
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdf->dirty = 1;
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *Document_convert_to_pdf(struct Document *self,int from_page,int to_page,int rotate){
            PyObject *doc = NULL;
            fz_document *fz_doc = (fz_document *) self;
            fz_try(gctx) {
                int fp = from_page, tp = to_page, srcCount = fz_count_pages(gctx, fz_doc);
                if (fp < 0) fp = 0;
                if (fp > srcCount - 1) fp = srcCount - 1;
                if (tp < 0) tp = srcCount - 1;
                if (tp > srcCount - 1) tp = srcCount - 1;
                doc = JM_convert_to_pdf(gctx, fz_doc, fp, tp, rotate);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return doc;
        }
SWIGINTERN PyObject *Document_page_count(struct Document *self){
            PyObject *ret;
            fz_try(gctx) {
                ret = Py_BuildValue("i", fz_count_pages(gctx, (fz_document *) self));
            }
            fz_catch(gctx) {
                PyErr_Clear();
                return NULL;
            }
            return ret;
        }
SWIGINTERN PyObject *Document_chapter_count(struct Document *self){
            PyObject *ret;
            fz_try(gctx) {
                ret = Py_BuildValue("i", fz_count_chapters(gctx, (fz_document *) self));
            }
            fz_catch(gctx) {
                return NULL;
            }
            return ret;
        }
SWIGINTERN PyObject *Document_last_location(struct Document *self){
            fz_document *this_doc = (fz_document *) self;
            fz_location last_loc;
            fz_try(gctx) {
                last_loc = fz_last_page(gctx, this_doc);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("ii", last_loc.chapter, last_loc.page);
        }
SWIGINTERN PyObject *Document_chapter_page_count(struct Document *self,int chapter){
            int pages = 0;
            fz_try(gctx) {
                int chapters = fz_count_chapters(gctx, (fz_document *) self);
                if (chapter < 0 || chapter >= chapters)
                    THROWMSG(gctx, "bad chapter number");
                pages = fz_count_chapter_pages(gctx, (fz_document *) self, chapter);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("i", pages);
        }
SWIGINTERN PyObject *Document_prev_location(struct Document *self,PyObject *page_id){
            fz_document *this_doc = (fz_document *) self;
            fz_location prev_loc, loc;
            PyObject *val;
            int pno;
            fz_try(gctx) {
                val = PySequence_GetItem(page_id, 0);
                if (!val) THROWMSG(gctx, "bad page id");
                int chapter = (int) PyLong_AsLong(val);
                Py_DECREF(val);
                if (PyErr_Occurred()) THROWMSG(gctx, "bad page id");

                val = PySequence_GetItem(page_id, 1);
                if (!val) THROWMSG(gctx, "bad page id");
                pno = (int) PyLong_AsLong(val);
                Py_DECREF(val);
                if (PyErr_Occurred()) THROWMSG(gctx, "bad page id");

                loc = fz_make_location(chapter, pno);
                prev_loc = fz_previous_page(gctx, this_doc, loc);
            }
            fz_catch(gctx) {
                PyErr_Clear();
                return NULL;
            }
            return Py_BuildValue("ii", prev_loc.chapter, prev_loc.page);
        }
SWIGINTERN PyObject *Document_next_location(struct Document *self,PyObject *page_id){
            fz_document *this_doc = (fz_document *) self;
            fz_location next_loc, loc;
            int page_n = -1;
            PyObject *val;
            int pno;
            fz_try(gctx) {
                val = PySequence_GetItem(page_id, 0);
                if (!val) THROWMSG(gctx, "bad page id");
                int chapter = (int) PyLong_AsLong(val);
                Py_DECREF(val);
                if (PyErr_Occurred()) THROWMSG(gctx, "bad page id");

                val = PySequence_GetItem(page_id, 1);
                if (!val) THROWMSG(gctx, "bad page id");
                pno = (int) PyLong_AsLong(val);
                Py_DECREF(val);
                if (PyErr_Occurred()) THROWMSG(gctx, "bad page id");

                loc = fz_make_location(chapter, pno);
                next_loc = fz_next_page(gctx, this_doc, loc);
            }
            fz_catch(gctx) {
                PyErr_Clear();
                return NULL;
            }
            return Py_BuildValue("ii", next_loc.chapter, next_loc.page);
        }
SWIGINTERN PyObject *Document_location_from_page_number(struct Document *self,int pno){
            fz_document *this_doc = (fz_document *) self;
            fz_location loc = fz_make_location(-1, -1);
            int page_count = fz_count_pages(gctx, this_doc);
            while (pno < 0) pno += page_count;
            fz_try(gctx) {
                if (pno >= page_count)
                    THROWMSG(gctx, "bad page number(s)");
                loc = fz_location_from_page_number(gctx, this_doc, pno);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("ii", loc.chapter, loc.page);
        }
SWIGINTERN PyObject *Document_page_number_from_location(struct Document *self,PyObject *page_id){
            fz_document *this_doc = (fz_document *) self;
            fz_location loc;
            int page_n = -1;
            PyObject *val;
            int pno;
            fz_try(gctx) {
                val = PySequence_GetItem(page_id, 0);
                if (!val) THROWMSG(gctx, "bad page id");
                int chapter = (int) PyLong_AsLong(val);
                Py_DECREF(val);
                if (PyErr_Occurred()) THROWMSG(gctx, "bad page id");

                val = PySequence_GetItem(page_id, 1);
                if (!val) THROWMSG(gctx, "bad page id");
                pno = (int) PyLong_AsLong(val);
                Py_DECREF(val);
                if (PyErr_Occurred()) THROWMSG(gctx, "bad page id");

                loc = fz_make_location(chapter, pno);
                page_n = fz_page_number_from_location(gctx, this_doc, loc);
            }
            fz_catch(gctx) {
                PyErr_Clear();
                return NULL;
            }
            return Py_BuildValue("i", page_n);
        }
SWIGINTERN PyObject *Document__getMetadata(struct Document *self,char const *key){
            PyObject *res = NULL;
            fz_document *doc = (fz_document *) self;
            int vsize;
            char *value;
            fz_try(gctx) {
                vsize = fz_lookup_metadata(gctx, doc, key, NULL, 0)+1;
                if(vsize > 1) {
                    value = JM_Alloc(char, vsize);
                    fz_lookup_metadata(gctx, doc, key, value, vsize);
                    res = JM_UnicodeFromStr(value);
                    JM_Free(value);
                } else {
                    res = EMPTY_STRING;
                }
            }
            fz_always(gctx) {
                PyErr_Clear();
            }
            fz_catch(gctx) {
                return EMPTY_STRING;
            }
            return res;
        }
SWIGINTERN PyObject *Document_needs_pass(struct Document *self){
            return JM_BOOL(fz_needs_password(gctx, (fz_document *) self));
        }
SWIGINTERN PyObject *Document_language(struct Document *self){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            if (!pdf) Py_RETURN_NONE;
            fz_text_language lang = pdf_document_language(gctx, pdf);
            char buf[8];
            if (lang == FZ_LANG_UNSET) Py_RETURN_NONE;
            return Py_BuildValue("s", fz_string_from_text_language(buf, lang));
        }
SWIGINTERN PyObject *Document_set_language(struct Document *self,char *language){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                fz_text_language lang;
                if (!language)
                    lang = FZ_LANG_UNSET;
                else
                    lang = fz_text_language_from_string(language);
                pdf_set_document_language(gctx, pdf, lang);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_TRUE;
        }
SWIGINTERN PyObject *Document_resolve_link(struct Document *self,char *uri,int chapters){
            if (!uri) {
                if (chapters) return Py_BuildValue("(ii)ff", -1, -1, 0, 0);
                return Py_BuildValue("iff", -1, 0, 0);
            }
            fz_document *this_doc = (fz_document *) self;
            float xp = 0, yp = 0;
            fz_location loc = {0, 0};
            fz_try(gctx) {
                loc = fz_resolve_link(gctx, (fz_document *) self, uri, &xp, &yp);
            }
            fz_catch(gctx) {
                if (chapters) return Py_BuildValue("(ii)ff", -1, -1, 0, 0);
                return Py_BuildValue("iff", -1, 0, 0);
            }
            if (chapters)
                return Py_BuildValue("(ii)ff", loc.chapter, loc.page, xp, yp);
            int pno = fz_page_number_from_location(gctx, this_doc, loc);
            return Py_BuildValue("iff", pno, xp, yp);
        }
SWIGINTERN PyObject *Document_layout(struct Document *self,PyObject *rect,float width,float height,float fontsize){
            fz_document *doc = (fz_document *) self;
            if (!fz_is_document_reflowable(gctx, doc)) Py_RETURN_NONE;
            fz_try(gctx) {
                float w = width, h = height;
                fz_rect r = JM_rect_from_py(rect);
                if (!fz_is_infinite_rect(r)) {
                    w = r.x1 - r.x0;
                    h = r.y1 - r.y0;
                }
                if (w <= 0.0f || h <= 0.0f)
                        THROWMSG(gctx, "invalid page size");
                fz_layout_document(gctx, doc, w, h, fontsize);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_make_bookmark(struct Document *self,PyObject *loc){
            fz_document *doc = (fz_document *) self;
            fz_location location;
            fz_bookmark mark;
            fz_try(gctx) {
                if (JM_INT_ITEM(loc, 0, &location.chapter) == 1)
                    THROWMSG(gctx, "Bad location");
                if (JM_INT_ITEM(loc, 1, &location.page) == 1)
                    THROWMSG(gctx, "Bad location");
                mark = fz_make_bookmark(gctx, doc, location);
                if (!mark) THROWMSG(gctx, "Bad location");
            }
            fz_catch(gctx) {
                return NULL;
            }
            return PyLong_FromVoidPtr((void *) mark);
        }
SWIGINTERN PyObject *Document_find_bookmark(struct Document *self,PyObject *bm){
            fz_document *doc = (fz_document *) self;
            fz_location location;
            fz_try(gctx) {
                intptr_t mark = (intptr_t) PyLong_AsVoidPtr(bm);
                location = fz_lookup_bookmark(gctx, doc, mark);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("ii", location.chapter, location.page);
        }
SWIGINTERN PyObject *Document_is_reflowable(struct Document *self){
            return JM_BOOL(fz_is_document_reflowable(gctx, (fz_document *) self));
        }
SWIGINTERN PyObject *Document__deleteObject(struct Document *self,int xref){
            fz_document *doc = (fz_document *) self;
            pdf_document *pdf = pdf_specifics(gctx, doc);
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                if (!INRANGE(xref, 1, pdf_xref_len(gctx, pdf)-1))
                    THROWMSG(gctx, "bad xref");
                pdf_delete_object(gctx, pdf, xref);
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdf->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_pdf_catalog(struct Document *self){
            fz_document *doc = (fz_document *) self;
            pdf_document *pdf = pdf_specifics(gctx, doc);
            int xref = 0;
            if (!pdf) return Py_BuildValue("i", xref);
            fz_try(gctx) {
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf),
                                             PDF_NAME(Root));
                xref = pdf_to_num(gctx, root);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *Document__getPDFfileid(struct Document *self){
            fz_document *doc = (fz_document *) self;
            pdf_document *pdf = pdf_specifics(gctx, doc);
            if (!pdf) Py_RETURN_NONE;
            PyObject *idlist = PyList_New(0);
            fz_buffer *buffer = NULL;
            unsigned char *hex;
            pdf_obj *o;
            int n, i, len;
            PyObject *bytes;

            fz_try(gctx) {
                pdf_obj *identity = pdf_dict_get(gctx, pdf_trailer(gctx, pdf),
                                             PDF_NAME(ID));
                if (identity) {
                    n = pdf_array_len(gctx, identity);
                    for (i = 0; i < n; i++) {
                        o = pdf_array_get(gctx, identity, i);
                        len = (int) pdf_to_str_len(gctx, o);
                        buffer = fz_new_buffer(gctx, 2 * len);
                        fz_buffer_storage(gctx, buffer, &hex);
                        hexlify(len, (unsigned char *) pdf_to_text_string(gctx, o), hex);
                        LIST_APPEND_DROP(idlist, JM_UnicodeFromStr(hex));
                        Py_CLEAR(bytes);
                        fz_drop_buffer(gctx, buffer);
                        buffer = NULL;
                    }
                }
            }
            fz_catch(gctx) {
                fz_drop_buffer(gctx, buffer);
            }
            return idlist;
        }
SWIGINTERN PyObject *Document_is_pdf(struct Document *self){
            if (pdf_specifics(gctx, (fz_document *) self)) Py_RETURN_TRUE;
            else Py_RETURN_FALSE;
        }
SWIGINTERN PyObject *Document_has_xref_streams(struct Document *self){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            if (!pdf) Py_RETURN_FALSE;
            if (pdf->has_xref_streams) Py_RETURN_TRUE;
            Py_RETURN_FALSE;
        }
SWIGINTERN PyObject *Document_has_old_style_xrefs(struct Document *self){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            if (!pdf) Py_RETURN_FALSE;
            if (pdf->has_old_style_xrefs) Py_RETURN_TRUE;
            Py_RETURN_FALSE;
        }
SWIGINTERN PyObject *Document_is_dirty(struct Document *self){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            if (!pdf) Py_RETURN_FALSE;
            return JM_BOOL(pdf_has_unsaved_changes(gctx, pdf));
        }
SWIGINTERN PyObject *Document_can_save_incrementally(struct Document *self){
            pdf_document *pdf = pdf_document_from_fz_document(gctx, (fz_document *) self);
            if (!pdf) Py_RETURN_FALSE; // gracefully handle non-PDF
            return JM_BOOL(pdf_can_be_saved_incrementally(gctx, pdf));
        }
SWIGINTERN PyObject *Document_is_repaired(struct Document *self){
            pdf_document *pdf = pdf_document_from_fz_document(gctx, (fz_document *) self);
            if (!pdf) Py_RETURN_FALSE; // gracefully handle non-PDF
            return JM_BOOL(pdf_was_repaired(gctx, pdf));
        }
SWIGINTERN PyObject *Document_authenticate(struct Document *self,char *password){
            return Py_BuildValue("i", fz_authenticate_password(gctx, (fz_document *) self, (const char *) password));
        }
SWIGINTERN PyObject *Document_save(struct Document *self,PyObject *filename,int garbage,int clean,int deflate,int deflate_images,int deflate_fonts,int incremental,int ascii,int expand,int linear,int pretty,int encryption,int permissions,char *owner_pw,char *user_pw){
            pdf_write_options opts = pdf_default_write_options;
            opts.do_incremental     = incremental;
            opts.do_ascii           = ascii;
            opts.do_compress        = deflate;
            opts.do_compress_images = deflate_images;
            opts.do_compress_fonts  = deflate_fonts;
            opts.do_decompress      = expand;
            opts.do_garbage         = garbage;
            opts.do_pretty          = pretty;
            opts.do_linear          = linear;
            opts.do_clean           = clean;
            opts.do_sanitize        = clean;
            opts.do_encrypt         = encryption;
            opts.permissions        = permissions;
            if (owner_pw) {
                memcpy(&opts.opwd_utf8, owner_pw, strlen(owner_pw)+1);
            } else if (user_pw) {
                memcpy(&opts.opwd_utf8, user_pw, strlen(user_pw)+1);
            }
            if (user_pw) {
                memcpy(&opts.upwd_utf8, user_pw, strlen(user_pw)+1);
            }

            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            fz_output *out = NULL;
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                JM_embedded_clean(gctx, pdf);
                JM_ensure_identity(gctx, pdf);
                if (PyUnicode_Check(filename)) {
                    pdf_save_document(gctx, pdf, JM_StrAsChar(filename), &opts);
                } else {
                    out = JM_new_output_fileptr(gctx, filename);
                    pdf_write_document(gctx, pdf, out, &opts);
                }
                pdf->dirty = 0;
            }
            fz_always(gctx) {
                fz_drop_output(gctx, out);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_insert_pdf(struct Document *self,struct Document *docsrc,int from_page,int to_page,int start_at,int rotate,int links,int annots,int show_progress,int final,struct Graftmap *_gmap){
            fz_document *doc = (fz_document *) self;
            pdf_document *pdfout = pdf_specifics(gctx, doc);
            pdf_document *pdfsrc = pdf_specifics(gctx, (fz_document *) docsrc);
            int outCount = fz_count_pages(gctx, doc);
            int srcCount = fz_count_pages(gctx, (fz_document *) docsrc);

            // local copies of page numbers
            int fp = from_page, tp = to_page, sa = start_at;

            // normalize page numbers
            fp = MAX(fp, 0);                // -1 = first page
            fp = MIN(fp, srcCount - 1);     // but do not exceed last page

            if (tp < 0) tp = srcCount - 1;  // -1 = last page
            tp = MIN(tp, srcCount - 1);     // but do not exceed last page

            if (sa < 0) sa = outCount;      // -1 = behind last page
            sa = MIN(sa, outCount);         // but that is also the limit

            fz_try(gctx) {
                if (!pdfout || !pdfsrc) THROWMSG(gctx, "source or target not a PDF");
                JM_merge_range(gctx, pdfout, pdfsrc, fp, tp, sa, rotate, links, annots, show_progress, (pdf_graft_map *) _gmap);
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdfout->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document__newPage(struct Document *self,int pno,float width,float height){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            fz_rect mediabox = fz_unit_rect;
            mediabox.x1 = width;
            mediabox.y1 = height;
            pdf_obj *resources = NULL, *page_obj = NULL;
            fz_buffer *contents = NULL;
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                if (pno < -1) THROWMSG(gctx, "bad page number(s)");
                // create /Resources and /Contents objects
                resources = pdf_add_object_drop(gctx, pdf, pdf_new_dict(gctx, pdf, 1));
                page_obj = pdf_add_page(gctx, pdf, mediabox, 0, resources, contents);
                pdf_insert_page(gctx, pdf, pno, page_obj);
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, contents);
                pdf_drop_obj(gctx, page_obj);
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdf->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_select(struct Document *self,PyObject *pyliste){
            // preparatory stuff:
            // (1) get underlying pdf document,
            // (2) transform Python list into integer array

            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            fz_try(gctx) {
                // call retainpages (code copy of fz_clean_file.c)
                globals glo = {0};
                glo.ctx = gctx;
                glo.doc = pdf;
                retainpages(gctx, &glo, pyliste);
                if (pdf->rev_page_map)
                {
                    pdf_drop_page_tree(gctx, pdf);
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdf->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document__delete_page(struct Document *self,int pno){
            fz_try(gctx) {
                fz_document *doc = (fz_document *) self;
                pdf_document *pdf = pdf_specifics(gctx, doc);
                pdf_delete_page(gctx, pdf, pno);
                if (pdf->rev_page_map)
                {
                    pdf_drop_page_tree(gctx, pdf);
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_permissions(struct Document *self){
            fz_document *doc = (fz_document *) self;
            pdf_document *pdf = pdf_document_from_fz_document(gctx, doc);

            // for PDF return result of standard function
            if (pdf)
                return Py_BuildValue("i", pdf_document_permissions(gctx, pdf));

            // otherwise simulate the PDF return value
            int perm = (int) 0xFFFFFFFC;  // all permissions granted
            // now switch off where needed
            if (!fz_has_permission(gctx, doc, FZ_PERMISSION_PRINT))
                perm = perm ^ PDF_PERM_PRINT;
            if (!fz_has_permission(gctx, doc, FZ_PERMISSION_EDIT))
                perm = perm ^ PDF_PERM_MODIFY;
            if (!fz_has_permission(gctx, doc, FZ_PERMISSION_COPY))
                perm = perm ^ PDF_PERM_COPY;
            if (!fz_has_permission(gctx, doc, FZ_PERMISSION_ANNOTATE))
                perm = perm ^ PDF_PERM_ANNOTATE;
            return Py_BuildValue("i", perm);
        }
SWIGINTERN PyObject *Document__get_char_widths(struct Document *self,int xref,char *bfname,char *ext,int ordering,int limit,int idx){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            PyObject *wlist = NULL;
            int i, glyph, mylimit;
            mylimit = limit;
            if (mylimit < 256) mylimit = 256;
            int cwlen = 0;
            int lang = 0;
            const unsigned char *data;
            int size, index;
            fz_font *font = NULL, *fb_font= NULL;
            fz_buffer *buf = NULL;

            fz_try(gctx) {
                ASSERT_PDF(pdf);
                if (ordering >= 0) {
                    data = fz_lookup_cjk_font(gctx, ordering, &size, &index);
                    font = fz_new_font_from_memory(gctx, NULL, data, size, index, 0);
                    goto weiter;
                }
                data = fz_lookup_base14_font(gctx, bfname, &size);
                if (data) {
                    font = fz_new_font_from_memory(gctx, bfname, data, size, 0, 0);
                    goto weiter;
                }
                buf = JM_get_fontbuffer(gctx, pdf, xref);
                if (!buf) {
                    fz_throw(gctx, FZ_ERROR_GENERIC, "font at xref %d is not supported", xref);
                }
                font = fz_new_font_from_buffer(gctx, NULL, buf, idx, 0);

                weiter:;
                wlist = PyList_New(0);
                float adv;
                for (i = 0; i < mylimit; i++) {
                    glyph = fz_encode_character(gctx, font, i);
                    adv = fz_advance_glyph(gctx, font, glyph, 0);
                    if (ordering >= 0) {
                        glyph = i;
                    }
                    if (glyph > 0) {
                        LIST_APPEND_DROP(wlist, Py_BuildValue("if", glyph, adv));
                    } else {
                        LIST_APPEND_DROP(wlist, Py_BuildValue("if", glyph, 0.0));
                    }
                }
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, buf);
                fz_drop_font(gctx, font);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return wlist;
        }
SWIGINTERN PyObject *Document_page_xref(struct Document *self,int pno){
            fz_document *this_doc = (fz_document *) self;
            int page_count = fz_count_pages(gctx, this_doc);
            int n = pno;
            while (n < 0) n += page_count;
            pdf_document *pdf = pdf_specifics(gctx, this_doc);
            int xref = 0;
            fz_try(gctx) {
                if (n >= page_count) THROWMSG(gctx, "bad page number(s)");
                ASSERT_PDF(pdf);
                xref = pdf_to_num(gctx, pdf_lookup_page_obj(gctx, pdf, n));
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *Document_page_annot_xrefs(struct Document *self,int pno){
            fz_document *this_doc = (fz_document *) self;
            int page_count = fz_count_pages(gctx, this_doc);
            int n = pno;
            while (n < 0) n += page_count;
            pdf_document *pdf = pdf_specifics(gctx, this_doc);
            PyObject *annots = NULL;
            fz_try(gctx) {
                if (n >= page_count) THROWMSG(gctx, "bad page number(s)");
                ASSERT_PDF(pdf);
                annots = JM_get_annot_xref_list(gctx, pdf_lookup_page_obj(gctx, pdf, n));
            }
            fz_catch(gctx) {
                return NULL;
            }
            return annots;
        }
SWIGINTERN PyObject *Document_page_cropbox(struct Document *self,int pno){
            fz_document *this_doc = (fz_document *) self;
            int page_count = fz_count_pages(gctx, this_doc);
            int n = pno;
            while (n < 0) n += page_count;
            pdf_obj *pageref = NULL;
            fz_var(pageref);
            pdf_document *pdf = pdf_specifics(gctx, this_doc);
            fz_try(gctx) {
                if (n >= page_count) THROWMSG(gctx, "bad page number(s)");
                ASSERT_PDF(pdf);
                pageref = pdf_lookup_page_obj(gctx, pdf, n);
            }
            fz_catch(gctx) {
                return NULL;
            }

            fz_rect cropbox = JM_cropbox(gctx, pageref);
            return JM_py_from_rect(cropbox);
        }
SWIGINTERN PyObject *Document__getPageInfo(struct Document *self,int pno,int what){
            fz_document *doc = (fz_document *) self;
            pdf_document *pdf = pdf_specifics(gctx, doc);
            pdf_obj *pageref, *rsrc;
            PyObject *liste = NULL, *tracer = NULL;
            fz_var(liste);
            fz_var(tracer);
            fz_try(gctx) {
                int page_count = fz_count_pages(gctx, doc);
                int n = pno;  // pno < 0 is allowed
                while (n < 0) n += page_count;  // make it non-negative
                if (n >= page_count) THROWMSG(gctx, "bad page number(s)");
                ASSERT_PDF(pdf);
                pageref = pdf_lookup_page_obj(gctx, pdf, n);
                rsrc = pdf_dict_get_inheritable(gctx,
                           pageref, PDF_NAME(Resources));
                liste = PyList_New(0);
                tracer = PyList_New(0);
                if (rsrc) {
                    JM_scan_resources(gctx, pdf, rsrc, liste, what, 0, tracer);
                }
            }
            fz_always(gctx) {
                Py_DECREF(tracer);
            }
            fz_catch(gctx) {
                Py_XDECREF(liste);
                return NULL;
            }
            return liste;
        }
SWIGINTERN PyObject *Document_extract_font(struct Document *self,int xref,int info_only){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);

            fz_try(gctx) {
                ASSERT_PDF(pdf);
            }
            fz_catch(gctx) {
                return NULL;
            }

            fz_buffer *buffer = NULL;
            pdf_obj *obj, *basefont, *bname;
            PyObject *bytes = NULL;
            char *ext = NULL;
            PyObject *tuple;
            Py_ssize_t len = 0;
            fz_try(gctx) {
                obj = pdf_load_object(gctx, pdf, xref);
                pdf_obj *type = pdf_dict_get(gctx, obj, PDF_NAME(Type));
                pdf_obj *subtype = pdf_dict_get(gctx, obj, PDF_NAME(Subtype));
                if(pdf_name_eq(gctx, type, PDF_NAME(Font)) &&
                   strncmp(pdf_to_name(gctx, subtype), "CIDFontType", 11) != 0) {
                    basefont = pdf_dict_get(gctx, obj, PDF_NAME(BaseFont));
                    if (!basefont || pdf_is_null(gctx, basefont)) {
                        bname = pdf_dict_get(gctx, obj, PDF_NAME(Name));
                    } else {
                        bname = basefont;
                    }
                    ext = JM_get_fontextension(gctx, pdf, xref);
                    if (strcmp(ext, "n/a") != 0 && !info_only) {
                        buffer = JM_get_fontbuffer(gctx, pdf, xref);
                        bytes = JM_BinFromBuffer(gctx, buffer);
                        fz_drop_buffer(gctx, buffer);
                    } else {
                        bytes = Py_BuildValue("y", "");
                    }
                    tuple = PyTuple_New(4);
                    PyTuple_SET_ITEM(tuple, 0, JM_EscapeStrFromStr(pdf_to_name(gctx, bname)));
                    PyTuple_SET_ITEM(tuple, 1, JM_UnicodeFromStr(ext));
                    PyTuple_SET_ITEM(tuple, 2, JM_UnicodeFromStr(pdf_to_name(gctx, subtype)));
                    PyTuple_SET_ITEM(tuple, 3, bytes);
                } else {
                    tuple = Py_BuildValue("sssy", "", "", "", "");
                }
            }
            fz_always(gctx) {
                pdf_drop_obj(gctx, obj);
                JM_PyErr_Clear;
            }
            fz_catch(gctx) {
                tuple = Py_BuildValue("sssy", "invalid-name", "", "", "");
            }
            return tuple;
        }
SWIGINTERN PyObject *Document_extract_image(struct Document *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            pdf_obj *obj = NULL;
            fz_buffer *res = NULL;
            fz_image *img = NULL;
            PyObject *rc = NULL;
            const char *ext = NULL;
            const char *cs_name = NULL;
            int img_type = 0, xres, yres, colorspace;
            int smask = 0, width, height, bpc;
            fz_compressed_buffer *cbuf = NULL;
            fz_var(img);
            fz_var(res);
            fz_var(obj);

            fz_try(gctx) {
                ASSERT_PDF(pdf);
                if (!INRANGE(xref, 1, pdf_xref_len(gctx, pdf)-1))
                    THROWMSG(gctx, "bad xref");

                obj = pdf_new_indirect(gctx, pdf, xref, 0);
                pdf_obj *subtype = pdf_dict_get(gctx, obj, PDF_NAME(Subtype));

                if (!pdf_name_eq(gctx, subtype, PDF_NAME(Image)))
                    THROWMSG(gctx, "not an image");

                pdf_obj *o = pdf_dict_geta(gctx, obj, PDF_NAME(SMask), PDF_NAME(Mask));
                if (o) smask = pdf_to_num(gctx, o);

                if (pdf_is_jpx_image(gctx, obj)) {
                    img_type = FZ_IMAGE_JPX;
                    ext = "jpx";
                }
                if (JM_is_jbig2_image(gctx, obj)) {
                    img_type = FZ_IMAGE_JBIG2;
                    ext = "jb2";
                }
                res = pdf_load_raw_stream(gctx, obj);
                if (img_type == FZ_IMAGE_UNKNOWN) {
                    unsigned char *c = NULL;
                    fz_buffer_storage(gctx, res, &c);
                    img_type = fz_recognize_image_format(gctx, c);
                    ext = JM_image_extension(img_type);
                }
                if (img_type == FZ_IMAGE_UNKNOWN) {
                    fz_drop_buffer(gctx, res);
                    res = NULL;
                    img = pdf_load_image(gctx, pdf, obj);
                    res = fz_new_buffer_from_image_as_png(gctx, img,
                                fz_default_color_params);
                    ext = "png";
                } else /*if (smask == 0)*/ {
                    img = fz_new_image_from_buffer(gctx, res);
                }
                fz_image_resolution(img, &xres, &yres);
                width = img->w;
                height = img->h;
                colorspace = img->n;
                bpc = img->bpc;
                cs_name = fz_colorspace_name(gctx, img->colorspace);

                rc = PyDict_New();
                DICT_SETITEM_DROP(rc, dictkey_ext,
                                    JM_UnicodeFromStr(ext));
                DICT_SETITEM_DROP(rc, dictkey_smask,
                                    Py_BuildValue("i", smask));
                DICT_SETITEM_DROP(rc, dictkey_width,
                                    Py_BuildValue("i", width));
                DICT_SETITEM_DROP(rc, dictkey_height,
                                    Py_BuildValue("i", height));
                DICT_SETITEM_DROP(rc, dictkey_colorspace,
                                    Py_BuildValue("i", colorspace));
                DICT_SETITEM_DROP(rc, dictkey_bpc,
                                    Py_BuildValue("i", bpc));
                DICT_SETITEM_DROP(rc, dictkey_xres,
                                    Py_BuildValue("i", xres));
                DICT_SETITEM_DROP(rc, dictkey_yres,
                                    Py_BuildValue("i", yres));
                DICT_SETITEM_DROP(rc, dictkey_cs_name,
                                    JM_UnicodeFromStr(cs_name));
                DICT_SETITEM_DROP(rc, dictkey_image,
                                    JM_BinFromBuffer(gctx, res));
            }
            fz_always(gctx) {
                fz_drop_image(gctx, img);
                if (!cbuf) fz_drop_buffer(gctx, res);
                pdf_drop_obj(gctx, obj);
            }

            fz_catch(gctx) {
                Py_CLEAR(rc);
                Py_RETURN_NONE;
            }
            if (!rc)
                Py_RETURN_NONE;
            return rc;
        }
SWIGINTERN PyObject *Document__delToC(struct Document *self){
            PyObject *xrefs = PyList_New(0);          // create Python list
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            if (!pdf) return xrefs;                   // not a pdf

            pdf_obj *root, *olroot, *first;
            int xref_count, olroot_xref, i, xref;

            // get the main root
            root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
            // get the outline root
            olroot = pdf_dict_get(gctx, root, PDF_NAME(Outlines));
            if (!olroot) return xrefs;                // no outlines or some problem

            first = pdf_dict_get(gctx, olroot, PDF_NAME(First)); // first outline

            xrefs = JM_outline_xrefs(gctx, first, xrefs);
            xref_count = (int) PyList_Size(xrefs);

            olroot_xref = pdf_to_num(gctx, olroot);        // delete OL root
            pdf_delete_object(gctx, pdf, olroot_xref);     // delete OL root
            pdf_dict_del(gctx, root, PDF_NAME(Outlines));  // delete OL root

            for (i = 0; i < xref_count; i++)
            {
                JM_INT_ITEM(xrefs, i, &xref);
                pdf_delete_object(gctx, pdf, xref);      // delete outline item
            }
            LIST_APPEND_DROP(xrefs, Py_BuildValue("i", olroot_xref));
            pdf->dirty = 1;
            return xrefs;
        }
SWIGINTERN PyObject *Document_is_stream(struct Document *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            if (!pdf) Py_RETURN_FALSE;  // not a PDF
            if (xref == -1) return JM_BOOL(pdf_is_stream(gctx, pdf_trailer(gctx, pdf)));
            return JM_BOOL(pdf_obj_num_is_stream(gctx, pdf, xref));
        }
SWIGINTERN PyObject *Document_need_appearances(struct Document *self,PyObject *value){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            int oldval = -1;
            pdf_obj *app = NULL;
            char appkey[] = "NeedAppearances";
            fz_try(gctx) {
                pdf_obj *form = pdf_dict_getp(gctx, pdf_trailer(gctx, pdf),
                                "Root/AcroForm");
                app = pdf_dict_gets(gctx, form, appkey);
                if (pdf_is_bool(gctx, app)) {
                    oldval = pdf_to_bool(gctx, app);
                }

                if (EXISTS(value)) {
                    pdf_dict_puts_drop(gctx, form, appkey, PDF_TRUE);
                } else if (value == Py_False) {
                    pdf_dict_puts_drop(gctx, form, appkey, PDF_FALSE);
                }
            }
            fz_catch(gctx) {
                Py_RETURN_NONE;
            }
            if (value != Py_None) {
                return value;
            }
            if (oldval >= 0) {
                return JM_BOOL(oldval);
            }
            Py_RETURN_NONE;
        }
SWIGINTERN int Document_get_sigflags(struct Document *self){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            if (!pdf) return -1;  // not a PDF
            int sigflag = -1;
            fz_try(gctx) {
                pdf_obj *sigflags = pdf_dict_getl(gctx,
                                        pdf_trailer(gctx, pdf),
                                        PDF_NAME(Root),
                                        PDF_NAME(AcroForm),
                                        PDF_NAME(SigFlags),
                                        NULL);
                if (sigflags) {
                    sigflag = (int) pdf_to_int(gctx, sigflags);
                }
            }
            fz_catch(gctx) {
                return -1;  // any problem
            }
            return sigflag;
        }
SWIGINTERN PyObject *Document_is_form_pdf(struct Document *self){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            if (!pdf) Py_RETURN_FALSE;  // not a PDF
            int count = -1;  // init count
            fz_try(gctx) {
                pdf_obj *fields = pdf_dict_getl(gctx,
                                                pdf_trailer(gctx, pdf),
                                                PDF_NAME(Root),
                                                PDF_NAME(AcroForm),
                                                PDF_NAME(Fields),
                                                NULL);
                if (pdf_is_array(gctx, fields)) {
                    count = pdf_array_len(gctx, fields);
                }
            }
            fz_catch(gctx) {
                Py_RETURN_FALSE;
            }
            if (count >= 0) {
                return Py_BuildValue("i", count);
            } else {
                Py_RETURN_FALSE;
            }
        }
SWIGINTERN PyObject *Document_FormFonts(struct Document *self){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            if (!pdf) Py_RETURN_NONE;           // not a PDF
            pdf_obj *fonts = NULL;
            PyObject *liste = PyList_New(0);
            fz_var(liste);
            fz_try(gctx) {
                fonts = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root), PDF_NAME(AcroForm), PDF_NAME(DR), PDF_NAME(Font), NULL);
                if (fonts && pdf_is_dict(gctx, fonts))       // fonts exist
                {
                    int i, n = pdf_dict_len(gctx, fonts);
                    for (i = 0; i < n; i++)
                    {
                        pdf_obj *f = pdf_dict_get_key(gctx, fonts, i);
                        LIST_APPEND_DROP(liste, JM_UnicodeFromStr(pdf_to_name(gctx, f)));
                    }
                }
            }
            fz_catch(gctx) {
                Py_DECREF(liste);
                Py_RETURN_NONE;  // any problem yields None
            }
            return liste;
        }
SWIGINTERN PyObject *Document__addFormFont(struct Document *self,char *name,char *font){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            if (!pdf) Py_RETURN_NONE;  // not a PDF
            pdf_obj *fonts = NULL;
            fz_try(gctx) {
                fonts = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root),
                             PDF_NAME(AcroForm), PDF_NAME(DR), PDF_NAME(Font), NULL);
                if (!fonts || !pdf_is_dict(gctx, fonts))
                    THROWMSG(gctx, "PDF has no form fonts yet");
                pdf_obj *k = pdf_new_name(gctx, (const char *) name);
                pdf_obj *v = JM_pdf_obj_from_str(gctx, pdf, font);
                pdf_dict_put(gctx, fonts, k, v);
            }
            fz_catch(gctx) NULL;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document__getOLRootNumber(struct Document *self){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            pdf_obj *root, *olroot, *ind_obj;
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                // get main root
                root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
                // get outline root
                olroot = pdf_dict_get(gctx, root, PDF_NAME(Outlines));
                if (!olroot)
                {
                    olroot = pdf_new_dict(gctx, pdf, 4);
                    pdf_dict_put(gctx, olroot, PDF_NAME(Type), PDF_NAME(Outlines));
                    ind_obj = pdf_add_object(gctx, pdf, olroot);
                    pdf_dict_put(gctx, root, PDF_NAME(Outlines), ind_obj);
                    olroot = pdf_dict_get(gctx, root, PDF_NAME(Outlines));
                    pdf_drop_obj(gctx, ind_obj);
                    pdf->dirty = 1;
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("i", pdf_to_num(gctx, olroot));
        }
SWIGINTERN PyObject *Document_get_new_xref(struct Document *self){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            int xref = 0;
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                xref = pdf_create_object(gctx, pdf);
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdf->dirty = 1;
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *Document_xref_length(struct Document *self){
            int xreflen = 0;
            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                if (pdf) xreflen = pdf_xref_len(gctx, pdf);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("i", xreflen);
        }
SWIGINTERN PyObject *Document_get_xml_metadata(struct Document *self){
            PyObject *rc = NULL;
            fz_buffer *buff = NULL;
            pdf_obj *xml = NULL;
            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                if (pdf) {
                    xml = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root), PDF_NAME(Metadata), NULL);
                }
                if (xml) {
                    buff = pdf_load_stream(gctx, xml);
                    rc = JM_UnicodeFromBuffer(gctx, buff);
                } else {
                    rc = EMPTY_STRING;
                }
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, buff);
                PyErr_Clear();
            }
            fz_catch(gctx) {
                return EMPTY_STRING;
            }
            return rc;
        }
SWIGINTERN PyObject *Document_xref_xml_metadata(struct Document *self){
            int xref = 0;
            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                ASSERT_PDF(pdf);
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
                if (!root) THROWMSG(gctx, "PDF has no root");
                pdf_obj *xml = pdf_dict_get(gctx, root, PDF_NAME(Metadata));
                if (xml) xref = pdf_to_num(gctx, xml);
            }
            fz_catch(gctx) {;}
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *Document_del_xml_metadata(struct Document *self){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
                if (root) pdf_dict_del(gctx, root, PDF_NAME(Metadata));
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdf->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_set_xml_metadata(struct Document *self,char *metadata){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            fz_buffer *res = NULL;
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
                if (!root) THROWMSG(gctx, "PDF has no root");
                res = fz_new_buffer_from_copied_data(gctx, (const unsigned char *) metadata, strlen(metadata));
                pdf_obj *xml = pdf_dict_get(gctx, root, PDF_NAME(Metadata));
                if (xml) {
                    JM_update_stream(gctx, pdf, xml, res, 0);
                } else {
                    xml = pdf_add_stream(gctx, pdf, res, NULL, 0);
                    pdf_dict_put(gctx, xml, PDF_NAME(Type), PDF_NAME(Metadata));
                    pdf_dict_put(gctx, xml, PDF_NAME(Subtype), PDF_NAME(XML));
                    pdf_dict_put_drop(gctx, root, PDF_NAME(Metadata), xml);
                }
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdf->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_xref_object(struct Document *self,int xref,int compressed,int ascii){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            pdf_obj *obj = NULL;
            PyObject *text = NULL;
            fz_buffer *res=NULL;
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1) && xref != -1)
                    THROWMSG(gctx, "bad xref");
                if (xref > 0) {
                    obj = pdf_load_object(gctx, pdf, xref);
                } else {
                    obj = pdf_trailer(gctx, pdf);
                }
                res = JM_object_to_buffer(gctx, pdf_resolve_indirect(gctx, obj), compressed, ascii);
                text = JM_EscapeStrFromBuffer(gctx, res);
            }
            fz_always(gctx) {
                if (xref > 0) {
                    pdf_drop_obj(gctx, obj);
                }
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) return EMPTY_STRING;
            return text;
        }
SWIGINTERN PyObject *Document_xref_stream_raw(struct Document *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            PyObject *r = Py_None;
            pdf_obj *obj = NULL;
            fz_var(obj);
            fz_buffer *res = NULL;
            fz_var(res);
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1) && xref != -1)
                    THROWMSG(gctx, "bad xref");
                if (xref >= 0) {
                    obj = pdf_new_indirect(gctx, pdf, xref, 0);
                } else {
                    obj = pdf_trailer(gctx, pdf);
                }
                if (pdf_is_stream(gctx, obj))
                {
                    res = pdf_load_raw_stream_number(gctx, pdf, xref);
                    r = JM_BinFromBuffer(gctx, res);
                }
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
                if (xref >= 0) {
                    pdf_drop_obj(gctx, obj);
                }
            }
            fz_catch(gctx)
            {
                Py_CLEAR(r);
                return NULL;
            }
            return r;
        }
SWIGINTERN PyObject *Document_xref_stream(struct Document *self,int xref){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            PyObject *r = Py_None;
            pdf_obj *obj = NULL;
            fz_var(obj);
            fz_buffer *res = NULL;
            fz_var(res);
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1) && xref != -1)
                    THROWMSG(gctx, "bad xref");
                if (xref >= 0) {
                    obj = pdf_new_indirect(gctx, pdf, xref, 0);
                } else {
                    obj = pdf_trailer(gctx, pdf);
                }
                if (pdf_is_stream(gctx, obj))
                {
                    res = pdf_load_stream_number(gctx, pdf, xref);
                    r = JM_BinFromBuffer(gctx, res);
                }
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
                if (xref >= 0) {
                    pdf_drop_obj(gctx, obj);
                }
            }
            fz_catch(gctx)
            {
                Py_CLEAR(r);
                return NULL;
            }
            return r;
        }
SWIGINTERN PyObject *Document_update_object(struct Document *self,int xref,char *text,struct Page *page){
            pdf_obj *new_obj;
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG(gctx, "bad xref");
                // create new object with passed-in string
                new_obj = JM_pdf_obj_from_str(gctx, pdf, text);
                pdf_update_object(gctx, pdf, xref, new_obj);
                pdf_drop_obj(gctx, new_obj);
                if (page)
                    JM_refresh_link_table(gctx, pdf_page_from_fz_page(gctx, (fz_page *)page));
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdf->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_update_stream(struct Document *self,int xref,PyObject *stream,int new){
            pdf_obj *obj = NULL;
            fz_var(obj);
            fz_buffer *res = NULL;
            fz_var(res);
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG(gctx, "bad xref");
                // get the object
                obj = pdf_new_indirect(gctx, pdf, xref, 0);
                if (!new && !pdf_is_stream(gctx, obj))
                    THROWMSG(gctx, "no stream object at xref");
                res = JM_BufferFromBytes(gctx, stream);
                if (!res) THROWMSG(gctx, "bad type: 'stream'");
                JM_update_stream(gctx, pdf, obj, res, 1);
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
                pdf_drop_obj(gctx, obj);
            }
            fz_catch(gctx)
                return NULL;
            pdf->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document__make_page_map(struct Document *self){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            if (!pdf) Py_RETURN_NONE;
            fz_try(gctx) {
                pdf_drop_page_tree(gctx, pdf);
                pdf_load_page_tree(gctx, pdf);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("i", pdf->rev_page_count);
        }
SWIGINTERN PyObject *Document_fullcopy_page(struct Document *self,int pno,int to){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            int page_count = pdf_count_pages(gctx, pdf);
            fz_buffer *res = NULL, *nres=NULL;
            pdf_obj *page2 = NULL;
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                if (!INRANGE(pno, 0, page_count - 1) ||
                    !INRANGE(to, -1, page_count - 1))
                    THROWMSG(gctx, "bad page number(s)");

                pdf_obj *page1 = pdf_resolve_indirect(gctx,
                                 pdf_lookup_page_obj(gctx, pdf, pno));

                pdf_obj *page2 = pdf_deep_copy_obj(gctx, page1);
                pdf_obj *old_annots = pdf_dict_get(gctx, page2, PDF_NAME(Annots));

                // copy annotations, but remove Popup and IRT types
                if (old_annots) {
                    int i, n = pdf_array_len(gctx, old_annots);
                    pdf_obj *new_annots = pdf_new_array(gctx, pdf, n);
                    for (i = 0; i < n; i++) {
                        pdf_obj *o = pdf_array_get(gctx, old_annots, i);
                        pdf_obj *subtype = pdf_dict_get(gctx, o, PDF_NAME(Subtype));
                        if (pdf_name_eq(gctx, subtype, PDF_NAME(Popup))) continue;
                        if (pdf_dict_gets(gctx, o, "IRT")) continue;
                        pdf_obj *copy_o = pdf_deep_copy_obj(gctx,
                                            pdf_resolve_indirect(gctx, o));
                        int xref = pdf_create_object(gctx, pdf);
                        pdf_update_object(gctx, pdf, xref, copy_o);
                        pdf_drop_obj(gctx, copy_o);
                        copy_o = pdf_new_indirect(gctx, pdf, xref, 0);
                        pdf_dict_del(gctx, copy_o, PDF_NAME(Popup));
                        pdf_dict_del(gctx, copy_o, PDF_NAME(P));
                        pdf_array_push_drop(gctx, new_annots, copy_o);
                    }
                pdf_dict_put_drop(gctx, page2, PDF_NAME(Annots), new_annots);
                }

                // copy the old contents stream(s)
                res = JM_read_contents(gctx, page1);

                // create new /Contents object for page2
                if (res) {
                    pdf_obj *contents = pdf_add_stream(gctx, pdf,
                               fz_new_buffer_from_copied_data(gctx, "  ", 1), NULL, 0);
                    JM_update_stream(gctx, pdf, contents, res, 1);
                    pdf_dict_put_drop(gctx, page2, PDF_NAME(Contents), contents);
                }

                // now insert target page, making sure it is an indirect object
                int xref = pdf_create_object(gctx, pdf);  // get new xref
                pdf_update_object(gctx, pdf, xref, page2);  // store new page
                pdf_drop_obj(gctx, page2);  // give up this object for now

                page2 = pdf_new_indirect(gctx, pdf, xref, 0);  // reread object
                pdf_insert_page(gctx, pdf, to, page2);  // and store the page
                pdf_drop_obj(gctx, page2);
            }
            fz_always(gctx) {
                pdf_drop_page_tree(gctx, pdf);
                fz_drop_buffer(gctx, res);
                fz_drop_buffer(gctx, nres);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document__move_copy_page(struct Document *self,int pno,int nb,int before,int copy){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            int i1, i2, pos, count, same = 0;
            pdf_obj *parent1 = NULL, *parent2 = NULL, *parent = NULL;
            pdf_obj *kids1, *kids2;
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                // get the two page objects -----------------------------------
                // locate the /Kids arrays and indices in each
                pdf_obj *page1 = pdf_lookup_page_loc(gctx, pdf, pno, &parent1, &i1);
                kids1 = pdf_dict_get(gctx, parent1, PDF_NAME(Kids));

                pdf_obj *page2 = pdf_lookup_page_loc(gctx, pdf, nb, &parent2, &i2);
                kids2 = pdf_dict_get(gctx, parent2, PDF_NAME(Kids));

                if (before)  // calc index of source page in target /Kids
                    pos = i2;
                else
                    pos = i2 + 1;

                // same /Kids array? ------------------------------------------
                same = pdf_objcmp(gctx, kids1, kids2);

                // put source page in target /Kids array ----------------------
                if (!copy && same != 0)  // update parent in page object
                {
                    pdf_dict_put(gctx, page1, PDF_NAME(Parent), parent2);
                }
                pdf_array_insert(gctx, kids2, page1, pos);

                if (same != 0) // different /Kids arrays ----------------------
                {
                    parent = parent2;
                    while (parent)  // increase /Count objects in parents
                    {
                        count = pdf_dict_get_int(gctx, parent, PDF_NAME(Count));
                        pdf_dict_put_int(gctx, parent, PDF_NAME(Count), count + 1);
                        parent = pdf_dict_get(gctx, parent, PDF_NAME(Parent));
                    }
                    if (!copy)  // delete original item
                    {
                        pdf_array_delete(gctx, kids1, i1);
                        parent = parent1;
                        while (parent) // decrease /Count objects in parents
                        {
                            count = pdf_dict_get_int(gctx, parent, PDF_NAME(Count));
                            pdf_dict_put_int(gctx, parent, PDF_NAME(Count), count - 1);
                            parent = pdf_dict_get(gctx, parent, PDF_NAME(Parent));
                        }
                    }
                }
                else {  // same /Kids array
                    if (copy) {  // source page is copied
                        parent = parent2;
                        while (parent) // increase /Count object in parents
                        {
                            count = pdf_dict_get_int(gctx, parent, PDF_NAME(Count));
                            pdf_dict_put_int(gctx, parent, PDF_NAME(Count), count + 1);
                            parent = pdf_dict_get(gctx, parent, PDF_NAME(Parent));
                        }
                    } else {
                        if (i1 < pos)
                            pdf_array_delete(gctx, kids1, i1);
                        else
                            pdf_array_delete(gctx, kids1, i1 + 1);
                    }
                }
                if (pdf->rev_page_map) {  // page map no longer valid: drop it
                    pdf_drop_page_tree(gctx, pdf);
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document__remove_toc_item(struct Document *self,int xref){
            // "remove" bookmark by letting it point to nowhere
            pdf_obj *item = NULL;
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            fz_try(gctx) {
                item = pdf_new_indirect(gctx, pdf, xref, 0);
                pdf_dict_del(gctx, item, PDF_NAME(Dest));
                pdf_dict_del(gctx, item, PDF_NAME(A));
                pdf_dict_put_text_string(gctx, item, PDF_NAME(Title), "<>");
            }
            fz_always(gctx) {
                pdf_drop_obj(gctx, item);
            }
            fz_catch(gctx){
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document__update_toc_item(struct Document *self,int xref,char *action,char *title,int flags,PyObject *collapse,PyObject *color){
            // "update" bookmark by letting it point to nowhere
            pdf_obj *item = NULL;
            pdf_obj *obj = NULL;
            Py_ssize_t i;
            double f;
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            fz_try(gctx) {
                item = pdf_new_indirect(gctx, pdf, xref, 0);
                if (title) {
                    pdf_dict_put_text_string(gctx, item, PDF_NAME(Title), title);
                }
                if (action) {
                    pdf_dict_del(gctx, item, PDF_NAME(Dest));
                    obj = JM_pdf_obj_from_str(gctx, pdf, action);
                    pdf_dict_put_drop(gctx, item, PDF_NAME(A), obj);
                }
                pdf_dict_put_int(gctx, item, PDF_NAME(F), flags);
                if (EXISTS(color)) {
                    pdf_obj *c = pdf_new_array(gctx, pdf, 3);
                    for (i = 0; i < 3; i++) {
                        JM_FLOAT_ITEM(color, i, &f);
                        pdf_array_push_real(gctx, c, f);
                    }
                    pdf_dict_put_drop(gctx, item, PDF_NAME(C), c);
                } else if (color != Py_None) {
                    pdf_dict_del(gctx, item, PDF_NAME(C));
                }
                if (collapse != Py_None) {
                    if (pdf_dict_get(gctx, item, PDF_NAME(Count))) {
                        i = pdf_dict_get_int(gctx, item, PDF_NAME(Count));
                        if ((i < 0 && collapse == Py_False) || (i > 0 && collapse == Py_True)) {
                            i = i * (-1);
                            pdf_dict_put_int(gctx, item, PDF_NAME(Count), i);
                        }
                    }
                }
            }
            fz_always(gctx) {
                pdf_drop_obj(gctx, item);
            }
            fz_catch(gctx){
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document__get_page_labels(struct Document *self){
            pdf_obj *obj, *nums, *kids;
            PyObject *rc = NULL;
            fz_buffer *res = NULL;
            int i, n;
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);

            fz_try(gctx) {
                ASSERT_PDF(pdf);
                rc = PyList_New(0);
                pdf_obj *pagelabels = pdf_new_name(gctx, "PageLabels");
                obj = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                   PDF_NAME(Root), pagelabels, NULL);
                if (!obj) {
                    goto finished;
                }
                // simple case: direct /Nums object
                nums = pdf_resolve_indirect(gctx,
                       pdf_dict_get(gctx, obj, PDF_NAME(Nums)));
                if (nums) {
                    JM_get_page_labels(gctx, rc, nums);
                    goto finished;
                }
                // case: /Kids/Nums
                nums = pdf_resolve_indirect(gctx,
                           pdf_dict_getl(gctx, obj, PDF_NAME(Kids), PDF_NAME(Nums), NULL)
                );
                if (nums) {
                    JM_get_page_labels(gctx, rc, nums);
                    goto finished;
                }
                // case: /Kids is an array of multiple /Nums
                kids = pdf_resolve_indirect(gctx,
                       pdf_dict_get(gctx, obj, PDF_NAME(Kids)));
                if (!kids || !pdf_is_array(gctx, kids)) {
                    goto finished;
                }

                n = pdf_array_len(gctx, kids);
                for (i = 0; i < n; i++) {
                    nums = pdf_resolve_indirect(gctx,
                           pdf_dict_get(gctx,
                           pdf_array_get(gctx, kids, i),
                           PDF_NAME(Nums)));
                    JM_get_page_labels(gctx, rc, nums);
                }
                finished:;
            }
            fz_always(gctx) {
                PyErr_Clear();
            }
            fz_catch(gctx){
                Py_CLEAR(rc);
                return NULL;
            }
            return rc;
        }
SWIGINTERN PyObject *Document__set_page_labels(struct Document *self,char *labels){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                pdf_obj *pagelabels = pdf_new_name(gctx, "PageLabels");
                pdf_obj *root = pdf_dict_get(gctx, pdf_trailer(gctx, pdf), PDF_NAME(Root));
                pdf_dict_del(gctx, root, pagelabels);
                pdf_dict_putl_drop(gctx, root, pdf_new_array(gctx, pdf, 0), pagelabels, PDF_NAME(Nums), NULL);
            }
            fz_always(gctx) {
                PyErr_Clear();
            }
            fz_catch(gctx){
                return NULL;
            }
            pdf->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_get_layers(struct Document *self){
            PyObject *rc = NULL;
            pdf_layer_config info = {NULL, NULL};
            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                ASSERT_PDF(pdf);
                int i, n = pdf_count_layer_configs(gctx, pdf);
                if (n == 1) {
                    pdf_obj *obj = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                   PDF_NAME(Root), PDF_NAME(OCProperties), PDF_NAME(Configs), NULL);
                    if (!pdf_is_array(gctx, obj)) n = 0;
                }
                rc = PyTuple_New(n);
                for (i = 0; i < n; i++) {
                    pdf_layer_config_info(gctx, pdf, i, &info);
                    PyObject *item = Py_BuildValue("{s:i,s:s,s:s}",
                        "number", i, "name", info.name, "creator", info.creator);
                    PyTuple_SET_ITEM(rc, i, item);
                    info.name = NULL;
                    info.creator = NULL;
                }
            }
            fz_catch(gctx) {
                Py_CLEAR(rc);
                return NULL;
            }
            return rc;
        }
SWIGINTERN PyObject *Document_switch_layer(struct Document *self,int config,int as_default){
            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                ASSERT_PDF(pdf);
                pdf_obj *cfgs = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                   PDF_NAME(Root), PDF_NAME(OCProperties), PDF_NAME(Configs), NULL);
                if (!pdf_is_array(gctx, cfgs) || !pdf_array_len(gctx, cfgs)) {
                    if (config < 1) goto finished;
                    THROWMSG(gctx, "bad layer number");
                }
                if (config < 0) goto finished;
                pdf_select_layer_config(gctx, pdf, config);
                if (as_default) {
                    pdf_set_layer_config_as_default(gctx, pdf);
                    pdf_read_ocg(gctx, pdf);
                }
                finished:;
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_get_layer(struct Document *self,int config){
            PyObject *rc;
            pdf_obj *obj = NULL;
            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                ASSERT_PDF(pdf);
                pdf_obj *ocp = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                   PDF_NAME(Root), PDF_NAME(OCProperties), NULL);
                if (!ocp) {
                    rc = Py_BuildValue("s", NULL);
                    goto finished;
                }
                if (config == -1) {
                    obj = pdf_dict_get(gctx, ocp, PDF_NAME(D));
                } else {
                    obj = pdf_array_get(gctx, pdf_dict_get(gctx, ocp, PDF_NAME(Configs)), config);
                }
                if (!obj) THROWMSG(gctx, "bad config number");
                rc = JM_get_ocg_arrays(gctx, obj);
                finished:;
            }
            fz_catch(gctx) {
                Py_CLEAR(rc);
                PyErr_Clear();
                return NULL;
            }
            return rc;
        }
SWIGINTERN PyObject *Document_set_layer(struct Document *self,int config,char const *basestate,PyObject *on,PyObject *off,PyObject *rbgroups){
            pdf_obj *obj = NULL;
            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                ASSERT_PDF(pdf);
                pdf_obj *ocp = pdf_dict_getl(gctx, pdf_trailer(gctx, pdf),
                                   PDF_NAME(Root), PDF_NAME(OCProperties), NULL);
                if (!ocp) {
                    goto finished;
                }
                if (config == -1) {
                    obj = pdf_dict_get(gctx, ocp, PDF_NAME(D));
                } else {
                    obj = pdf_array_get(gctx, pdf_dict_get(gctx, ocp, PDF_NAME(Configs)), config);
                }
                if (!obj) THROWMSG(gctx, "bad config number");
                JM_set_ocg_arrays(gctx, obj, basestate, on, off, rbgroups);
                pdf_read_ocg(gctx, pdf);
                finished:;
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_add_layer(struct Document *self,char *name,char *creator,PyObject *on){
            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                ASSERT_PDF(pdf);
                JM_add_layer_config(gctx, pdf, name, creator, on);
                pdf_read_ocg(gctx, pdf);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_layer_ui_configs(struct Document *self){
            typedef struct
            {
                const char *text;
                int depth;
                pdf_layer_config_ui_type type;
                int selected;
                int locked;
            } pdf_layer_config_ui;
            PyObject *rc = NULL;

            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                ASSERT_PDF(pdf);
                pdf_layer_config_ui info;
                int i, n = pdf_count_layer_config_ui(gctx, pdf);
                rc = PyTuple_New(n);
                char *type = NULL;
                for (i = 0; i < n; i++) {
                    pdf_layer_config_ui_info(gctx, pdf, i, (void *) &info);
                    switch (info.type)
                    {
                        case (1): type = "checkbox"; break;
                        case (2): type = "radiobox"; break;
                        default: type = "label"; break;
                    }
                    PyObject *item = Py_BuildValue("{s:i,s:s,s:i,s:s,s:O,s:O}",
                        "number", i,
                        "text", info.text,
                        "depth", info.depth,
                        "type", type,
                        "on", JM_BOOL(info.selected),
                        "locked", JM_BOOL(info.locked));
                    PyTuple_SET_ITEM(rc, i, item);
                }
            }
            fz_catch(gctx) {
                Py_CLEAR(rc);
                return NULL;
            }
            return rc;
        }
SWIGINTERN PyObject *Document_set_layer_ui_config(struct Document *self,int number,int action){
            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                ASSERT_PDF(pdf);
                switch (action)
                {
                    case (1):
                        pdf_toggle_layer_config_ui(gctx, pdf, number);
                        break;
                    case (2):
                        pdf_deselect_layer_config_ui(gctx, pdf, number);
                        break;
                    default:
                        pdf_select_layer_config_ui(gctx, pdf, number);
                        break;
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Document_get_ocgs(struct Document *self){
            PyObject *rc = NULL;
            pdf_obj *ci = pdf_new_name(gctx, "CreatorInfo");
            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                ASSERT_PDF(pdf);
                pdf_obj *ocgs = pdf_dict_getl(gctx,
                                pdf_dict_get(gctx,
                                pdf_trailer(gctx, pdf), PDF_NAME(Root)),
                                PDF_NAME(OCProperties), PDF_NAME(OCGs), NULL);
                rc = PyDict_New();
                if (!pdf_is_array(gctx, ocgs)) goto fertig;
                int i, n = pdf_array_len(gctx, ocgs);
                for (i = 0; i < n; i++) {
                    pdf_obj *ocg = pdf_array_get(gctx, ocgs, i);
                    int xref = pdf_to_num(gctx, ocg);
                    const char *name = pdf_to_text_string(gctx, pdf_dict_get(gctx, ocg, PDF_NAME(Name)));
                    pdf_obj *obj = pdf_dict_getl(gctx, ocg, PDF_NAME(Usage), ci, PDF_NAME(Subtype), NULL);
                    const char *usage = NULL;
                    if (obj) usage = pdf_to_name(gctx, obj);
                    PyObject *intents = PyList_New(0);
                    pdf_obj *intent = pdf_dict_get(gctx, ocg, PDF_NAME(Intent));
                    if (intent) {
                        if (pdf_is_name(gctx, intent)) {
                            LIST_APPEND_DROP(intents, Py_BuildValue("s", pdf_to_name(gctx, intent)));
                        } else if (pdf_is_array(gctx, intent)) {
                            int j, m = pdf_array_len(gctx, intent);
                            for (j = 0; j < m; j++) {
                                pdf_obj *o = pdf_array_get(gctx, intent, j);
                                if (pdf_is_name(gctx, o))
                                    LIST_APPEND_DROP(intents, Py_BuildValue("s", pdf_to_name(gctx, o)));
                            }
                        }
                    }
                    pdf_ocg_descriptor *desc = pdf->ocg;
                    int hidden = pdf_is_hidden_ocg(gctx, desc, NULL, usage, ocg);
                    PyObject *item = Py_BuildValue("{s:s,s:O,s:O,s:s}",
                            "name", name,
                            "intent", intents,
                            "on", JM_BOOL(!hidden),
                            "usage", usage);
                    Py_DECREF(intents);
                    PyObject *temp = Py_BuildValue("i", xref);
                    DICT_SETITEM_DROP(rc, temp, item);
                    Py_DECREF(temp);
                }
                fertig:;
            }
            fz_always(gctx) {
                pdf_drop_obj(gctx, ci);
            }
            fz_catch(gctx) {
                Py_CLEAR(rc);
                return NULL;
            }
            return rc;
        }
SWIGINTERN PyObject *Document_add_ocg(struct Document *self,char *name,int config,int on,PyObject *intent,char const *usage){
            int xref = 0;
            pdf_obj *obj = NULL, *cfg = NULL;
            pdf_obj *indocg = NULL;
            fz_try(gctx) {
                pdf_document *pdf = pdf_specifics(gctx, (fz_document *) self);
                ASSERT_PDF(pdf);

                // ------------------------------
                // make the OCG
                // ------------------------------
                pdf_obj *ocg = pdf_add_new_dict(gctx, pdf, 3);
                pdf_dict_put(gctx, ocg, PDF_NAME(Type), PDF_NAME(OCG));
                pdf_dict_put_text_string(gctx, ocg, PDF_NAME(Name), name);
                pdf_obj *intents = pdf_dict_put_array(gctx, ocg, PDF_NAME(Intent), 2);
                if (!EXISTS(intent)) {
                    pdf_array_push(gctx, intents, PDF_NAME(View));
                } else if (!PyUnicode_Check(intent)) {
                    int i, n = PySequence_Size(intent);
                    for (i = 0; i < n; i++) {
                        PyObject *item = PySequence_ITEM(intent, i);
                        char *c = JM_StrAsChar(item);
                        if (c) {
                            pdf_array_push(gctx, intents, pdf_new_name(gctx, c));
                        }
                        Py_DECREF(item);
                    }
                } else {
                    char *c = JM_StrAsChar(intent);
                    if (c) {
                        pdf_array_push(gctx, intents, pdf_new_name(gctx, c));
                    }
                }
                pdf_obj *use_for = pdf_dict_put_dict(gctx, ocg, PDF_NAME(Usage), 3);
                pdf_obj *ci_name = pdf_new_name(gctx, "CreatorInfo");
                pdf_obj *cre_info = pdf_dict_put_dict(gctx, use_for, ci_name, 2);
                pdf_dict_put_text_string(gctx, cre_info, PDF_NAME(Creator), "PyMuPDF");
                if (usage) {
                    pdf_dict_put_name(gctx, cre_info, PDF_NAME(Subtype), usage);
                } else {
                    pdf_dict_put_name(gctx, cre_info, PDF_NAME(Subtype), "Artwork");
                }
                indocg = pdf_add_object(gctx, pdf, ocg);

                // ------------------------------
                // Insert OCG in the right config
                // ------------------------------
                pdf_obj *ocp = JM_ensure_ocproperties(gctx, pdf);
                obj = pdf_dict_get(gctx, ocp, PDF_NAME(OCGs));
                pdf_array_push(gctx, obj, indocg);

                if (config > -1) {
                    obj = pdf_dict_get(gctx, ocp, PDF_NAME(Configs));
                    if (!pdf_is_array(gctx, obj)) {
                        THROWMSG(gctx, "bad config number");
                    }
                    cfg = pdf_array_get(gctx, obj, config);
                    if (!cfg) {
                        THROWMSG(gctx, "bad config number");
                    }
                } else {
                    cfg = pdf_dict_get(gctx, ocp, PDF_NAME(D));
                }

                obj = pdf_dict_get(gctx, cfg, PDF_NAME(Order));
                if (!obj) {
                    obj = pdf_dict_put_array(gctx, cfg, PDF_NAME(Order), 1);
                }
                pdf_array_push(gctx, obj, indocg);
                if (on) {
                    obj = pdf_dict_get(gctx, cfg, PDF_NAME(ON));
                    if (!obj) {
                        obj = pdf_dict_put_array(gctx, cfg, PDF_NAME(ON), 1);
                    }
                } else {
                    obj = pdf_dict_get(gctx, cfg, PDF_NAME(OFF));
                    if (!obj) {
                        obj = pdf_dict_put_array(gctx, cfg, PDF_NAME(OFF), 1);
                    }
                }
                pdf_array_push(gctx, obj, indocg);

                // let MuPDF take note: re-read OCProperties
                pdf_read_ocg(gctx, pdf);

                xref = pdf_to_num(gctx, indocg);
            }
            fz_always(gctx) {
                pdf_drop_obj(gctx, indocg);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("i", xref);
        }
SWIGINTERN void delete_Page(struct Page *self){
            DEBUGMSG1("Page");
            fz_page *this_page = (fz_page *) self;
            fz_drop_page(gctx, this_page);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *Page_bound(struct Page *self){
            fz_rect rect = fz_bound_page(gctx, (fz_page *) self);
            return JM_py_from_rect(rect);
        }
SWIGINTERN PyObject *Page_get_image_bbox(struct Page *self,PyObject *name,int transform){
            pdf_page *pdf_page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            PyObject *rc =NULL;
            fz_try(gctx) {
                rc = JM_image_reporter(gctx, pdf_page);
            }
            fz_catch(gctx) {
                Py_RETURN_NONE;
            }
            return rc;
        }
SWIGINTERN PyObject *Page_run(struct Page *self,struct DeviceWrapper *dw,PyObject *m){
            fz_try(gctx) {
                fz_run_page(gctx, (fz_page *) self, dw->device, JM_matrix_from_py(m), NULL);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN struct TextPage *Page__get_text_page(struct Page *self,PyObject *clip,int flags){
            fz_stext_page *textpage=NULL;
            fz_try(gctx) {
                fz_rect rect = JM_rect_from_py(clip);
                textpage = JM_new_stext_page_from_page(gctx, (fz_page *) self, rect, flags);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct TextPage *) textpage;
        }
SWIGINTERN PyObject *Page_language(struct Page *self){
            pdf_page *pdfpage = pdf_page_from_fz_page(gctx, (fz_page *) self);
            if (!pdfpage) Py_RETURN_NONE;
            pdf_obj *lang = pdf_dict_get_inheritable(gctx, pdfpage->obj, PDF_NAME(Lang));
            if (!lang) Py_RETURN_NONE;
            return Py_BuildValue("s", pdf_to_str_buf(gctx, lang));
        }
SWIGINTERN PyObject *Page_set_language(struct Page *self,char *language){
            pdf_page *pdfpage = pdf_page_from_fz_page(gctx, (fz_page *) self);
            fz_try(gctx) {
                ASSERT_PDF(pdfpage);
                fz_text_language lang;
                char buf[8];
                if (!language) {
                    pdf_dict_del(gctx, pdfpage->obj, PDF_NAME(Lang));
                } else {
                    lang = fz_text_language_from_string(language);
                    pdf_dict_put_text_string(gctx, pdfpage->obj,
                        PDF_NAME(Lang),
                        fz_string_from_text_language(buf, lang));
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_TRUE;
        }
SWIGINTERN PyObject *Page_get_svg_image(struct Page *self,PyObject *matrix,int text_as_path){
            fz_rect mediabox = fz_bound_page(gctx, (fz_page *) self);
            fz_device *dev = NULL;
            fz_buffer *res = NULL;
            PyObject *text = NULL;
            fz_matrix ctm = JM_matrix_from_py(matrix);
            fz_output *out = NULL;
            fz_separations *seps = NULL;
            fz_var(out);
            fz_var(dev);
            fz_var(res);
            fz_rect tbounds = mediabox;
            int text_option = (text_as_path == 1) ? FZ_SVG_TEXT_AS_PATH : FZ_SVG_TEXT_AS_TEXT;
            tbounds = fz_transform_rect(tbounds, ctm);

            fz_try(gctx) {
                res = fz_new_buffer(gctx, 1024);
                out = fz_new_output_with_buffer(gctx, res);
                dev = fz_new_svg_device(gctx, out,
                            tbounds.x1-tbounds.x0,  // width
                            tbounds.y1-tbounds.y0,  // height
                            text_option, 1);
                fz_run_page(gctx, (fz_page *) self, dev, ctm, NULL);
                fz_close_device(gctx, dev);
                text = JM_EscapeStrFromBuffer(gctx, res);
            }
            fz_always(gctx) {
                fz_drop_device(gctx, dev);
                fz_drop_output(gctx, out);
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return text;
        }
SWIGINTERN PyObject *Page__set_opacity(struct Page *self,char *gstate,float CA,float ca){
            if (!gstate) Py_RETURN_NONE;
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            fz_try(gctx) {
                ASSERT_PDF(page);
                pdf_obj *resources = pdf_dict_get(gctx, page->obj, PDF_NAME(Resources));
                if (!resources) {
                    resources = pdf_dict_put_dict(gctx, page->obj, PDF_NAME(Resources), 2);
                }
                pdf_obj *extg = pdf_dict_get(gctx, resources, PDF_NAME(ExtGState));
                if (!extg) {
                    extg = pdf_dict_put_dict(gctx, resources, PDF_NAME(ExtGState), 2);
                }
                int i, n = pdf_dict_len(gctx, extg);
                for (i = 0; i < n; i++) {
                    pdf_obj *o1 = pdf_dict_get_key(gctx, extg, i);
                    char *name = (char *) pdf_to_name(gctx, o1);
                    if (strcmp(name, gstate) == 0) goto finished;
                }
                pdf_obj *opa = pdf_new_dict(gctx, page->doc, 3);
                pdf_dict_put_real(gctx, opa, PDF_NAME(CA), (double) CA);
                pdf_dict_put_real(gctx, opa, PDF_NAME(ca), (double) ca);
                pdf_dict_puts_drop(gctx, extg, gstate, opa);
                finished:;
            }
            fz_always(gctx) {
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("s", gstate);
        }
SWIGINTERN struct Annot *Page__add_caret_annot(struct Page *self,PyObject *point){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_annot *annot = NULL;
            fz_try(gctx) {
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_CARET);
                if (point)
                {
                    fz_point p = JM_point_from_py(point);
                    fz_rect r = pdf_annot_rect(gctx, annot);
                    r = fz_make_rect(p.x, p.y, p.x + r.x1 - r.x0, p.y + r.y1 - r.y0);
                    pdf_set_annot_rect(gctx, annot, r);
                }
                JM_add_annot_id(gctx, annot, "A");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) {
                return NULL;
            }
            annot = pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct Annot *Page__add_redact_annot(struct Page *self,PyObject *quad,char *text,char const *da_str,int align,PyObject *fill,PyObject *text_color){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_annot *annot = NULL;
            float fcol[4] = { 1, 1, 1, 0};
            int nfcol = 0, i;
            fz_try(gctx) {
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_REDACT);
                fz_quad q = JM_quad_from_py(quad);
                fz_rect r = fz_rect_from_quad(q);

                // TODO calculate de-rotated rect
                pdf_set_annot_rect(gctx, annot, r);
                if (EXISTS(fill)) {
                    JM_color_FromSequence(fill, &nfcol, fcol);
                    pdf_obj *arr = pdf_new_array(gctx, page->doc, nfcol);
                    for (i = 0; i < nfcol; i++)
                    {
                        pdf_array_push_real(gctx, arr, fcol[i]);
                    }
                    pdf_dict_put_drop(gctx, annot->obj, PDF_NAME(IC), arr);
                }
                if (text) {
                    pdf_dict_puts_drop(gctx, annot->obj, "OverlayText",
                                       pdf_new_text_string(gctx, text));
                    pdf_dict_put_text_string(gctx,annot->obj, PDF_NAME(DA), da_str);
                    pdf_dict_put_int(gctx, annot->obj, PDF_NAME(Q), (int64_t) align);
                }
                JM_add_annot_id(gctx, annot, "A");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) {
                return NULL;
            }
            annot = pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct Annot *Page__add_line_annot(struct Page *self,PyObject *p1,PyObject *p2){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_annot *annot = NULL;
            fz_try(gctx) {
                ASSERT_PDF(page);
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_LINE);
                fz_point a = JM_point_from_py(p1);
                fz_point b = JM_point_from_py(p2);
                pdf_set_annot_line(gctx, annot, a, b);
                JM_add_annot_id(gctx, annot, "A");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) {
                return NULL;
            }
            annot = pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct Annot *Page__add_text_annot(struct Page *self,PyObject *point,char *text,char *icon){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_annot *annot = NULL;
            fz_rect r;
            fz_point p = JM_point_from_py(point);
            fz_var(annot);
            fz_try(gctx) {
                ASSERT_PDF(page);
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_TEXT);
                r = pdf_annot_rect(gctx, annot);
                r = fz_make_rect(p.x, p.y, p.x + r.x1 - r.x0, p.y + r.y1 - r.y0);
                pdf_set_annot_rect(gctx, annot, r);
                int flags = PDF_ANNOT_IS_PRINT;
                pdf_set_annot_flags(gctx, annot, flags);
                pdf_set_annot_contents(gctx, annot, text);
                if (icon) {
                    pdf_set_annot_icon_name(gctx, annot, icon);
                }
                JM_add_annot_id(gctx, annot, "A");
                pdf_update_annot(gctx, annot);
                pdf_set_annot_rect(gctx, annot, r);
                pdf_set_annot_flags(gctx, annot, flags);
            }
            fz_catch(gctx) {
                return NULL;
            }
            annot = pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct Annot *Page__add_ink_annot(struct Page *self,PyObject *list){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_annot *annot = NULL;
            PyObject *p = NULL, *sublist = NULL;
            pdf_obj *inklist = NULL, *stroke = NULL;
            fz_matrix ctm, inv_ctm;
            fz_point point;
            fz_var(annot);
            fz_try(gctx) {
                ASSERT_PDF(page);
                if (!PySequence_Check(list)) THROWMSG(gctx, "arg must be a sequence");
                pdf_page_transform(gctx, page, NULL, &ctm);
                inv_ctm = fz_invert_matrix(ctm);
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_INK);
                Py_ssize_t i, j, n0 = PySequence_Size(list), n1;
                inklist = pdf_new_array(gctx, annot->page->doc, n0);

                for (j = 0; j < n0; j++) {
                    sublist = PySequence_ITEM(list, j);
                    n1 = PySequence_Size(sublist);
                    stroke = pdf_new_array(gctx, annot->page->doc, 2 * n1);

                    for (i = 0; i < n1; i++) {
                        p = PySequence_ITEM(sublist, i);
                        if (!PySequence_Check(p) || PySequence_Size(p) != 2)
                            THROWMSG(gctx, "3rd level entries must be pairs of floats");
                        point = fz_transform_point(JM_point_from_py(p), inv_ctm);
                        Py_CLEAR(p);
                        pdf_array_push_real(gctx, stroke, point.x);
                        pdf_array_push_real(gctx, stroke, point.y);
                    }

                    pdf_array_push_drop(gctx, inklist, stroke);
                    stroke = NULL;
                    Py_CLEAR(sublist);
                }

                pdf_dict_put_drop(gctx, annot->obj, PDF_NAME(InkList), inklist);
                inklist = NULL;
                pdf_dirty_annot(gctx, annot);
                JM_add_annot_id(gctx, annot, "A");
                pdf_update_annot(gctx, annot);
            }

            fz_catch(gctx) {
                Py_CLEAR(p);
                Py_CLEAR(sublist);
                return NULL;
            }
            annot = pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct Annot *Page__add_stamp_annot(struct Page *self,PyObject *rect,int stamp){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_annot *annot = NULL;
            pdf_obj *stamp_id[] = {PDF_NAME(Approved), PDF_NAME(AsIs),
                                   PDF_NAME(Confidential), PDF_NAME(Departmental),
                                   PDF_NAME(Experimental), PDF_NAME(Expired),
                                   PDF_NAME(Final), PDF_NAME(ForComment),
                                   PDF_NAME(ForPublicRelease), PDF_NAME(NotApproved),
                                   PDF_NAME(NotForPublicRelease), PDF_NAME(Sold),
                                   PDF_NAME(TopSecret), PDF_NAME(Draft)};
            int n = nelem(stamp_id);
            pdf_obj *name = stamp_id[0];
            fz_try(gctx) {
                ASSERT_PDF(page);
                fz_rect r = JM_rect_from_py(rect);
                if (fz_is_infinite_rect(r) || fz_is_empty_rect(r))
                    THROWMSG(gctx, "rect must be finite and not empty");
                if (INRANGE(stamp, 0, n-1))
                    name = stamp_id[stamp];
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_STAMP);
                pdf_set_annot_rect(gctx, annot, r);
                pdf_dict_put(gctx, annot->obj, PDF_NAME(Name), name);
                pdf_set_annot_contents(gctx, annot,
                        pdf_dict_get_name(gctx, annot->obj, PDF_NAME(Name)));
                JM_add_annot_id(gctx, annot, "A");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) {
                return NULL;
            }
            annot = pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct Annot *Page__add_file_annot(struct Page *self,PyObject *point,PyObject *buffer,char *filename,char *ufilename,char *desc,char *icon){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_annot *annot = NULL;
            char *uf = ufilename, *d = desc;
            if (!ufilename) uf = filename;
            if (!desc) d = filename;
            fz_buffer *filebuf = NULL;
            fz_rect r;
            fz_point p = JM_point_from_py(point);
            fz_var(annot);
            fz_try(gctx) {
                ASSERT_PDF(page);
                filebuf = JM_BufferFromBytes(gctx, buffer);
                if (!filebuf) THROWMSG(gctx, "bad type: 'buffer'");
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_FILE_ATTACHMENT);
                r = pdf_annot_rect(gctx, annot);
                r = fz_make_rect(p.x, p.y, p.x + r.x1 - r.x0, p.y + r.y1 - r.y0);
                pdf_set_annot_rect(gctx, annot, r);
                int flags = PDF_ANNOT_IS_PRINT;
                pdf_set_annot_flags(gctx, annot, flags);

                if (icon)
                    pdf_set_annot_icon_name(gctx, annot, icon);

                pdf_obj *val = JM_embed_file(gctx, page->doc, filebuf,
                                    filename, uf, d, 1);
                pdf_dict_put(gctx, annot->obj, PDF_NAME(FS), val);
                pdf_dict_put_text_string(gctx, annot->obj, PDF_NAME(Contents), filename);
                JM_add_annot_id(gctx, annot, "A");
                pdf_update_annot(gctx, annot);
                pdf_set_annot_rect(gctx, annot, r);
                pdf_set_annot_flags(gctx, annot, flags);
            }
            fz_catch(gctx) {
                return NULL;
            }
            annot = pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct Annot *Page__add_text_marker(struct Page *self,PyObject *quads,int annot_type){
            pdf_page *pdfpage = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_annot *annot = NULL;
            PyObject *item = NULL;
            int rotation = JM_page_rotation(gctx, pdfpage);
            fz_quad q;
            fz_var(annot);
            fz_var(item);
            fz_try(gctx) {
                if (rotation != 0) {
                    pdf_dict_put_int(gctx, pdfpage->obj, PDF_NAME(Rotate), 0);
                }
                annot = pdf_create_annot(gctx, pdfpage, annot_type);
                Py_ssize_t i, len = PySequence_Size(quads);
                for (i = 0; i < len; i++) {
                    item = PySequence_ITEM(quads, i);
                    q = JM_quad_from_py(item);
                    Py_DECREF(item);
                    pdf_add_annot_quad_point(gctx, annot, q);
                }
                JM_add_annot_id(gctx, annot, "A");
                pdf_update_annot(gctx, annot);
            }
            fz_always(gctx) {
                if (rotation != 0) {
                    pdf_dict_put_int(gctx, pdfpage->obj, PDF_NAME(Rotate), rotation);
                }
            }
            fz_catch(gctx) {
                pdf_drop_annot(gctx, annot);
                return NULL;
            }
            annot = pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct Annot *Page__add_square_or_circle(struct Page *self,PyObject *rect,int annot_type){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_annot *annot = NULL;
            fz_try(gctx) {
                fz_rect r = JM_rect_from_py(rect);
                if (fz_is_infinite_rect(r) || fz_is_empty_rect(r))
                    THROWMSG(gctx, "rect must be finite and not empty");
                annot = pdf_create_annot(gctx, page, annot_type);
                pdf_set_annot_rect(gctx, annot, r);
                JM_add_annot_id(gctx, annot, "A");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) {
                return NULL;
            }
            annot = pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct Annot *Page__add_multiline(struct Page *self,PyObject *points,int annot_type){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_annot *annot = NULL;
            fz_try(gctx) {
                Py_ssize_t i, n = PySequence_Size(points);
                if (n < 2) THROWMSG(gctx, "bad list of points");
                annot = pdf_create_annot(gctx, page, annot_type);
                for (i = 0; i < n; i++) {
                    PyObject *p = PySequence_ITEM(points, i);
                    if (PySequence_Size(p) != 2) {
                        Py_DECREF(p);
                        THROWMSG(gctx, "bad list of points");
                    }
                    fz_point point = JM_point_from_py(p);
                    Py_DECREF(p);
                    pdf_add_annot_vertex(gctx, annot, point);
                }

                JM_add_annot_id(gctx, annot, "A");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) {
                return NULL;
            }
            annot = pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct Annot *Page__add_freetext_annot(struct Page *self,PyObject *rect,char *text,float fontsize,char *fontname,PyObject *text_color,PyObject *fill_color,int align,int rotate){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            float fcol[4] = {1, 1, 1, 1}; // fill color: white
            int nfcol = 0;
            JM_color_FromSequence(fill_color, &nfcol, fcol);
            float tcol[4] = {0, 0, 0, 0}; // std. text color: black
            int ntcol = 0;
            JM_color_FromSequence(text_color, &ntcol, tcol);
            fz_rect r = JM_rect_from_py(rect);
            pdf_annot *annot = NULL;
            fz_try(gctx) {
                if (fz_is_infinite_rect(r) || fz_is_empty_rect(r))
                    THROWMSG(gctx, "rect must be finite and not empty");
                annot = pdf_create_annot(gctx, page, PDF_ANNOT_FREE_TEXT);
                pdf_set_annot_contents(gctx, annot, text);
                pdf_set_annot_rect(gctx, annot, r);
                pdf_dict_put_int(gctx, annot->obj, PDF_NAME(Rotate), rotate);
                pdf_dict_put_int(gctx, annot->obj, PDF_NAME(Q), align);

                if (fill_color) {
                    pdf_set_annot_color(gctx, annot, nfcol, fcol);
                }

                // insert the default appearance string
                JM_make_annot_DA(gctx, annot, ntcol, tcol, fontname, fontsize);
                JM_add_annot_id(gctx, annot, "A");
                pdf_update_annot(gctx, annot);
            }
            fz_catch(gctx) {
                return NULL;
            }
            annot = pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct Annot *Page__load_annot(struct Page *self,char *name,int xref){
            pdf_annot *annot = NULL;
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            fz_try(gctx) {
                ASSERT_PDF(page);
                if (xref == 0)
                    annot = JM_get_annot_by_name(gctx, page, name);
                else
                    annot = JM_get_annot_by_xref(gctx, page, xref);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Annot *) annot;
        }
SWIGINTERN PyObject *Page__get_resource_properties(struct Page *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            PyObject *rc;
            fz_try(gctx) {
                ASSERT_PDF(page);
                rc = JM_get_resource_properties(gctx, page->obj);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return rc;
        }
SWIGINTERN PyObject *Page__set_resource_property(struct Page *self,char *name,int xref){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            fz_try(gctx) {
                ASSERT_PDF(page);
                JM_set_resource_property(gctx, page->obj, name, xref);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Page_annot_names(struct Page *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            if (!page) Py_RETURN_NONE;
            return JM_get_annot_id_list(gctx, page);
        }
SWIGINTERN PyObject *Page_annot_xrefs(struct Page *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            if (!page) Py_RETURN_NONE;
            return JM_get_annot_xref_list(gctx, page->obj);
        }
SWIGINTERN struct Annot *Page__addWidget(struct Page *self,int field_type,char *field_name){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_document *pdf = page->doc;
            pdf_annot *annot = NULL;
            fz_var(annot);
            fz_try(gctx) {
                annot = JM_create_widget(gctx, pdf, page, field_type, field_name);
                if (!annot) THROWMSG(gctx, "could not create widget");
                JM_add_annot_id(gctx, annot, "W");
            }
            fz_catch(gctx) {
                return NULL;
            }
            annot = pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct DisplayList *Page_get_displaylist(struct Page *self,int annots){
            fz_display_list *dl = NULL;
            fz_try(gctx) {
                if (annots) {
                    dl = fz_new_display_list_from_page(gctx, (fz_page *) self);
                } else {
                    dl = fz_new_display_list_from_page_contents(gctx, (fz_page *) self);
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct DisplayList *) dl;
        }
SWIGINTERN PyObject *Page__getDrawings(struct Page *self){
            fz_page *page = (fz_page *) self;
            fz_device *dev = NULL;
            PyObject *rc = NULL;
            fz_try(gctx) {
                rc = PyList_New(0);
                dev = JM_new_tracedraw_device(gctx, rc);
                fz_run_page(gctx, page, dev, fz_identity, NULL);
                fz_close_device(gctx, dev);
            }
            fz_always(gctx) {
                fz_drop_device(gctx, dev);
            }
            fz_catch(gctx) {
                Py_CLEAR(rc);
                return NULL;
            }
            return rc;
        }
SWIGINTERN PyObject *Page__apply_redactions(struct Page *self,int images){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            int success = 0;
            pdf_redact_options opts;
            opts.black_boxes = 0;  // no black boxes
            opts.image_method = images;  // how to treat images
            fz_try(gctx) {
                ASSERT_PDF(page);
                success = pdf_redact_page(gctx, page->doc, page, &opts);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return JM_BOOL(success);
        }
SWIGINTERN struct Pixmap *Page__makePixmap(struct Page *self,struct Document *doc,PyObject *ctm,struct Colorspace *cs,int alpha,int annots,PyObject *clip){
            fz_pixmap *pix = NULL;
            fz_try(gctx) {
                pix = JM_pixmap_from_page(gctx, (fz_document *) doc, (fz_page *) self, ctm, (fz_colorspace *) cs, alpha, annots, clip);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Pixmap *) pix;
        }
SWIGINTERN PyObject *Page_set_mediabox(struct Page *self,PyObject *rect){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            fz_try(gctx) {
                ASSERT_PDF(page);
                fz_rect mediabox = JM_rect_from_py(rect);
                if (fz_is_empty_rect(mediabox) ||
                    fz_is_infinite_rect(mediabox)) {
                    THROWMSG(gctx, "rect must be finite and not empty");
                }
                if (mediabox.x0 != 0 || mediabox.y0 != 0) {
                    THROWMSG(gctx, "mediabox must start at (0,0)");
                }
                pdf_dict_put_rect(gctx, page->obj, PDF_NAME(MediaBox), mediabox);
                pdf_dict_put_rect(gctx, page->obj, PDF_NAME(CropBox), mediabox);
            }
            fz_catch(gctx) {
                return NULL;
            }
            page->doc->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Page_set_cropbox(struct Page *self,PyObject *rect){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            fz_try(gctx) {
                ASSERT_PDF(page);
                fz_rect mediabox = pdf_bound_page(gctx, page);
                pdf_obj *o = pdf_dict_get_inheritable(gctx, page->obj, PDF_NAME(MediaBox));
                if (o) mediabox = pdf_to_rect(gctx, o);
                fz_rect cropbox = fz_empty_rect;
                fz_rect r = JM_rect_from_py(rect);
                cropbox.x0 = r.x0;
                cropbox.x1 = r.x1;
                cropbox.y0 = mediabox.y1 - r.y1 + mediabox.y0;
                cropbox.y1 = mediabox.y1 - r.y0 + mediabox.y0;
                pdf_dict_put_drop(gctx, page->obj, PDF_NAME(CropBox),
                                  pdf_new_rect(gctx, page->doc, cropbox));
            }
            fz_catch(gctx) {
                return NULL;
            }
            page->doc->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN struct Link *Page_load_links(struct Page *self){
            fz_link *l = NULL;
            fz_try(gctx) {
                l = fz_load_links(gctx, (fz_page *) self);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Link *) l;
        }
SWIGINTERN struct Annot *Page_first_annot(struct Page *self){
            pdf_annot *annot = NULL;
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            if (page)
            {
                annot = pdf_first_annot(gctx, page);
                if (annot) pdf_keep_annot(gctx, annot);
            }
            return (struct Annot *) annot;
        }
SWIGINTERN struct Annot *Page_first_widget(struct Page *self){
            pdf_annot *annot = NULL;
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            if (page) {
                annot = pdf_first_widget(gctx, page);
                if (annot) pdf_keep_annot(gctx, annot);
            }
            return (struct Annot *) annot;
        }
SWIGINTERN void Page_delete_link(struct Page *self,PyObject *linkdict){
            if (!PyDict_Check(linkdict)) return; // have no dictionary
            fz_try(gctx) {
                pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
                if (!page) goto finished;  // have no PDF
                int xref = (int) PyInt_AsLong(PyDict_GetItem(linkdict, dictkey_xref));
                if (xref < 1) goto finished;  // invalid xref
                pdf_obj *annots = pdf_dict_get(gctx, page->obj, PDF_NAME(Annots));
                if (!annots) goto finished;  // have no annotations
                int len = pdf_array_len(gctx, annots);
                if (len == 0) goto finished;
                int i, oxref = 0;

                for (i = 0; i < len; i++) {
                    oxref = pdf_to_num(gctx, pdf_array_get(gctx, annots, i));
                    if (xref == oxref) break;        // found xref in annotations
                }

                if (xref != oxref) goto finished;  // xref not in annotations
                pdf_array_delete(gctx, annots, i);   // delete entry in annotations
                pdf_delete_object(gctx, page->doc, xref);      // delete link object
                pdf_dict_put(gctx, page->obj, PDF_NAME(Annots), annots);
                JM_refresh_link_table(gctx, page);  // reload link / annot tables
                page->doc->dirty = 1;
                finished:;
            }
            fz_catch(gctx) {;}
        }
SWIGINTERN struct Annot *Page_delete_annot(struct Page *self,struct Annot *annot){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_annot *irt_annot = NULL;
            while (1) {
                // first loop through all /IRT annots and remove them
                irt_annot = JM_find_annot_irt(gctx, (pdf_annot *) annot);
                if (!irt_annot)  // no more there
                    break;
                JM_delete_annot(gctx, page, irt_annot);
            }
            pdf_annot *nextannot = pdf_next_annot(gctx, (pdf_annot *) annot);  // store next
            JM_delete_annot(gctx, page, (pdf_annot *) annot);
            if (nextannot) {
                nextannot = pdf_keep_annot(gctx, nextannot);
            }
            page->doc->dirty = 1;
            return (struct Annot *) nextannot;
        }
SWIGINTERN PyObject *Page_mediabox(struct Page *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            if (!page) {
                return JM_py_from_rect(fz_bound_page(gctx, (fz_page *) self));
            }
            return JM_py_from_rect(JM_mediabox(gctx, page->obj));
        }
SWIGINTERN PyObject *Page_cropbox(struct Page *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            if (!page) {
                return JM_py_from_rect(fz_bound_page(gctx, (fz_page *) self));
            }
            return JM_py_from_rect(JM_cropbox(gctx, page->obj));
        }
SWIGINTERN int Page_rotation(struct Page *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            if (!page) return 0;
            return JM_page_rotation(gctx, page);
        }
SWIGINTERN PyObject *Page_set_rotation(struct Page *self,int rotation){
            fz_try(gctx) {
                pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
                ASSERT_PDF(page);
                int rot = JM_norm_rotation(rotation);
                pdf_dict_put_int(gctx, page->obj, PDF_NAME(Rotate), (int64_t) rot);
                page->doc->dirty = 1;
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Page__addAnnot_FromString(struct Page *self,PyObject *linklist){
            pdf_obj *annots, *annot, *ind_obj;
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            PyObject *txtpy = NULL;
            char *text = NULL;
            int lcount = (int) PySequence_Size(linklist); // link count
            if (lcount < 1) Py_RETURN_NONE;
            int i = -1;
            fz_var(text);

            // insert links from the provided sources
            fz_try(gctx) {
                ASSERT_PDF(page);
                if (!pdf_dict_get(gctx, page->obj, PDF_NAME(Annots))) {
                    pdf_dict_put_array(gctx, page->obj, PDF_NAME(Annots), lcount);
                }
                annots = pdf_dict_get(gctx, page->obj, PDF_NAME(Annots));
                for (i = 0; i < lcount; i++) {
                    text = NULL;
                    txtpy = PySequence_ITEM(linklist, (Py_ssize_t) i);
                    text = JM_StrAsChar(txtpy);
                    Py_CLEAR(txtpy);
                    if (!text) THROWMSG(gctx, "bad linklist item");
                    annot = pdf_add_object_drop(gctx, page->doc,
                            JM_pdf_obj_from_str(gctx, page->doc, text));
                    ind_obj = pdf_new_indirect(gctx, page->doc, pdf_to_num(gctx, annot), 0);
                    pdf_array_push_drop(gctx, annots, ind_obj);
                    pdf_drop_obj(gctx, annot);
                }
            }
            fz_catch(gctx) {
                if (text) {
                    PySys_WriteStderr("%s (%i): '%s'\n", fz_caught_message(gctx), i, text);
                }
                else if (i >= 0) {
                    PySys_WriteStderr("%s (%i)\n", fz_caught_message(gctx), i);
                }
                PyErr_Clear();
                return NULL;
            }
            page->doc->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Page_clean_contents(struct Page *self,int sanitize){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            if (!page) {
                Py_RETURN_NONE;
            }
            pdf_filter_options filter = {
                NULL,  // opaque
                NULL,  // image filter
                NULL,  // text filter
                NULL,  // after text
                NULL,  // end page
                1,     // recurse: true
                1,     // instance forms
                1,     // sanitize plus filtering
                0      // do not ascii-escape binary data
                };
            filter.sanitize = sanitize;
            fz_try(gctx) {
                pdf_filter_page_contents(gctx, page->doc, page, &filter);
            }
            fz_catch(gctx) {
                Py_RETURN_NONE;
            }
            page->doc->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Page__show_pdf_page(struct Page *self,struct Page *fz_srcpage,int overlay,PyObject *matrix,int xref,int oc,PyObject *clip,struct Graftmap *graftmap,char *_imgname){
            pdf_obj *xobj1, *xobj2, *resources;
            fz_buffer *res=NULL, *nres=NULL;
            fz_rect cropbox = JM_rect_from_py(clip);
            fz_matrix mat = JM_matrix_from_py(matrix);
            int rc_xref = xref;
            fz_try(gctx) {
                pdf_page *tpage = pdf_page_from_fz_page(gctx, (fz_page *) self);
                pdf_obj *tpageref = tpage->obj;
                pdf_document *pdfout = tpage->doc;    // target PDF

                //-------------------------------------------------------------
                // convert the source page to a Form XObject
                //-------------------------------------------------------------
                xobj1 = JM_xobject_from_page(gctx, pdfout, (fz_page *) fz_srcpage,
                                             xref, (pdf_graft_map *) graftmap);
                if (!rc_xref) rc_xref = pdf_to_num(gctx, xobj1);

                //-------------------------------------------------------------
                // create referencing XObject (controls display on target page)
                //-------------------------------------------------------------
                // fill reference to xobj1 into the /Resources
                //-------------------------------------------------------------
                pdf_obj *subres1 = pdf_new_dict(gctx, pdfout, 5);
                pdf_dict_puts(gctx, subres1, "fullpage", xobj1);
                pdf_obj *subres  = pdf_new_dict(gctx, pdfout, 5);
                pdf_dict_put_drop(gctx, subres, PDF_NAME(XObject), subres1);

                res = fz_new_buffer(gctx, 20);
                fz_append_string(gctx, res, "/fullpage Do");

                xobj2 = pdf_new_xobject(gctx, pdfout, cropbox, mat, subres, res);
                if (oc > 0) {
                    JM_add_oc_object(gctx, pdfout, pdf_resolve_indirect(gctx, xobj2), oc);
                }
                pdf_drop_obj(gctx, subres);
                fz_drop_buffer(gctx, res);

                //-------------------------------------------------------------
                // update target page with xobj2:
                //-------------------------------------------------------------
                // 1. insert Xobject in Resources
                //-------------------------------------------------------------
                resources = pdf_dict_get_inheritable(gctx, tpageref, PDF_NAME(Resources));
                subres = pdf_dict_get(gctx, resources, PDF_NAME(XObject));
                if (!subres) {
                    subres = pdf_dict_put_dict(gctx, resources, PDF_NAME(XObject), 5);
                }

                pdf_dict_puts(gctx, subres, _imgname, xobj2);

                //-------------------------------------------------------------
                // 2. make and insert new Contents object
                //-------------------------------------------------------------
                nres = fz_new_buffer(gctx, 50);       // buffer for Do-command
                fz_append_string(gctx, nres, " q /");    // Do-command
                fz_append_string(gctx, nres, _imgname);
                fz_append_string(gctx, nres, " Do Q ");

                JM_insert_contents(gctx, pdfout, tpageref, nres, overlay);
                fz_drop_buffer(gctx, nres);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("i", rc_xref);
        }
SWIGINTERN PyObject *Page__insert_image(struct Page *self,char *filename,struct Pixmap *pixmap,PyObject *stream,PyObject *imask,PyObject *clip,int overlay,int rotate,int keep_proportion,int oc,int width,int height,int xref,int alpha,char const *_imgname,PyObject *digests){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_document *pdf = page->doc;
            float w = width, h = height;
            fz_pixmap *pm = NULL;
            fz_pixmap *pix = NULL;
            fz_image *mask = NULL, *zimg = NULL, *image = NULL, *freethis = NULL;
            pdf_obj *resources, *xobject, *ref;
            fz_buffer *nres = NULL,  *imgbuf = NULL, *maskbuf = NULL;
            fz_compressed_buffer *cbuf1 = NULL;
            int xres, yres, bpc, img_xref = xref, rc_digest = 0;
            unsigned char digest[16];
            PyObject *md5_py = NULL, *temp;
            const char *template = "\nq\n%g %g %g %g %g %g cm\n/%s Do\nQ\n";

            fz_try(gctx) {
                if (xref > 0) {
                    ref = pdf_new_indirect(gctx, pdf, xref, 0);
                    w = pdf_to_int(gctx,
                        pdf_dict_geta(gctx, ref,
                        PDF_NAME(Width), PDF_NAME(W)));
                    h = pdf_to_int(gctx,
                        pdf_dict_geta(gctx, ref,
                        PDF_NAME(Height), PDF_NAME(H)));
                    if ((w + h) == 0) {
                        THROWMSG(gctx, "xref is no image");
                    }
                    goto have_xref;
                }
                if (EXISTS(stream)) {
                    imgbuf = JM_BufferFromBytes(gctx, stream);
                    goto have_stream;
                }
                if (filename) {
                    imgbuf = fz_read_file(gctx, filename);
                    goto have_stream;
                }
            // process pixmap ---------------------------------
                fz_pixmap *arg_pix = (fz_pixmap *) pixmap;
                w = arg_pix->w;
                h = arg_pix->h;
                fz_md5_pixmap(gctx, arg_pix, digest);
                md5_py = PyBytes_FromStringAndSize(digest, 16);
                temp = PyDict_GetItem(digests, md5_py);
                if (temp) {
                    img_xref = (int) PyLong_AsLong(temp);
                    ref = pdf_new_indirect(gctx, page->doc, img_xref, 0);
                    goto have_xref;
                }
                if (arg_pix->alpha == 0) {
                    image = fz_new_image_from_pixmap(gctx, arg_pix, NULL);
                } else {
                    pm = fz_convert_pixmap(gctx, arg_pix, NULL, NULL, NULL,
                            fz_default_color_params, 1);
                    pm->alpha = 0;
                    pm->colorspace = NULL;
                    mask = fz_new_image_from_pixmap(gctx, pm, NULL);
                    image = fz_new_image_from_pixmap(gctx, arg_pix, mask);
                }
                goto have_image;

            // process stream ---------------------------------
            have_stream:;
                fz_md5_buffer(gctx, imgbuf, digest);
                md5_py = PyBytes_FromStringAndSize(digest, 16);
                temp = PyDict_GetItem(digests, md5_py);
                if (temp) {
                    img_xref = (int) PyLong_AsLong(temp);
                    ref = pdf_new_indirect(gctx, page->doc, img_xref, 0);
                    w = pdf_to_int(gctx,
                        pdf_dict_geta(gctx, ref,
                        PDF_NAME(Width), PDF_NAME(W)));
                    h = pdf_to_int(gctx,
                        pdf_dict_geta(gctx, ref,
                        PDF_NAME(Height), PDF_NAME(H)));
                    goto have_xref;
                }
                image = fz_new_image_from_buffer(gctx, imgbuf);
                w = image->w;
                h = image->h;
                if (EXISTS(imask)) {
                    goto have_imask;
                }
                if (alpha==0) {
                    goto have_image;
                }
                pix = fz_get_pixmap_from_image(gctx, image, NULL, NULL, 0, 0);
                if (!pix->alpha) {
                    goto have_image;
                }
                pix = fz_get_pixmap_from_image(gctx, image, NULL, NULL, 0, 0);
                pm = fz_convert_pixmap(gctx, pix, NULL, NULL, NULL,
                            fz_default_color_params, 1);
                pm->alpha = 0;
                pm->colorspace = NULL;
                mask = fz_new_image_from_pixmap(gctx, pm, NULL);
                zimg = fz_new_image_from_pixmap(gctx, pix, mask);
                fz_drop_image(gctx, image);
                image = zimg;
                zimg = NULL;
                goto have_image;

            have_imask:;
                cbuf1 = fz_compressed_image_buffer(gctx, image);
                if (!cbuf1) THROWMSG(gctx, "cannot mask uncompressed image");
                bpc = image->bpc;
                fz_colorspace *colorspace = image->colorspace;
                fz_image_resolution(image, &xres, &yres);
                maskbuf = JM_BufferFromBytes(gctx, imask);
                mask = fz_new_image_from_buffer(gctx, maskbuf);
                zimg = fz_new_image_from_compressed_buffer(gctx, w, h,
                            bpc, colorspace, xres, yres, 1, 0, NULL,
                            NULL, cbuf1, mask);
                freethis = image;
                image = zimg;
                zimg = NULL;
                goto have_image;

            have_image:;
                ref =  pdf_add_image(gctx, pdf, image);
                if (oc) {
                    JM_add_oc_object(gctx, pdf, ref, oc);
                }
                img_xref = pdf_to_num(gctx, ref);
                DICT_SETITEM_DROP(digests, md5_py, Py_BuildValue("i", img_xref));
                rc_digest = 1;
            have_xref:;
                resources = pdf_dict_get_inheritable(gctx, page->obj,
                                PDF_NAME(Resources));
                if (!resources) {
                    resources = pdf_dict_put_dict(gctx, page->obj,
                                    PDF_NAME(Resources), 2);
                }
                xobject = pdf_dict_get(gctx, resources, PDF_NAME(XObject));
                if (!xobject) {
                    xobject = pdf_dict_put_dict(gctx, resources,
                                  PDF_NAME(XObject), 2);
                }
                fz_matrix mat = calc_image_matrix(w, h, clip, rotate, keep_proportion);
                pdf_dict_puts_drop(gctx, xobject, _imgname, ref);
                nres = fz_new_buffer(gctx, 50);
                fz_append_printf(gctx, nres, template,
                                 mat.a, mat.b, mat.c, mat.d, mat.e, mat.f, _imgname);
                JM_insert_contents(gctx, pdf, page->obj, nres, overlay);
            }
            fz_always(gctx) {
                if (freethis) {
                    fz_drop_image(gctx, freethis);
                } else {
                    fz_drop_image(gctx, image);
                }
                fz_drop_image(gctx, mask);
                fz_drop_image(gctx, zimg);
                fz_drop_pixmap(gctx, pix);
                fz_drop_pixmap(gctx, pm);
                fz_drop_buffer(gctx, imgbuf);
                fz_drop_buffer(gctx, maskbuf);
                fz_drop_buffer(gctx, nres);
            }
            fz_catch(gctx) {
                return NULL;
            }

            if (rc_digest) {
                return Py_BuildValue("iO", img_xref, digests);
            } else {
                return Py_BuildValue("iO", img_xref, Py_None);
            }
        }
SWIGINTERN PyObject *Page_refresh(struct Page *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            if (!page) Py_RETURN_NONE;
            fz_try(gctx) {
                JM_refresh_link_table(gctx, page);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Page__insertFont(struct Page *self,char *fontname,char *bfname,char *fontfile,PyObject *fontbuffer,int set_simple,int idx,int wmode,int serif,int encoding,int ordering){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            pdf_document *pdf;
            pdf_obj *resources, *fonts, *font_obj;
            PyObject *value;
            fz_try(gctx) {
                ASSERT_PDF(page);
                pdf = page->doc;

                value = JM_insert_font(gctx, pdf, bfname, fontfile,fontbuffer,
                            set_simple, idx, wmode, serif, encoding, ordering);

                // get the objects /Resources, /Resources/Font
                resources = pdf_dict_get_inheritable(gctx, page->obj, PDF_NAME(Resources));
                fonts = pdf_dict_get(gctx, resources, PDF_NAME(Font));
                if (!fonts) {  // page has no fonts yet
                    fonts = pdf_new_dict(gctx, pdf, 5);
                    pdf_dict_putl_drop(gctx, page->obj, fonts, PDF_NAME(Resources), PDF_NAME(Font), NULL);
                }
                // store font in resources and fonts objects will contain named reference to font
                int xref = 0;
                JM_INT_ITEM(value, 0, &xref);
                if (!xref) {
                    THROWMSG(gctx, "cannot insert font");
                }
                font_obj = pdf_new_indirect(gctx, pdf, xref, 0);
                pdf_dict_puts_drop(gctx, fonts, fontname, font_obj);
            }
            fz_always(gctx) {
                ;
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdf->dirty = 1;
            return value;
        }
SWIGINTERN PyObject *Page_transformation_matrix(struct Page *self){
            fz_matrix ctm = fz_identity;
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            if (!page) return JM_py_from_matrix(ctm);
            fz_try(gctx) {
                pdf_page_transform(gctx, page, NULL, &ctm);
            }
            fz_catch(gctx) {;}
            return JM_py_from_matrix(ctm);
        }
SWIGINTERN PyObject *Page_get_contents(struct Page *self){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) self);
            PyObject *list = NULL;
            pdf_obj *contents = NULL, *icont = NULL;
            int i, xref;
            size_t n = 0;
            fz_try(gctx) {
                ASSERT_PDF(page);
                contents = pdf_dict_get(gctx, page->obj, PDF_NAME(Contents));
                if (pdf_is_array(gctx, contents)) {
                    n = pdf_array_len(gctx, contents);
                    list = PyList_New(n);
                    for (i = 0; i < n; i++) {
                        icont = pdf_array_get(gctx, contents, i);
                        xref = pdf_to_num(gctx, icont);
                        PyList_SET_ITEM(list, i, Py_BuildValue("i", xref));
                    }
                }
                else if (contents) {
                    list = PyList_New(1);
                    xref = pdf_to_num(gctx, contents);
                    PyList_SET_ITEM(list, 0, Py_BuildValue("i", xref));
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            if (list) {
                return list;
            }
            return PyList_New(0);
        }
SWIGINTERN void delete_Pixmap(struct Pixmap *self){
            DEBUGMSG1("Pixmap");
            fz_pixmap *this_pix = (fz_pixmap *) self;
            fz_drop_pixmap(gctx, this_pix);
            DEBUGMSG2;
        }
SWIGINTERN struct Pixmap *new_Pixmap__SWIG_0(struct Colorspace *cs,PyObject *bbox,int alpha){
            fz_pixmap *pm = NULL;
            fz_try(gctx) {
                pm = fz_new_pixmap_with_bbox(gctx, (fz_colorspace *) cs, JM_irect_from_py(bbox), NULL, alpha);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Pixmap *) pm;
        }
SWIGINTERN struct Pixmap *new_Pixmap__SWIG_1(struct Colorspace *cs,struct Pixmap *spix){
            fz_pixmap *pm = NULL;
            fz_try(gctx) {
                if (!fz_pixmap_colorspace(gctx, (fz_pixmap *) spix))
                    THROWMSG(gctx, "cannot copy pixmap with NULL colorspace");
                pm = fz_convert_pixmap(gctx, (fz_pixmap *) spix, (fz_colorspace *) cs, NULL, NULL, fz_default_color_params, 1);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Pixmap *) pm;
        }
SWIGINTERN struct Pixmap *new_Pixmap__SWIG_2(struct Pixmap *spix,float w,float h,PyObject *clip){
            fz_pixmap *pm = NULL;
            fz_pixmap *src_pix = (fz_pixmap *) spix;
            fz_try(gctx) {
                fz_irect bbox = JM_irect_from_py(clip);
                if (!fz_is_infinite_irect(bbox)) {
                    pm = fz_scale_pixmap(gctx, src_pix, src_pix->x, src_pix->y, w, h, &bbox);
                } else {
                    pm = fz_scale_pixmap(gctx, src_pix, src_pix->x, src_pix->y, w, h, NULL);
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Pixmap *) pm;
        }
SWIGINTERN struct Pixmap *new_Pixmap__SWIG_3(struct Pixmap *spix,int alpha){
            fz_pixmap *pm = NULL, *src_pix = (fz_pixmap *) spix;
            int n, w, h, i;
            fz_separations *seps = NULL;
            fz_try(gctx) {
                if (!INRANGE(alpha, 0, 1))
                    THROWMSG(gctx, "bad alpha value");
                fz_colorspace *cs = fz_pixmap_colorspace(gctx, src_pix);
                if (!cs && !alpha)
                    THROWMSG(gctx, "cannot drop alpha for 'NULL' colorspace");
                n = fz_pixmap_colorants(gctx, src_pix);
                w = fz_pixmap_width(gctx, src_pix);
                h = fz_pixmap_height(gctx, src_pix);
                pm = fz_new_pixmap(gctx, cs, w, h, seps, alpha);
                pm->x = src_pix->x;
                pm->y = src_pix->y;
                pm->xres = src_pix->xres;
                pm->yres = src_pix->yres;

                // copy samples data ------------------------------------------
                unsigned char *sptr = src_pix->samples;
                unsigned char *tptr = pm->samples;
                if (src_pix->alpha == pm->alpha) {  // identical samples
                    memcpy(tptr, sptr, w * h * (n + alpha));
                } else {
                    for (i = 0; i < w * h; i++) {
                        memcpy(tptr, sptr, n);
                        tptr += n;
                        if (pm->alpha) {
                            tptr[0] = 255;
                            tptr++;
                        }
                        sptr += n + src_pix->alpha;
                    }
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Pixmap *) pm;
        }
SWIGINTERN struct Pixmap *new_Pixmap__SWIG_4(struct Colorspace *cs,int w,int h,PyObject *samples,int alpha){
            int n = fz_colorspace_n(gctx, (fz_colorspace *) cs);
            int stride = (n + alpha)*w;
            fz_separations *seps = NULL;
            fz_buffer *res = NULL;
            fz_pixmap *pm = NULL;
            fz_try(gctx) {
                size_t size = 0;
                unsigned char *c = NULL;
                res = JM_BufferFromBytes(gctx, samples);
                if (!res) THROWMSG(gctx, "bad samples data");
                size = fz_buffer_storage(gctx, res, &c);
                if (stride * h != size) THROWMSG(gctx, "bad samples length");
                pm = fz_new_pixmap(gctx, (fz_colorspace *) cs, w, h, seps, alpha);
                memcpy(pm->samples, c, size);
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Pixmap *) pm;
        }
SWIGINTERN struct Pixmap *new_Pixmap__SWIG_5(PyObject *imagedata){
            fz_buffer *res = NULL;
            fz_image *img = NULL;
            fz_pixmap *pm = NULL;
            PyObject *fname = NULL;
            PyObject *name = PyUnicode_FromString("name");
            fz_try(gctx) {
                if (PyObject_HasAttrString(imagedata, "resolve")) {
                    fname = PyObject_CallMethod(imagedata, "__str__", NULL);
                    if (fname) {
                        img = fz_new_image_from_file(gctx, JM_StrAsChar(fname));
                    }
                } else if (PyObject_HasAttr(imagedata, name)) {
                    fname = PyObject_GetAttr(imagedata, name);
                    if (fname) {
                        img = fz_new_image_from_file(gctx, JM_StrAsChar(fname));
                    }
                } else if (PyUnicode_Check(imagedata)) {
                    img = fz_new_image_from_file(gctx, JM_StrAsChar(imagedata));
                } else {
                    res = JM_BufferFromBytes(gctx, imagedata);
                    if (!res || !fz_buffer_storage(gctx, res, NULL)) {
                        THROWMSG(gctx, "bad image data");
                    }
                    img = fz_new_image_from_buffer(gctx, res);
                }
                pm = fz_get_pixmap_from_image(gctx, img, NULL, NULL, NULL, NULL);
                int xres, yres;
                fz_image_resolution(img, &xres, &yres);
                pm->xres = xres;
                pm->yres = yres;
            }
            fz_always(gctx) {
                Py_CLEAR(fname);
                Py_CLEAR(name);
                fz_drop_image(gctx, img);
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Pixmap *) pm;
        }
SWIGINTERN struct Pixmap *new_Pixmap__SWIG_6(struct Document *doc,int xref){
            fz_image *img = NULL;
            fz_pixmap *pix = NULL;
            pdf_obj *ref = NULL;
            pdf_obj *type;
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) doc);
            fz_try(gctx) {
                ASSERT_PDF(pdf);
                int xreflen = pdf_xref_len(gctx, pdf);
                if (!INRANGE(xref, 1, xreflen-1))
                    THROWMSG(gctx, "bad xref");
                ref = pdf_new_indirect(gctx, pdf, xref, 0);
                type = pdf_dict_get(gctx, ref, PDF_NAME(Subtype));
                if (!pdf_name_eq(gctx, type, PDF_NAME(Image)))
                    THROWMSG(gctx, "not an image");
                img = pdf_load_image(gctx, pdf, ref);
                pix = fz_get_pixmap_from_image(gctx, img, NULL, NULL, NULL, NULL);
            }
            fz_always(gctx) {
                fz_drop_image(gctx, img);
                pdf_drop_obj(gctx, ref);
            }
            fz_catch(gctx) {
                fz_drop_pixmap(gctx, pix);
                return NULL;
            }
            return (struct Pixmap *) pix;
        }
SWIGINTERN void Pixmap_shrink(struct Pixmap *self,int factor){
            if (factor < 1)
            {
                JM_Warning("ignoring shrink factor < 1");
                return;
            }
            fz_subsample_pixmap(gctx, (fz_pixmap *) self, factor);
        }
SWIGINTERN void Pixmap_gamma_with(struct Pixmap *self,float gamma){
            if (!fz_pixmap_colorspace(gctx, (fz_pixmap *) self))
            {
                JM_Warning("colorspace invalid for function");
                return;
            }
            fz_gamma_pixmap(gctx, (fz_pixmap *) self, gamma);
        }
SWIGINTERN void Pixmap_tint_with(struct Pixmap *self,int black,int white){
            fz_tint_pixmap(gctx, (fz_pixmap *) self, black, white);
        }
SWIGINTERN void Pixmap_clear_with__SWIG_0(struct Pixmap *self){
            fz_clear_pixmap(gctx, (fz_pixmap *) self);
        }
SWIGINTERN void Pixmap_clear_with__SWIG_1(struct Pixmap *self,int value){
            fz_clear_pixmap_with_value(gctx, (fz_pixmap *) self, value);
        }
SWIGINTERN void Pixmap_clear_with__SWIG_2(struct Pixmap *self,int value,PyObject *bbox){
            JM_clear_pixmap_rect_with_value(gctx, (fz_pixmap *) self, value, JM_irect_from_py(bbox));
        }
SWIGINTERN PyObject *Pixmap_copy(struct Pixmap *self,struct Pixmap *src,PyObject *bbox){
            fz_try(gctx) {
                fz_pixmap *pm = (fz_pixmap *) self, *src_pix = (fz_pixmap *) src;
                if (!fz_pixmap_colorspace(gctx, src_pix))
                    THROWMSG(gctx, "cannot copy pixmap with NULL colorspace");
                if (pm->alpha != src_pix->alpha)
                    THROWMSG(gctx, "source and target alpha must be equal");
                fz_copy_pixmap_rect(gctx, pm, src_pix, JM_irect_from_py(bbox), NULL);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Pixmap_set_alpha(struct Pixmap *self,PyObject *alphavalues,int premultiply,PyObject *opaque){
            fz_buffer *res = NULL;
            fz_pixmap *pix = (fz_pixmap *) self;
            int divisor = 255;
            int denom;
            fz_try(gctx) {
                if (pix->alpha == 0) {
                    THROWMSG(gctx, "pixmap has no alpha");
                }
                size_t i, k, j;
                size_t n = fz_pixmap_colorants(gctx, pix);
                size_t w = (size_t) fz_pixmap_width(gctx, pix);
                size_t h = (size_t) fz_pixmap_height(gctx, pix);
                size_t balen = w * h * (n+1);
                int colors[4];
                int zero_out = 0;
                if (opaque && PySequence_Check(opaque) && PySequence_Size(opaque) == n) {
                    for (i = 0; i < n; i++) {
                        if (JM_INT_ITEM(opaque, i, &colors[i]) == 1) {
                            THROWMSG(gctx, "bad opaque components");
                        }
                    }
                    zero_out = 1;
                }
                unsigned char *data = NULL;
                size_t data_len = 0;
                if (alphavalues && PyObject_IsTrue(alphavalues)) {
                    res = JM_BufferFromBytes(gctx, alphavalues);
                    data_len = fz_buffer_storage(gctx, res, &data);
                    if (data_len < w * h)
                        THROWMSG(gctx, "bad alpha values");
                }
                i = k = j = 0;
                int data_fix = 255;
                while (i < balen) {
                    if (zero_out) {
                        for (j = i; j < i+n; j++) {
                            if (pix->samples[j] != (unsigned char) colors[j - i]) {
                                data_fix = 255;
                                break;
                            } else {
                                data_fix = 0;
                            }
                        }
                    }
                    if (data_len) {
                        if (data_fix == 0) {
                            pix->samples[i+n] = 0;
                        } else {
                            pix->samples[i+n] = data[k];
                        }
                        if (premultiply == 1) {
                            denom = (int) data[k];
                            for (j = i; j < i+n; j++) {
                                pix->samples[j] = pix->samples[j] * denom / divisor;
                            }
                        }
                    } else {
                        pix->samples[i+n] = data_fix;
                    }
                    i += n+1;
                    k += 1;
                }
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Pixmap__tobytes(struct Pixmap *self,int format){
            fz_output *out = NULL;
            fz_buffer *res = NULL;
            PyObject *barray = NULL;
            fz_pixmap *pm = (fz_pixmap *) self;
            fz_try(gctx) {
                size_t size = fz_pixmap_stride(gctx, pm) * pm->h;
                res = fz_new_buffer(gctx, size);
                out = fz_new_output_with_buffer(gctx, res);

                switch(format) {
                    case(1):
                        fz_write_pixmap_as_png(gctx, out, pm);
                        break;
                    case(2):
                        fz_write_pixmap_as_pnm(gctx, out, pm);
                        break;
                    case(3):
                        fz_write_pixmap_as_pam(gctx, out, pm);
                        break;
                    case(5):           // Adobe Photoshop Document
                        fz_write_pixmap_as_psd(gctx, out, pm);
                        break;
                    case(6):           // Postscript format
                        fz_write_pixmap_as_ps(gctx, out, pm);
                        break;
                    default:
                        fz_write_pixmap_as_png(gctx, out, pm);
                        break;
                }
                barray = JM_BinFromBuffer(gctx, res);
            }
            fz_always(gctx) {
                fz_drop_output(gctx, out);
                fz_drop_buffer(gctx, res);
            }

            fz_catch(gctx) {
                return NULL;
            }
            return barray;
        }
SWIGINTERN PyObject *Pixmap__writeIMG(struct Pixmap *self,char *filename,int format){
            fz_try(gctx) {
                fz_pixmap *pm = (fz_pixmap *) self;
                switch(format) {
                    case(1):
                        fz_save_pixmap_as_png(gctx, pm, filename);
                        break;
                    case(2):
                        fz_save_pixmap_as_pnm(gctx, pm, filename);
                        break;
                    case(3):
                        fz_save_pixmap_as_pam(gctx, pm, filename);
                        break;
                    case(5): // Adobe Photoshop Document
                        fz_save_pixmap_as_psd(gctx, pm, filename);
                        break;
                    case(6): // Postscript
                        fz_save_pixmap_as_ps(gctx, pm, filename, 0);
                        break;
                    default:
                        fz_save_pixmap_as_png(gctx, pm, filename);
                        break;
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Pixmap_invert_irect(struct Pixmap *self,PyObject *bbox){
            fz_pixmap *pm = (fz_pixmap *) self;
            if (!fz_pixmap_colorspace(gctx, pm))
                {
                    JM_Warning("ignored for stencil pixmap");
                    return JM_BOOL(0);
                }

            fz_irect r = JM_irect_from_py(bbox);
            if (fz_is_infinite_irect(r))
                r = fz_pixmap_bbox(gctx, pm);

            return JM_BOOL(JM_invert_pixmap_rect(gctx, pm, r));
        }
SWIGINTERN PyObject *Pixmap_pixel(struct Pixmap *self,int x,int y){
            PyObject *p = NULL;
            fz_try(gctx) {
                fz_pixmap *pm = (fz_pixmap *) self;
                if (!INRANGE(x, 0, pm->w - 1) || !INRANGE(y, 0, pm->h - 1))
                    THROWMSG(gctx, "outside image");
                int n = pm->n;
                int stride = fz_pixmap_stride(gctx, pm);
                int j, i = stride * y + n * x;
                p = PyTuple_New(n);
                for (j = 0; j < n; j++) {
                    PyTuple_SET_ITEM(p, j, Py_BuildValue("i", pm->samples[i + j]));
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            return p;
        }
SWIGINTERN PyObject *Pixmap_set_pixel(struct Pixmap *self,int x,int y,PyObject *color){
            fz_try(gctx) {
                fz_pixmap *pm = (fz_pixmap *) self;
                if (!INRANGE(x, 0, pm->w - 1) || !INRANGE(y, 0, pm->h - 1))
                    THROWMSG(gctx, "outside image");
                int n = pm->n;
                if (!PySequence_Check(color) || PySequence_Size(color) != n)
                    THROWMSG(gctx, "bad color arg");
                int i, j;
                unsigned char c[5];
                for (j = 0; j < n; j++) {
                    if (JM_INT_ITEM(color, j, &i) == 1)
                        THROWMSG(gctx, "bad color sequence");
                    if (!INRANGE(i, 0, 255))
                        THROWMSG(gctx, "bad color sequence");
                    c[j] = (unsigned char) i;
                }
                int stride = fz_pixmap_stride(gctx, pm);
                i = stride * y + n * x;
                for (j = 0; j < n; j++) {
                    pm->samples[i + j] = c[j];
                }
            }
            fz_catch(gctx) {
                PyErr_Clear();
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Pixmap_set_origin(struct Pixmap *self,int x,int y){
            fz_pixmap *pm = (fz_pixmap *) self;
            pm->x = x;
            pm->y = y;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Pixmap_set_dpi(struct Pixmap *self,int xres,int yres){
            fz_pixmap *pm = (fz_pixmap *) self;
            pm->xres = xres;
            pm->yres = yres;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Pixmap_set_rect(struct Pixmap *self,PyObject *bbox,PyObject *color){
            PyObject *rc = NULL;
            fz_try(gctx) {
                fz_pixmap *pm = (fz_pixmap *) self;
                Py_ssize_t j, n = (Py_ssize_t) pm->n;
                if (!PySequence_Check(color) || PySequence_Size(color) != n)
                    THROWMSG(gctx, "bad color arg");
                unsigned char c[5];
                int i;
                for (j = 0; j < n; j++) {
                    if (JM_INT_ITEM(color, j, &i) == 1)
                        THROWMSG(gctx, "bad color component");
                    if (!INRANGE(i, 0, 255))
                        THROWMSG(gctx, "bad color component");
                    c[j] = (unsigned char) i;
                }
                i = JM_fill_pixmap_rect_with_color(gctx, pm, c, JM_irect_from_py(bbox));
                rc = JM_BOOL(i);
            }
            fz_catch(gctx) {
                PyErr_Clear();
                return NULL;
            }
            return rc;
        }
SWIGINTERN PyObject *Pixmap_is_monochrome(struct Pixmap *self){
            return JM_BOOL(fz_is_pixmap_monochrome(gctx, (fz_pixmap *) self));
        }
SWIGINTERN PyObject *Pixmap_digest(struct Pixmap *self){
            unsigned char digest[16];
            fz_md5_pixmap(gctx, (fz_pixmap *) self, digest);
            return PyBytes_FromStringAndSize(digest, 16);
        }
SWIGINTERN PyObject *Pixmap_stride(struct Pixmap *self){
            return PyLong_FromSize_t((size_t) fz_pixmap_stride(gctx, (fz_pixmap *) self));
        }
SWIGINTERN int Pixmap_xres(struct Pixmap *self){
            fz_pixmap *this_pix = (fz_pixmap *) self;
            return this_pix->xres;
        }
SWIGINTERN int Pixmap_yres(struct Pixmap *self){
            fz_pixmap *this_pix = (fz_pixmap *) self;
            return this_pix->yres;
        }
SWIGINTERN PyObject *Pixmap_w(struct Pixmap *self){
            return PyLong_FromSize_t((size_t) fz_pixmap_width(gctx, (fz_pixmap *) self));
        }
SWIGINTERN PyObject *Pixmap_h(struct Pixmap *self){
            return PyLong_FromSize_t((size_t) fz_pixmap_height(gctx, (fz_pixmap *) self));
        }
SWIGINTERN int Pixmap_x(struct Pixmap *self){
            return fz_pixmap_x(gctx, (fz_pixmap *) self);
        }
SWIGINTERN int Pixmap_y(struct Pixmap *self){
            return fz_pixmap_y(gctx, (fz_pixmap *) self);
        }
SWIGINTERN int Pixmap_n(struct Pixmap *self){
            return fz_pixmap_components(gctx, (fz_pixmap *) self);
        }
SWIGINTERN int Pixmap_alpha(struct Pixmap *self){
            return fz_pixmap_alpha(gctx, (fz_pixmap *) self);
        }
SWIGINTERN struct Colorspace *Pixmap_colorspace(struct Pixmap *self){
            return (struct Colorspace *) fz_pixmap_colorspace(gctx, (fz_pixmap *) self);
        }
SWIGINTERN PyObject *Pixmap_irect(struct Pixmap *self){
            return JM_py_from_irect(fz_pixmap_bbox(gctx, (fz_pixmap *) self));
        }
SWIGINTERN PyObject *Pixmap_size(struct Pixmap *self){
            fz_pixmap *pix = (fz_pixmap *) self;
            size_t s = (size_t) pix->w;
            s *= pix->h;
            s *= pix->n;
            s += sizeof(*pix);
            return PyLong_FromSize_t(s);
        }
SWIGINTERN PyObject *Pixmap_samples(struct Pixmap *self){
            fz_pixmap *pm = (fz_pixmap *) self;
            Py_ssize_t s = (Py_ssize_t) pm->w;
            s *= pm->h;
            s *= pm->n;
            return PyBytes_FromStringAndSize((const char *) pm->samples, s);
        }
SWIGINTERN void delete_Colorspace(struct Colorspace *self){
            DEBUGMSG1("Colorspace");
            fz_colorspace *this_cs = (fz_colorspace *) self;
            fz_drop_colorspace(gctx, this_cs);
            DEBUGMSG2;
        }
SWIGINTERN struct Colorspace *new_Colorspace(int type){
            fz_colorspace *cs = NULL;
            switch(type) {
                case CS_GRAY:
                    cs = fz_device_gray(gctx);
                    break;
                case CS_CMYK:
                    cs = fz_device_cmyk(gctx);
                    break;
                case CS_RGB:
                default:
                    cs = fz_device_rgb(gctx);
                    break;
            }
            return (struct Colorspace *) cs;
        }
SWIGINTERN PyObject *Colorspace_n(struct Colorspace *self){
            return Py_BuildValue("i", fz_colorspace_n(gctx, (fz_colorspace *) self));
        }
SWIGINTERN PyObject *Colorspace__name(struct Colorspace *self){
            return JM_UnicodeFromStr(fz_colorspace_name(gctx, (fz_colorspace *) self));
        }
SWIGINTERN struct DeviceWrapper *new_DeviceWrapper__SWIG_0(struct Pixmap *pm,PyObject *clip){
            struct DeviceWrapper *dw = NULL;
            fz_try(gctx) {
                dw = (struct DeviceWrapper *)calloc(1, sizeof(struct DeviceWrapper));
                fz_irect bbox = JM_irect_from_py(clip);
                if (fz_is_infinite_irect(bbox))
                    dw->device = fz_new_draw_device(gctx, fz_identity, (fz_pixmap *) pm);
                else
                    dw->device = fz_new_draw_device_with_bbox(gctx, fz_identity, (fz_pixmap *) pm, &bbox);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return dw;
        }
SWIGINTERN struct DeviceWrapper *new_DeviceWrapper__SWIG_1(struct DisplayList *dl){
            struct DeviceWrapper *dw = NULL;
            fz_try(gctx) {
                dw = (struct DeviceWrapper *)calloc(1, sizeof(struct DeviceWrapper));
                dw->device = fz_new_list_device(gctx, (fz_display_list *) dl);
                dw->list = (fz_display_list *) dl;
                fz_keep_display_list(gctx, (fz_display_list *) dl);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return dw;
        }
SWIGINTERN struct DeviceWrapper *new_DeviceWrapper__SWIG_2(struct TextPage *tp,int flags){
            struct DeviceWrapper *dw = NULL;
            fz_try(gctx) {
                dw = (struct DeviceWrapper *)calloc(1, sizeof(struct DeviceWrapper));
                fz_stext_options opts = { 0 };
                opts.flags = flags;
                dw->device = fz_new_stext_device(gctx, (fz_stext_page *) tp, &opts);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return dw;
        }
SWIGINTERN void delete_DeviceWrapper(struct DeviceWrapper *self){
            fz_display_list *list = self->list;
            DEBUGMSG1("Device");
            fz_close_device(gctx, self->device);
            fz_drop_device(gctx, self->device);
            DEBUGMSG2;
            if(list)
            {
                DEBUGMSG1("DisplayList after Device");
                fz_drop_display_list(gctx, list);
                DEBUGMSG2;
            }
        }
SWIGINTERN PyObject *Outline_uri(struct Outline *self){
            fz_outline *ol = (fz_outline *) self;
            return JM_UnicodeFromStr(ol->uri);
        }
SWIGINTERN struct Outline *Outline_next(struct Outline *self){
            fz_outline *ol = (fz_outline *) self;
            fz_outline *next_ol = ol->next;
            if (!next_ol) return NULL;
            next_ol = fz_keep_outline(gctx, next_ol);
            return (struct Outline *) next_ol;
        }
SWIGINTERN struct Outline *Outline_down(struct Outline *self){
            fz_outline *ol = (fz_outline *) self;
            fz_outline *down_ol = ol->down;
            if (!down_ol) return NULL;
            down_ol = fz_keep_outline(gctx, down_ol);
            return (struct Outline *) down_ol;
        }
SWIGINTERN PyObject *Outline_isExternal(struct Outline *self){
            fz_outline *ol = (fz_outline *) self;
            if (!ol->uri) Py_RETURN_FALSE;
            return JM_BOOL(fz_is_external_link(gctx, ol->uri));
        }
SWIGINTERN int Outline_page(struct Outline *self){
            fz_outline *ol = (fz_outline *) self;
            return ol->page;
        }
SWIGINTERN float Outline_x(struct Outline *self){
            fz_outline *ol = (fz_outline *) self;
            return ol->x;
        }

SWIGINTERNINLINE PyObject *
SWIG_From_float  (float value)
{    
  return SWIG_From_double  (value);
}

SWIGINTERN float Outline_y(struct Outline *self){
            fz_outline *ol = (fz_outline *) self;
            return ol->y;
        }
SWIGINTERN PyObject *Outline_title(struct Outline *self){
            fz_outline *ol = (fz_outline *) self;
            return JM_UnicodeFromStr(ol->title);
        }
SWIGINTERN PyObject *Outline_is_open(struct Outline *self){
            fz_outline *ol = (fz_outline *) self;
            return JM_BOOL(ol->is_open);
        }
SWIGINTERN void delete_Annot(struct Annot *self){
            DEBUGMSG1("Annot");
            pdf_drop_annot(gctx, (pdf_annot *) self);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *Annot_rect(struct Annot *self){
            fz_rect r = pdf_bound_annot(gctx, (pdf_annot *) self);
            return JM_py_from_rect(r);
        }
SWIGINTERN PyObject *Annot_xref(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;
            return Py_BuildValue("i", pdf_to_num(gctx, annot->obj));
        }
SWIGINTERN PyObject *Annot_apn_matrix(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;
            pdf_obj *ap = pdf_dict_getl(gctx, annot->obj, PDF_NAME(AP),
                            PDF_NAME(N), NULL);
            if (!ap)
                return JM_py_from_matrix(fz_identity);
            fz_matrix mat = pdf_dict_get_matrix(gctx, ap, PDF_NAME(Matrix));
            return JM_py_from_matrix(mat);
        }
SWIGINTERN PyObject *Annot_apn_bbox(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;
            pdf_obj *ap = pdf_dict_getl(gctx, annot->obj, PDF_NAME(AP),
                            PDF_NAME(N), NULL);
            if (!ap)
                return JM_py_from_rect(fz_infinite_rect);
            fz_rect rect = pdf_dict_get_rect(gctx, ap, PDF_NAME(BBox));
            return JM_py_from_rect(rect);
        }
SWIGINTERN PyObject *Annot_set_apn_matrix(struct Annot *self,PyObject *matrix){
            pdf_annot *annot = (pdf_annot *) self;
            fz_try(gctx) {
                pdf_obj *ap = pdf_dict_getl(gctx, annot->obj, PDF_NAME(AP),
                                                PDF_NAME(N), NULL);
                if (!ap) THROWMSG(gctx, "annot has no appearance stream");
                fz_matrix mat = JM_matrix_from_py(matrix);
                pdf_dict_put_matrix(gctx, ap, PDF_NAME(Matrix), mat);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot_set_apn_bbox(struct Annot *self,PyObject *bbox){
            pdf_annot *annot = (pdf_annot *) self;
            fz_try(gctx) {
                pdf_obj *ap = pdf_dict_getl(gctx, annot->obj, PDF_NAME(AP),
                                                PDF_NAME(N), NULL);
                if (!ap) THROWMSG(gctx, "annot has no appearance stream");
                fz_rect rect = JM_rect_from_py(bbox);
                pdf_dict_put_rect(gctx, ap, PDF_NAME(BBox), rect);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot_blendmode(struct Annot *self){
            PyObject *blend_mode = NULL;
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                pdf_obj *obj, *obj1, *obj2;
                obj = pdf_dict_get(gctx, annot->obj, PDF_NAME(BM));
                if (obj) {
                    blend_mode = JM_UnicodeFromStr(pdf_to_name(gctx, obj));
                    goto finished;
                }
                // loop through the /AP/N/Resources/ExtGState objects
                obj = pdf_dict_getl(gctx, annot->obj, PDF_NAME(AP),
                    PDF_NAME(N),
                    PDF_NAME(Resources),
                    PDF_NAME(ExtGState),
                    NULL);

                if (pdf_is_dict(gctx, obj)) {
                    int i, j, m, n = pdf_dict_len(gctx, obj);
                    for (i = 0; i < n; i++) {
                        obj1 = pdf_dict_get_val(gctx, obj, i);
                        if (pdf_is_dict(gctx, obj1)) {
                            m = pdf_dict_len(gctx, obj1);
                            for (j = 0; j < m; j++) {
                                obj2 = pdf_dict_get_key(gctx, obj1, j);
                                if (pdf_objcmp(gctx, obj2, PDF_NAME(BM)) == 0) {
                                    blend_mode = JM_UnicodeFromStr(pdf_to_name(gctx, pdf_dict_get_val(gctx, obj1, j)));
                                    goto finished;
                                }
                            }
                        }
                    }
                }
                finished:;
            }
            fz_catch(gctx) {
                Py_RETURN_NONE;
            }
            if (blend_mode) return blend_mode;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot_set_blendmode(struct Annot *self,char *blend_mode){
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                pdf_dict_put_name(gctx, annot->obj, PDF_NAME(BM), blend_mode);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot_get_oc(struct Annot *self){
            int oc = 0;
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                pdf_obj *obj = pdf_dict_get(gctx, annot->obj, PDF_NAME(OC));
                if (obj) {
                    oc = pdf_to_num(gctx, obj);
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("i", oc);
        }
SWIGINTERN PyObject *Annot_set_open(struct Annot *self,int is_open){
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                pdf_set_annot_is_open(gctx, annot, is_open);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot_is_open(struct Annot *self){
            int is_open;
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                is_open = pdf_annot_is_open(gctx, annot);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return JM_BOOL(is_open);
        }
SWIGINTERN PyObject *Annot_has_popup(struct Annot *self){
            int has_popup = 0;
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                pdf_obj *obj = pdf_dict_get(gctx, annot->obj, PDF_NAME(Popup));
                if (obj) has_popup = 1;
            }
            fz_catch(gctx) {
                return NULL;
            }
            return JM_BOOL(has_popup);
        }
SWIGINTERN PyObject *Annot_set_popup(struct Annot *self,PyObject *rect){
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                pdf_page *pdfpage = annot->page;
                fz_matrix rot = JM_rotate_page_matrix(gctx, pdfpage);
                fz_rect r = fz_transform_rect(JM_rect_from_py(rect), rot);
                pdf_set_annot_popup(gctx, annot, r);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot_popup_rect(struct Annot *self){
            fz_rect rect = fz_infinite_rect;
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                pdf_obj *obj = pdf_dict_get(gctx, annot->obj, PDF_NAME(Popup));
                if (obj) {
                    rect = pdf_dict_get_rect(gctx, obj, PDF_NAME(Rect));
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            return JM_py_from_rect(rect);
        }
SWIGINTERN PyObject *Annot_popup_xref(struct Annot *self){
            int xref = 0;
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                pdf_obj *obj = pdf_dict_get(gctx, annot->obj, PDF_NAME(Popup));
                if (obj) {
                    xref = pdf_to_num(gctx, obj);
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *Annot_set_oc(struct Annot *self,int oc){
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                if (!oc) {
                    pdf_dict_del(gctx, annot->obj, PDF_NAME(OC));
                } else {
                    JM_add_oc_object(gctx, pdf_get_bound_document(gctx, annot->obj), annot->obj, oc);
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot_language(struct Annot *self){
            pdf_annot *this_annot = (pdf_annot *) self;
            fz_text_language lang = pdf_annot_language(gctx, this_annot);
            char buf[8];
            if (lang == FZ_LANG_UNSET) Py_RETURN_NONE;
            return Py_BuildValue("s", fz_string_from_text_language(buf, lang));
        }
SWIGINTERN PyObject *Annot_set_language(struct Annot *self,char *language){
            pdf_annot *this_annot = (pdf_annot *) self;
            fz_try(gctx) {
                fz_text_language lang;
                if (!language)
                    lang = FZ_LANG_UNSET;
                else
                    lang = fz_text_language_from_string(language);
                pdf_set_annot_language(gctx, this_annot, lang);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot__getAP(struct Annot *self){
            PyObject *r = NULL;
            fz_buffer *res = NULL;
            fz_var(res);
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                pdf_obj *ap = pdf_dict_getl(gctx, annot->obj, PDF_NAME(AP),
                                              PDF_NAME(N), NULL);

                if (pdf_is_stream(gctx, ap))  res = pdf_load_stream(gctx, ap);
                if (res) {
                    r = JM_BinFromBuffer(gctx, res);
                }
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) {
                Py_RETURN_NONE;
            }
            if (!r) Py_RETURN_NONE;
            return r;
        }
SWIGINTERN PyObject *Annot__setAP(struct Annot *self,PyObject *ap,int rect){
            fz_buffer *res = NULL;
            fz_var(res);
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                pdf_obj *apobj = pdf_dict_getl(gctx, annot->obj, PDF_NAME(AP),
                                              PDF_NAME(N), NULL);
                if (!apobj) THROWMSG(gctx, "annot has no AP/N object");
                if (!pdf_is_stream(gctx, apobj))
                    THROWMSG(gctx, "AP/N object is no stream");
                res = JM_BufferFromBytes(gctx, ap);
                if (!res) THROWMSG(gctx, "invalid /AP stream argument");
                JM_update_stream(gctx, annot->page->doc, apobj, res, 1);
                if (rect) {
                    fz_rect bbox = pdf_dict_get_rect(gctx, annot->obj, PDF_NAME(Rect));
                    pdf_dict_put_rect(gctx, apobj, PDF_NAME(BBox), bbox);
                    annot->ap = NULL;
                }
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot__get_redact_values(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;
            if (pdf_annot_type(gctx, annot) != PDF_ANNOT_REDACT)
                Py_RETURN_NONE;

            PyObject *values = PyDict_New();
            pdf_obj *obj = NULL;
            const char *text = NULL;
            fz_try(gctx) {
                obj = pdf_dict_gets(gctx, annot->obj, "RO");
                if (obj) {
                    JM_Warning("Ignoring redaction key '/RO'.");
                    int xref = pdf_to_num(gctx, obj);
                    DICT_SETITEM_DROP(values, dictkey_xref, Py_BuildValue("i", xref));
                }
                obj = pdf_dict_gets(gctx, annot->obj, "OverlayText");
                if (obj) {
                    text = pdf_to_text_string(gctx, obj);
                    DICT_SETITEM_DROP(values, dictkey_text, JM_UnicodeFromStr(text));
                } else {
                    DICT_SETITEM_DROP(values, dictkey_text, Py_BuildValue("s", ""));
                }
                obj = pdf_dict_get(gctx, annot->obj, PDF_NAME(Q));
                int align = 0;
                if (obj) {
                    align = pdf_to_int(gctx, obj);
                }
                DICT_SETITEM_DROP(values, dictkey_align, Py_BuildValue("i", align));
            }
            fz_catch(gctx) {
                Py_DECREF(values);
                return NULL;
            }
            return values;
        }
SWIGINTERN struct TextPage *Annot_get_textpage(struct Annot *self,PyObject *clip,int flags){
            fz_stext_page *textpage=NULL;
            fz_stext_options options = { 0 };
            options.flags = flags;
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                textpage = pdf_new_stext_page_from_annot(gctx, annot, &options);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct TextPage *) textpage;
        }
SWIGINTERN PyObject *Annot_set_name(struct Annot *self,char *name){
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                pdf_dict_put_name(gctx, annot->obj, PDF_NAME(Name), name);
                pdf_dirty_annot(gctx, annot);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot_set_rect(struct Annot *self,PyObject *rect){
            fz_try(gctx) {
                pdf_annot *annot = (pdf_annot *) self;
                pdf_page *pdfpage = annot->page;
                fz_matrix rot = JM_rotate_page_matrix(gctx, pdfpage);
                fz_rect r = fz_transform_rect(JM_rect_from_py(rect), rot);
                pdf_set_annot_rect(gctx, annot, r);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot_set_rotation(struct Annot *self,int rotate){
            pdf_annot *annot = (pdf_annot *) self;
            int type = pdf_annot_type(gctx, annot);
            switch (type)
            {
                case PDF_ANNOT_CARET: break;
                case PDF_ANNOT_CIRCLE: break;
                case PDF_ANNOT_FREE_TEXT: break;
                case PDF_ANNOT_FILE_ATTACHMENT: break;
                case PDF_ANNOT_INK: break;
                case PDF_ANNOT_LINE: break;
                case PDF_ANNOT_POLY_LINE: break;
                case PDF_ANNOT_POLYGON: break;
                case PDF_ANNOT_SQUARE: break;
                case PDF_ANNOT_STAMP: break;
                case PDF_ANNOT_TEXT: break;
                default: Py_RETURN_NONE;
            }
            int rot = rotate;
            while (rot < 0) rot += 360;
            while (rot >= 360) rot -= 360;
            if (type == PDF_ANNOT_FREE_TEXT && rot % 90 != 0)
                rot = 0;

            pdf_dict_put_int(gctx, annot->obj, PDF_NAME(Rotate), rot);
            Py_RETURN_NONE;
        }
SWIGINTERN int Annot_rotation(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;
            pdf_obj *rotation = pdf_dict_get(gctx, annot->obj, PDF_NAME(Rotate));
            if (!rotation) return -1;
            return pdf_to_int(gctx, rotation);
        }
SWIGINTERN PyObject *Annot_vertices(struct Annot *self){
            PyObject *res = NULL, *res1 = NULL;
            pdf_obj *o, *o1;
            pdf_annot *annot = (pdf_annot *) self;
            int i, j;
            fz_point point;  // point object to work with
            fz_matrix page_ctm;  // page transformation matrix
            pdf_page_transform(gctx, annot->page, NULL, &page_ctm);
            fz_matrix derot = JM_derotate_page_matrix(gctx, annot->page);
            page_ctm = fz_concat(page_ctm, derot);

            //----------------------------------------------------------------
            // The following objects occur in different annotation types.
            // So we are sure that (!o) occurs at most once.
            // Every pair of floats is one point, that needs to be separately
            // transformed with the page transformation matrix.
            //----------------------------------------------------------------
            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(Vertices));
            if (o) goto weiter;
            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(L));
            if (o) goto weiter;
            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(QuadPoints));
            if (o) goto weiter;
            o = pdf_dict_gets(gctx, annot->obj, "CL");
            if (o) goto weiter;
            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(InkList));
            if (o) goto inklist;
            Py_RETURN_NONE;

            // handle lists with 1-level depth --------------------------------
            weiter:;
            res = PyList_New(0);  // create Python list
            for (i = 0; i < pdf_array_len(gctx, o); i += 2)
            {
                point.x = pdf_to_real(gctx, pdf_array_get(gctx, o, i));
                point.y = pdf_to_real(gctx, pdf_array_get(gctx, o, i+1));
                point = fz_transform_point(point, page_ctm);
                LIST_APPEND_DROP(res, Py_BuildValue("ff", point.x, point.y));
            }
            return res;

            // InkList has 2-level lists --------------------------------------
            inklist:;
            res = PyList_New(0);
            for (i = 0; i < pdf_array_len(gctx, o); i++)
            {
                res1 = PyList_New(0);
                o1 = pdf_array_get(gctx, o, i);
                for (j = 0; j < pdf_array_len(gctx, o1); j += 2)
                {
                    point.x = pdf_to_real(gctx, pdf_array_get(gctx, o1, j));
                    point.y = pdf_to_real(gctx, pdf_array_get(gctx, o1, j+1));
                    point = fz_transform_point(point, page_ctm);
                    LIST_APPEND_DROP(res1, Py_BuildValue("ff", point.x, point.y));
                }
                LIST_APPEND_DROP(res, res1);
            }
            return res;
        }
SWIGINTERN PyObject *Annot_colors(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;
            return JM_annot_colors(gctx, annot->obj);
        }
SWIGINTERN PyObject *Annot__update_appearance(struct Annot *self,float opacity,char *blend_mode,PyObject *fill_color,int rotate){
            pdf_annot *annot = (pdf_annot *) self;
            int type = pdf_annot_type(gctx, annot);
            float fcol[4] = {1,1,1,1};  // std fill color: white
            int nfcol = 0;  // number of color components
            JM_color_FromSequence(fill_color, &nfcol, fcol);
            fz_try(gctx) {
                pdf_dirty_annot(gctx, annot); // enforce MuPDF /AP formatting
                if (type == PDF_ANNOT_FREE_TEXT) {
                    if (EXISTS(fill_color)) {
                        pdf_set_annot_color(gctx, annot, nfcol, fcol);
                    } else {
                        pdf_dict_del(gctx, annot->obj, PDF_NAME(IC));
                    }
                } else {
                    if (EXISTS(fill_color)) {
                        pdf_set_annot_interior_color(gctx, annot, nfcol, fcol);
                    } else if (fill_color != Py_None) {
                        pdf_dict_del(gctx, annot->obj, PDF_NAME(IC));
                    }
                }

                int insert_rot = (rotate >= 0) ? 1 : 0;
                switch (type) {
                    case PDF_ANNOT_CARET:
                    case PDF_ANNOT_CIRCLE:
                    case PDF_ANNOT_FREE_TEXT:
                    case PDF_ANNOT_FILE_ATTACHMENT:
                    case PDF_ANNOT_INK:
                    case PDF_ANNOT_LINE:
                    case PDF_ANNOT_POLY_LINE:
                    case PDF_ANNOT_POLYGON:
                    case PDF_ANNOT_SQUARE:
                    case PDF_ANNOT_STAMP:
                    case PDF_ANNOT_TEXT: break;
                    default: insert_rot = 0;
                }

                if (insert_rot)
                    pdf_dict_put_int(gctx, annot->obj, PDF_NAME(Rotate), rotate);
                annot->needs_new_ap = 1;  // re-create appearance stream
                pdf_update_annot(gctx, annot);  // update the annotation

            }
            fz_catch(gctx) {
                PySys_WriteStderr("cannot update annot: '%s'\n", fz_caught_message(gctx));
                Py_RETURN_FALSE;
            }

            if ((opacity < 0 || opacity >= 1) && !blend_mode)  // no opacity, no blend_mode
                Py_RETURN_TRUE;

            fz_try(gctx) {  // create or update /ExtGState
                pdf_obj *ap = pdf_dict_getl(gctx, annot->obj, PDF_NAME(AP),
                                        PDF_NAME(N), NULL);
                if (!ap)  // should never happen
                    THROWMSG(gctx, "annot has no /AP object");

                pdf_obj *resources = pdf_dict_get(gctx, ap, PDF_NAME(Resources));
                if (!resources) {  // no Resources yet: make one
                    resources = pdf_dict_put_dict(gctx, ap, PDF_NAME(Resources), 2);
                }
                pdf_obj *alp0 = pdf_new_dict(gctx, annot->page->doc, 3);
                if (opacity >= 0 && opacity < 1) {
                    pdf_dict_put_real(gctx, alp0, PDF_NAME(CA), (double) opacity);
                    pdf_dict_put_real(gctx, alp0, PDF_NAME(ca), (double) opacity);
                    pdf_dict_put_real(gctx, annot->obj, PDF_NAME(CA), (double) opacity);
                }
                if (blend_mode) {
                    pdf_dict_put_name(gctx, alp0, PDF_NAME(BM), blend_mode);
                    pdf_dict_put_name(gctx, annot->obj, PDF_NAME(BM), blend_mode);
                }
                pdf_obj *extg = pdf_dict_get(gctx, resources, PDF_NAME(ExtGState));
                if (!extg) {  // no ExtGState yet: make one
                    extg = pdf_dict_put_dict(gctx, resources, PDF_NAME(ExtGState), 2);
                }
                pdf_dict_put_drop(gctx, extg, PDF_NAME(H), alp0);
            }

            fz_catch(gctx) {
                PySys_WriteStderr("could not set opacity or blend mode\n");
                Py_RETURN_FALSE;
            }
            Py_RETURN_TRUE;
        }
SWIGINTERN void Annot_set_colors(struct Annot *self,PyObject *colors,PyObject *fill,PyObject *stroke){
            if (!PyDict_Check(colors)) return;
            pdf_annot *annot = (pdf_annot *) self;
            int type = pdf_annot_type(gctx, annot);
            PyObject *ccol, *icol;
            ccol = PyDict_GetItem(colors, dictkey_stroke);
            icol = PyDict_GetItem(colors, dictkey_fill);
            int i, n;
            float col[4];
            n = 0;
            if (EXISTS(ccol)) {
                JM_color_FromSequence(ccol, &n, col);
                fz_try(gctx) {
                    pdf_set_annot_color(gctx, annot, n, col);
                }
                fz_catch(gctx) {
                    JM_Warning("annot type has no stroke color");
                }
            } else if (ccol != Py_None) {
                pdf_dict_del(gctx, annot->obj, PDF_NAME(C));
            }
            n = 0;
            if (EXISTS(icol)) {
                JM_color_FromSequence(icol, &n, col);
                if (type != PDF_ANNOT_REDACT) {
                    fz_try(gctx)
                        pdf_set_annot_interior_color(gctx, annot, n, col);
                    fz_catch(gctx)
                        JM_Warning("annot type has no fill color");
                } else {
                    pdf_obj *arr = pdf_new_array(gctx, annot->page->doc, n);
                    for (i = 0; i < n; i++) {
                        pdf_array_push_real(gctx, arr, col[i]);
                    }
                    pdf_dict_put_drop(gctx, annot->obj, PDF_NAME(IC), arr);
                }
            } else if (icol != Py_None) {
                pdf_dict_del(gctx, annot->obj, PDF_NAME(IC));
            }
            return;
        }
SWIGINTERN PyObject *Annot_line_ends(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;

            // return nothing for invalid annot types
            if (!pdf_annot_has_line_ending_styles(gctx, annot))
                Py_RETURN_NONE;

            int lstart = (int) pdf_annot_line_start_style(gctx, annot);
            int lend = (int) pdf_annot_line_end_style(gctx, annot);
            return Py_BuildValue("ii", lstart, lend);
        }
SWIGINTERN void Annot_set_line_ends(struct Annot *self,int start,int end){
            pdf_annot *annot = (pdf_annot *) self;
            if (pdf_annot_has_line_ending_styles(gctx, annot))
                pdf_set_annot_line_ending_styles(gctx, annot, start, end);
            else
                JM_Warning("bad annot type for line ends");
        }
SWIGINTERN PyObject *Annot_type(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;
            int type = pdf_annot_type(gctx, annot);
            const char *c = pdf_string_from_annot_type(gctx, type);
            pdf_obj *o = pdf_dict_gets(gctx, annot->obj, "IT");
            if (!o || !pdf_is_name(gctx, o))
                return Py_BuildValue("is", type, c);         // no IT entry
            const char *it = pdf_to_name(gctx, o);
            return Py_BuildValue("iss", type, c, it);
        }
SWIGINTERN PyObject *Annot_opacity(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;
            double opy = -1;
            pdf_obj *ca = pdf_dict_get(gctx, annot->obj, PDF_NAME(CA));
            if (pdf_is_number(gctx, ca))
                opy = pdf_to_real(gctx, ca);
            return Py_BuildValue("f", opy);
        }
SWIGINTERN void Annot_set_opacity(struct Annot *self,float opacity){
            pdf_annot *annot = (pdf_annot *) self;
            if (!INRANGE(opacity, 0.0f, 1.0f))
            {
                pdf_set_annot_opacity(gctx, annot, 1);
                return;
            }
            pdf_set_annot_opacity(gctx, annot, opacity);
            if (opacity < 1.0f)
            {
                annot->page->transparency = 1;
            }
        }
SWIGINTERN PyObject *Annot_file_info(struct Annot *self){
            PyObject *res = PyDict_New();  // create Python dict
            char *filename = NULL;
            char *desc = NULL;
            int length = -1, size = -1;
            pdf_obj *stream = NULL, *o = NULL, *fs = NULL;
            pdf_annot *annot = (pdf_annot *) self;

            fz_try(gctx) {
                int type = (int) pdf_annot_type(gctx, annot);
                if (type != PDF_ANNOT_FILE_ATTACHMENT)
                    THROWMSG(gctx, "bad annot type");
                stream = pdf_dict_getl(gctx, annot->obj, PDF_NAME(FS),
                                   PDF_NAME(EF), PDF_NAME(F), NULL);
                if (!stream) THROWMSG(gctx, "bad PDF: file entry not found");
            }
            fz_catch(gctx) {
                return NULL;
            }

            fs = pdf_dict_get(gctx, annot->obj, PDF_NAME(FS));

            o = pdf_dict_get(gctx, fs, PDF_NAME(UF));
            if (o) {
                filename = (char *) pdf_to_text_string(gctx, o);
            } else {
                o = pdf_dict_get(gctx, fs, PDF_NAME(F));
                if (o) filename = (char *) pdf_to_text_string(gctx, o);
            }

            o = pdf_dict_get(gctx, fs, PDF_NAME(Desc));
            if (o) desc = (char *) pdf_to_text_string(gctx, o);

            o = pdf_dict_get(gctx, stream, PDF_NAME(Length));
            if (o) length = pdf_to_int(gctx, o);

            o = pdf_dict_getl(gctx, stream, PDF_NAME(Params),
                                PDF_NAME(Size), NULL);
            if (o) size = pdf_to_int(gctx, o);

            DICT_SETITEM_DROP(res, dictkey_filename, JM_EscapeStrFromStr(filename));
            DICT_SETITEM_DROP(res, dictkey_desc, JM_UnicodeFromStr(desc));
            DICT_SETITEM_DROP(res, dictkey_length, Py_BuildValue("i", length));
            DICT_SETITEM_DROP(res, dictkey_size, Py_BuildValue("i", size));
            return res;
        }
SWIGINTERN PyObject *Annot_get_file(struct Annot *self){
            PyObject *res = NULL;
            pdf_obj *stream = NULL;
            fz_buffer *buf = NULL;
            pdf_annot *annot = (pdf_annot *) self;
            fz_var(buf);
            fz_try(gctx) {
                int type = (int) pdf_annot_type(gctx, annot);
                if (type != PDF_ANNOT_FILE_ATTACHMENT)
                    THROWMSG(gctx, "bad annot type");
                stream = pdf_dict_getl(gctx, annot->obj, PDF_NAME(FS),
                                   PDF_NAME(EF), PDF_NAME(F), NULL);
                if (!stream) THROWMSG(gctx, "bad PDF: file entry not found");
                buf = pdf_load_stream(gctx, stream);
                res = JM_BinFromBuffer(gctx, buf);
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, buf);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return res;
        }
SWIGINTERN PyObject *Annot_get_sound(struct Annot *self){
            PyObject *res = NULL;
            PyObject *stream = NULL;
            fz_buffer *buf = NULL;
            pdf_obj *obj = NULL;
            pdf_annot *annot = (pdf_annot *) self;
            fz_var(buf);
            fz_try(gctx) {
                int type = (int) pdf_annot_type(gctx, annot);
                pdf_obj *sound = pdf_dict_get(gctx, annot->obj, PDF_NAME(Sound));
                if (type != PDF_ANNOT_SOUND || !sound)
                    THROWMSG(gctx, "bad annot type");
                if (pdf_dict_get(gctx, sound, PDF_NAME(F))) {
                    THROWMSG(gctx, "unsupported sound stream");
                }
                res = PyDict_New();
                obj = pdf_dict_get(gctx, sound, PDF_NAME(R));
                if (obj) {
                    DICT_SETITEMSTR_DROP(res, "rate",
                            Py_BuildValue("f", pdf_to_real(gctx, obj)));
                }
                obj = pdf_dict_get(gctx, sound, PDF_NAME(C));
                if (obj) {
                    DICT_SETITEMSTR_DROP(res, "channels",
                            Py_BuildValue("i", pdf_to_int(gctx, obj)));
                }
                obj = pdf_dict_get(gctx, sound, PDF_NAME(B));
                if (obj) {
                    DICT_SETITEMSTR_DROP(res, "bps",
                            Py_BuildValue("i", pdf_to_int(gctx, obj)));
                }
                obj = pdf_dict_get(gctx, sound, PDF_NAME(E));
                if (obj) {
                    DICT_SETITEMSTR_DROP(res, "encoding",
                            Py_BuildValue("s", pdf_to_name(gctx, obj)));
                }
                obj = pdf_dict_gets(gctx, sound, "CO");
                if (obj) {
                    DICT_SETITEMSTR_DROP(res, "compression",
                            Py_BuildValue("s", pdf_to_name(gctx, obj)));
                }
                buf = pdf_load_stream(gctx, sound);
                stream = JM_BinFromBuffer(gctx, buf);
                DICT_SETITEMSTR_DROP(res, "stream", stream);
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, buf);
            }
            fz_catch(gctx) {
                Py_CLEAR(res);
                return NULL;
            }
            return res;
        }
SWIGINTERN PyObject *Annot_update_file(struct Annot *self,PyObject *buffer,char *filename,char *ufilename,char *desc){
            pdf_document *pdf = NULL;       // to be filled in
            char *data = NULL;              // for new file content
            fz_buffer *res = NULL;          // for compressed content
            pdf_obj *stream = NULL, *fs = NULL;
            int64_t size = 0;
            pdf_annot *annot = (pdf_annot *) self;
            fz_try(gctx) {
                pdf = annot->page->doc;     // the owning PDF
                int type = (int) pdf_annot_type(gctx, annot);
                if (type != PDF_ANNOT_FILE_ATTACHMENT)
                    THROWMSG(gctx, "bad annot type");
                stream = pdf_dict_getl(gctx, annot->obj, PDF_NAME(FS),
                                   PDF_NAME(EF), PDF_NAME(F), NULL);
                // the object for file content
                if (!stream) THROWMSG(gctx, "bad PDF: no /EF object");

                fs = pdf_dict_get(gctx, annot->obj, PDF_NAME(FS));

                // file content given
                res = JM_BufferFromBytes(gctx, buffer);
                if (buffer && !res) THROWMSG(gctx, "bad type: 'buffer'");
                if (res) {
                    JM_update_stream(gctx, pdf, stream, res, 1);
                    // adjust /DL and /Size parameters
                    int64_t len = (int64_t) fz_buffer_storage(gctx, res, NULL);
                    pdf_obj *l = pdf_new_int(gctx, len);
                    pdf_dict_put(gctx, stream, PDF_NAME(DL), l);
                    pdf_dict_putl(gctx, stream, l, PDF_NAME(Params), PDF_NAME(Size), NULL);
                }

                if (filename) {
                    pdf_dict_put_text_string(gctx, stream, PDF_NAME(F), filename);
                    pdf_dict_put_text_string(gctx, fs, PDF_NAME(F), filename);
                    pdf_dict_put_text_string(gctx, stream, PDF_NAME(UF), filename);
                    pdf_dict_put_text_string(gctx, fs, PDF_NAME(UF), filename);
                    pdf_dict_put_text_string(gctx, annot->obj, PDF_NAME(Contents), filename);
                }

                if (ufilename) {
                    pdf_dict_put_text_string(gctx, stream, PDF_NAME(UF), ufilename);
                    pdf_dict_put_text_string(gctx, fs, PDF_NAME(UF), ufilename);
                }

                if (desc) {
                    pdf_dict_put_text_string(gctx, stream, PDF_NAME(Desc), desc);
                    pdf_dict_put_text_string(gctx, fs, PDF_NAME(Desc), desc);
                }
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdf->dirty = 1;
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot_info(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;
            PyObject *res = PyDict_New();
            pdf_obj *o;

            DICT_SETITEM_DROP(res, dictkey_content,
                          JM_UnicodeFromStr(pdf_annot_contents(gctx, annot)));

            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(Name));
            DICT_SETITEM_DROP(res, dictkey_name, JM_UnicodeFromStr(pdf_to_name(gctx, o)));

            // Title (= author)
            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(T));
            DICT_SETITEM_DROP(res, dictkey_title, JM_UnicodeFromStr(pdf_to_text_string(gctx, o)));

            // CreationDate
            o = pdf_dict_gets(gctx, annot->obj, "CreationDate");
            DICT_SETITEM_DROP(res, dictkey_creationDate,
                          JM_UnicodeFromStr(pdf_to_text_string(gctx, o)));

            // ModDate
            o = pdf_dict_get(gctx, annot->obj, PDF_NAME(M));
            DICT_SETITEM_DROP(res, dictkey_modDate, JM_UnicodeFromStr(pdf_to_text_string(gctx, o)));

            // Subj
            o = pdf_dict_gets(gctx, annot->obj, "Subj");
            DICT_SETITEM_DROP(res, dictkey_subject,
                          Py_BuildValue("s",pdf_to_text_string(gctx, o)));

            // Identification (PDF key /NM)
            o = pdf_dict_gets(gctx, annot->obj, "NM");
            DICT_SETITEM_DROP(res, dictkey_id,
                          JM_UnicodeFromStr(pdf_to_text_string(gctx, o)));

            return res;
        }
SWIGINTERN PyObject *Annot_set_info(struct Annot *self,PyObject *info,char *content,char *title,char *creationDate,char *modDate,char *subject){
            pdf_annot *annot = (pdf_annot *) self;
            // use this to indicate a 'markup' annot type
            int is_markup = pdf_annot_has_author(gctx, annot);
            fz_try(gctx) {
                // contents
                if (content)
                    pdf_set_annot_contents(gctx, annot, content);

                if (is_markup) {
                    // title (= author)
                    if (title)
                        pdf_set_annot_author(gctx, annot, title);

                    // creation date
                    if (creationDate)
                        pdf_dict_put_text_string(gctx, annot->obj,
                                                 PDF_NAME(CreationDate), creationDate);

                    // mod date
                    if (modDate)
                        pdf_dict_put_text_string(gctx, annot->obj,
                                                 PDF_NAME(M), modDate);

                    // subject
                    if (subject)
                        pdf_dict_puts_drop(gctx, annot->obj, "Subj",
                                           pdf_new_text_string(gctx, subject));
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Annot_border(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;
            return JM_annot_border(gctx, annot->obj);
        }
SWIGINTERN PyObject *Annot_set_border(struct Annot *self,PyObject *border,float width,char *style,PyObject *dashes){
            pdf_annot *annot = (pdf_annot *) self;
            return JM_annot_set_border(gctx, border, annot->page->doc, annot->obj);
        }
SWIGINTERN int Annot_flags(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;
            return pdf_annot_flags(gctx, annot);
        }
SWIGINTERN PyObject *Annot_clean_contents(struct Annot *self,int sanitize){
            pdf_annot *annot = (pdf_annot *) self;
            pdf_filter_options filter = {
                NULL,  // opaque
                NULL,  // image filter
                NULL,  // text filter
                NULL,  // after text
                NULL,  // end page
                1,     // recurse: true
                1,     // instance forms
                1,     // sanitize,
                0      // do not ascii-escape binary data
                };
            filter.sanitize = sanitize;
            fz_try(gctx) {
                pdf_filter_annot_contents(gctx, annot->page->doc, annot, &filter);
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdf_dirty_annot(gctx, annot);
            Py_RETURN_NONE;
        }
SWIGINTERN void Annot_set_flags(struct Annot *self,int flags){
            pdf_annot *annot = (pdf_annot *) self;
            pdf_set_annot_flags(gctx, annot, flags);
        }
SWIGINTERN PyObject *Annot_delete_responses(struct Annot *self){
            pdf_annot *annot = (pdf_annot *) self;
            pdf_page *page = annot->page;
            pdf_annot *irt_annot = NULL;
            fz_try(gctx) {
                while (1) {
                    irt_annot = JM_find_annot_irt(gctx, annot);
                    if (!irt_annot)
                        break;
                    JM_delete_annot(gctx, page, irt_annot);
                }
                pdf_dict_del(gctx, annot->obj, PDF_NAME(Popup));
                pdf_obj *annots = pdf_dict_get(gctx, page->obj, PDF_NAME(Annots));
                int i, n = pdf_array_len(gctx, annots), found = 0;
                for (i = n - 1; i >= 0; i--) {
                    pdf_obj *o = pdf_array_get(gctx, annots, i);
                    pdf_obj *p = pdf_dict_get(gctx, o, PDF_NAME(Parent));
                    if (!p)
                        continue;
                    if (!pdf_objcmp(gctx, p, annot->obj)) {
                        pdf_array_delete(gctx, annots, i);
                        found = 1;
                    }
                }
                if (found > 0) {
                    pdf_dict_put(gctx, page->obj, PDF_NAME(Annots), annots);
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            pdf_dirty_annot(gctx, annot);
            Py_RETURN_NONE;
        }
SWIGINTERN struct Annot *Annot_next(struct Annot *self){
            pdf_annot *this_annot = (pdf_annot *) self;
            int type = pdf_annot_type(gctx, this_annot);
            pdf_annot *annot;

            if (type != PDF_ANNOT_WIDGET) {
                annot = pdf_next_annot(gctx, this_annot);
            } else {
                annot = (pdf_widget *) pdf_next_widget(gctx, (pdf_widget *) this_annot);
            }

            if (annot)
                pdf_keep_annot(gctx, annot);
            return (struct Annot *) annot;
        }
SWIGINTERN struct Pixmap *Annot_get_pixmap(struct Annot *self,PyObject *matrix,struct Colorspace *colorspace,int alpha){
            fz_matrix ctm = JM_matrix_from_py(matrix);
            fz_colorspace *cs = (fz_colorspace *) colorspace;
            fz_pixmap *pix = NULL;
            if (!cs) {
                cs = fz_device_rgb(gctx);
            }

            fz_try(gctx) {
                pix = pdf_new_pixmap_from_annot(gctx, (pdf_annot *) self, ctm, cs, NULL, alpha);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Pixmap *) pix;
        }
SWIGINTERN void delete_Link(struct Link *self){
            DEBUGMSG1("Link");
            fz_drop_link(gctx, (fz_link *) self);
            DEBUGMSG2;
        }
SWIGINTERN PyObject *Link__border(struct Link *self,struct Document *doc,int xref){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) doc);
            if (!pdf) Py_RETURN_NONE;
            pdf_obj *link_obj = pdf_new_indirect(gctx, pdf, xref, 0);
            if (!link_obj) Py_RETURN_NONE;
            PyObject *b = JM_annot_border(gctx, link_obj);
            pdf_drop_obj(gctx, link_obj);
            return b;
        }
SWIGINTERN PyObject *Link__setBorder(struct Link *self,PyObject *border,struct Document *doc,int xref){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) doc);
            if (!pdf) Py_RETURN_NONE;
            pdf_obj *link_obj = pdf_new_indirect(gctx, pdf, xref, 0);
            if (!link_obj) Py_RETURN_NONE;
            PyObject *b = JM_annot_set_border(gctx, border, pdf, link_obj);
            pdf_drop_obj(gctx, link_obj);
            return b;
        }
SWIGINTERN PyObject *Link__colors(struct Link *self,struct Document *doc,int xref){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) doc);
            if (!pdf) Py_RETURN_NONE;
            pdf_obj *link_obj = pdf_new_indirect(gctx, pdf, xref, 0);
            if (!link_obj) Py_RETURN_NONE;
            PyObject *b = JM_annot_colors(gctx, link_obj);
            pdf_drop_obj(gctx, link_obj);
            return b;
        }
SWIGINTERN PyObject *Link__setColors(struct Link *self,PyObject *colors,struct Document *doc,int xref){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) doc);
            pdf_obj *arr = NULL;
            int i;
            if (!pdf) Py_RETURN_NONE;
            if (!PyDict_Check(colors)) Py_RETURN_NONE;
            float scol[4] = {0.0f, 0.0f, 0.0f, 0.0f};
            int nscol = 0;
            float fcol[4] = {0.0f, 0.0f, 0.0f, 0.0f};
            int nfcol = 0;
            PyObject *stroke = PyDict_GetItem(colors, dictkey_stroke);
            PyObject *fill = PyDict_GetItem(colors, dictkey_fill);
            JM_color_FromSequence(stroke, &nscol, scol);
            JM_color_FromSequence(fill, &nfcol, fcol);
            if (!nscol && !nfcol) Py_RETURN_NONE;
            pdf_obj *link_obj = pdf_new_indirect(gctx, pdf, xref, 0);
            if (!link_obj) Py_RETURN_NONE;
            if (nscol > 0)
            {
                arr = pdf_new_array(gctx, pdf, nscol);
                for (i = 0; i < nscol; i++)
                    pdf_array_push_real(gctx, arr, scol[i]);
                pdf_dict_put_drop(gctx, link_obj, PDF_NAME(C), arr);
            }
            if (nfcol > 0) JM_Warning("this annot type has no fill color)");
            pdf_drop_obj(gctx, link_obj);
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Link_uri(struct Link *self){
            fz_link *this_link = (fz_link *) self;
            return JM_UnicodeFromStr(this_link->uri);
        }
SWIGINTERN PyObject *Link_isExternal(struct Link *self){
            fz_link *this_link = (fz_link *) self;
            if (!this_link->uri) Py_RETURN_FALSE;
            return JM_BOOL(fz_is_external_link(gctx, this_link->uri));
        }
SWIGINTERN PyObject *Link_rect(struct Link *self){
            fz_link *this_link = (fz_link *) self;
            return JM_py_from_rect(this_link->rect);
        }
SWIGINTERN struct Link *Link_next(struct Link *self){
            fz_link *this_link = (fz_link *) self;
            fz_link *next_link = this_link->next;
            if (!next_link) return NULL;
            next_link = fz_keep_link(gctx, next_link);
            return (struct Link *) next_link;
        }
SWIGINTERN void delete_DisplayList(struct DisplayList *self){
            DEBUGMSG1("DisplayList");
            fz_drop_display_list(gctx, (fz_display_list *) self);
            DEBUGMSG2;
        }
SWIGINTERN struct DisplayList *new_DisplayList(PyObject *mediabox){
            fz_display_list *dl = NULL;
            fz_try(gctx) {
                dl = fz_new_display_list(gctx, JM_rect_from_py(mediabox));
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct DisplayList *) dl;
        }
SWIGINTERN PyObject *DisplayList_run(struct DisplayList *self,struct DeviceWrapper *dw,PyObject *m,PyObject *area){
            fz_try(gctx) {
                fz_run_display_list(gctx, (fz_display_list *) self, dw->device,
                    JM_matrix_from_py(m), JM_rect_from_py(area), NULL);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *DisplayList_rect(struct DisplayList *self){
            return JM_py_from_rect(fz_bound_display_list(gctx, (fz_display_list *) self));
        }
SWIGINTERN struct Pixmap *DisplayList_get_pixmap(struct DisplayList *self,PyObject *matrix,struct Colorspace *colorspace,int alpha,PyObject *clip){
            fz_colorspace *cs = NULL;
            fz_pixmap *pix = NULL;

            if (colorspace) cs = (fz_colorspace *) colorspace;
            else cs = fz_device_rgb(gctx);

            fz_try(gctx) {
                pix = JM_pixmap_from_display_list(gctx,
                          (fz_display_list *) self, matrix, cs,
                           alpha, clip, NULL);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Pixmap *) pix;
        }
SWIGINTERN struct TextPage *DisplayList_get_textpage(struct DisplayList *self,int flags){
            fz_display_list *this_dl = (fz_display_list *) self;
            fz_stext_page *tp = NULL;
            fz_try(gctx) {
                fz_stext_options stext_options = { 0 };
                stext_options.flags = flags;
                tp = fz_new_stext_page_from_display_list(gctx, this_dl, &stext_options);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct TextPage *) tp;
        }
SWIGINTERN void delete_TextPage(struct TextPage *self){
            DEBUGMSG1("TextPage");
            fz_drop_stext_page(gctx, (fz_stext_page *) self);
            DEBUGMSG2;
        }
SWIGINTERN struct TextPage *new_TextPage(PyObject *mediabox){
            fz_stext_page *tp = NULL;
            fz_try(gctx) {
                tp = fz_new_stext_page(gctx, JM_rect_from_py(mediabox));
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct TextPage *) tp;
        }
SWIGINTERN PyObject *TextPage_search(struct TextPage *self,char const *needle,int hit_max,int quads){
            PyObject *liste = NULL;
            fz_try(gctx) {
                liste = JM_search_stext_page(gctx, (fz_stext_page *) self, needle);
            }
            fz_always(gctx) {
                ;
            }
            fz_catch(gctx) {
                return NULL;
            }
            return liste;
        }
SWIGINTERN PyObject *TextPage__getNewBlockList(struct TextPage *self,PyObject *page_dict,int raw){
            fz_try(gctx) {
                JM_make_textpage_dict(gctx, (fz_stext_page *) self, page_dict, raw);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *TextPage_extractIMGINFO(struct TextPage *self,int hashes){
            fz_stext_block *block;
            int block_n = -1;
            fz_stext_page *this_tpage = (fz_stext_page *) self;
            PyObject *rc = NULL, *block_dict = NULL;
            fz_pixmap *pix = NULL;
            fz_try(gctx) {
                rc = PyList_New(0);
                for (block = this_tpage->first_block; block; block = block->next) {
                    block_n++;
                    if (block->type == FZ_STEXT_BLOCK_TEXT) {
                        continue;
                    }
                    unsigned char digest[16];
                    fz_image *img = block->u.i.image;
                    if (hashes) {
                        pix = fz_get_pixmap_from_image(gctx, img, NULL, NULL, NULL, NULL);
                        fz_md5_pixmap(gctx, pix, digest);
                        fz_drop_pixmap(gctx, pix);
                        pix = NULL;
                    }
                    fz_colorspace *cs = img->colorspace;
                    block_dict = PyDict_New();
                    DICT_SETITEM_DROP(block_dict, dictkey_number, Py_BuildValue("i", block_n));
                    DICT_SETITEM_DROP(block_dict, dictkey_bbox,
                                    JM_py_from_rect(block->bbox));
                    DICT_SETITEM_DROP(block_dict, dictkey_matrix,
                                    JM_py_from_matrix(block->u.i.transform));
                    DICT_SETITEM_DROP(block_dict, dictkey_width,
                                    Py_BuildValue("i", img->w));
                    DICT_SETITEM_DROP(block_dict, dictkey_height,
                                    Py_BuildValue("i", img->h));
                    DICT_SETITEM_DROP(block_dict, dictkey_colorspace,
                                    Py_BuildValue("i",
                                    fz_colorspace_n(gctx, cs)));
                    DICT_SETITEM_DROP(block_dict, dictkey_cs_name,
                                    Py_BuildValue("s",
                                    fz_colorspace_name(gctx, cs)));
                    DICT_SETITEM_DROP(block_dict, dictkey_xres,
                                    Py_BuildValue("i", img->xres));
                    DICT_SETITEM_DROP(block_dict, dictkey_yres,
                                    Py_BuildValue("i", img->xres));
                    DICT_SETITEM_DROP(block_dict, dictkey_bpc,
                                    Py_BuildValue("i", (int) img->bpc));
                    DICT_SETITEM_DROP(block_dict, dictkey_size,
                                    Py_BuildValue("n", (Py_ssize_t) fz_image_size(gctx, img)));
                    if (hashes) {
                        DICT_SETITEMSTR_DROP(block_dict, "digest",
                                    PyBytes_FromStringAndSize(digest, 16));
                    }
                    LIST_APPEND_DROP(rc, block_dict);
                }
            }
            fz_always(gctx) {
            }
            fz_catch(gctx) {
                Py_CLEAR(rc);
                Py_CLEAR(block_dict);
                fz_drop_pixmap(gctx, pix);
                return NULL;
            }
            return rc;
        }
SWIGINTERN PyObject *TextPage_extractBLOCKS(struct TextPage *self){
            fz_stext_block *block;
            fz_stext_line *line;
            fz_stext_char *ch;
            int block_n = -1;
            PyObject *text = NULL, *litem;
            fz_buffer *res = NULL;
            fz_var(res);
            fz_stext_page *this_tpage = (fz_stext_page *) self;
            fz_rect tp_rect = this_tpage->mediabox;
            PyObject *lines = NULL;
            fz_try(gctx) {
                res = fz_new_buffer(gctx, 1024);
                lines = PyList_New(0);
                for (block = this_tpage->first_block; block; block = block->next) {
                    block_n++;
                    fz_rect blockrect = fz_empty_rect;
                    if (block->type == FZ_STEXT_BLOCK_TEXT) {
                        fz_clear_buffer(gctx, res);  // set text buffer to empty
                        int line_n = -1;
                        float last_y0 = 0.0;
                        int last_char = 0;
                        for (line = block->u.t.first_line; line; line = line->next) {
                            line_n++;
                            fz_rect linerect = fz_empty_rect;
                            for (ch = line->first_char; ch; ch = ch->next) {
                                fz_rect cbbox = JM_char_bbox(gctx, line, ch);
                                if (!fz_contains_rect(tp_rect, cbbox) &&
                                    !fz_is_infinite_rect(tp_rect)) {
                                    continue;
                                }
                                JM_append_rune(gctx, res, ch->c);
                                last_char = ch->c;
                                linerect = fz_union_rect(linerect, cbbox);
                            }
                            if (last_char != 10) {
                                fz_append_byte(gctx, res, 10);
                            }
                            blockrect = fz_union_rect(blockrect, linerect);
                        }
                        text = JM_EscapeStrFromBuffer(gctx, res);
                    } else if (fz_contains_rect(tp_rect, block->bbox) || fz_is_infinite_rect(tp_rect)) {
                        fz_image *img = block->u.i.image;
                        fz_colorspace *cs = img->colorspace;
                        text = PyUnicode_FromFormat("<image: %s, width: %d, height: %d, bpc: %d>", fz_colorspace_name(gctx, cs), img->w, img->h, img->bpc);
                        blockrect = fz_union_rect(blockrect, block->bbox);
                    }
                    if (!fz_is_empty_rect(blockrect)) {
                        litem = PyTuple_New(7);
                        PyTuple_SET_ITEM(litem, 0, Py_BuildValue("f", blockrect.x0));
                        PyTuple_SET_ITEM(litem, 1, Py_BuildValue("f", blockrect.y0));
                        PyTuple_SET_ITEM(litem, 2, Py_BuildValue("f", blockrect.x1));
                        PyTuple_SET_ITEM(litem, 3, Py_BuildValue("f", blockrect.y1));
                        PyTuple_SET_ITEM(litem, 4, Py_BuildValue("O", text));
                        PyTuple_SET_ITEM(litem, 5, Py_BuildValue("i", block_n));
                        PyTuple_SET_ITEM(litem, 6, Py_BuildValue("i", block->type));
                        LIST_APPEND_DROP(lines, litem);
                    }
                    Py_CLEAR(text);
                }
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
                PyErr_Clear();
            }
            fz_catch(gctx) {
                Py_CLEAR(lines);
                return NULL;
            }
            return lines;
        }
SWIGINTERN PyObject *TextPage_extractWORDS(struct TextPage *self){
            fz_stext_block *block;
            fz_stext_line *line;
            fz_stext_char *ch;
            fz_buffer *buff = NULL;
            fz_var(buff);
            size_t buflen = 0;
            int block_n = -1, line_n, word_n;
            fz_rect wbbox = {0,0,0,0};  // word bbox
            fz_stext_page *this_tpage = (fz_stext_page *) self;
            fz_rect tp_rect = this_tpage->mediabox;

            PyObject *lines = NULL;
            fz_try(gctx) {
                buff = fz_new_buffer(gctx, 64);
                lines = PyList_New(0);
                for (block = this_tpage->first_block; block; block = block->next) {
                    block_n++;
                    if (block->type != FZ_STEXT_BLOCK_TEXT) {
                        continue;
                    }
                    line_n = 0;
                    for (line = block->u.t.first_line; line; line = line->next) {
                        word_n = 0;                       // word counter per line
                        fz_clear_buffer(gctx, buff);      // reset word buffer
                        buflen = 0;                       // reset char counter
                        for (ch = line->first_char; ch; ch = ch->next) {
                            fz_rect cbbox = JM_char_bbox(gctx, line, ch);
                            if (!fz_contains_rect(tp_rect, cbbox) &&
                                !fz_is_infinite_rect(tp_rect)) {
                                continue;
                            }
                            if (ch->c == 32 && buflen == 0)
                                continue;  // skip spaces at line start
                            if (ch->c == 32) {
                                word_n = JM_append_word(gctx, lines, buff, &wbbox,
                                                        block_n, line_n, word_n);
                                fz_clear_buffer(gctx, buff);
                                buflen = 0;  // reset char counter
                                continue;
                            }
                            // append one unicode character to the word
                            JM_append_rune(gctx, buff, ch->c);
                            buflen++;
                            // enlarge word bbox
                            wbbox = fz_union_rect(wbbox, JM_char_bbox(gctx, line, ch));
                        }
                        if (buflen) {
                            word_n = JM_append_word(gctx, lines, buff, &wbbox,
                                                    block_n, line_n, word_n);
                            fz_clear_buffer(gctx, buff);
                            buflen = 0;
                        }
                        line_n++;
                    }
                }
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, buff);
                PyErr_Clear();
            }
            fz_catch(gctx) {
                return NULL;
            }
            return lines;
        }
SWIGINTERN PyObject *TextPage_rect(struct TextPage *self){
            fz_stext_page *this_tpage = (fz_stext_page *) self;
            fz_rect mediabox = this_tpage->mediabox;
            return JM_py_from_rect(mediabox);
        }
SWIGINTERN PyObject *TextPage__extractText(struct TextPage *self,int format){
            fz_buffer *res = NULL;
            fz_output *out = NULL;
            PyObject *text = NULL;
            fz_var(res);
            fz_var(out);
            fz_stext_page *this_tpage = (fz_stext_page *) self;
            fz_try(gctx) {
                res = fz_new_buffer(gctx, 1024);
                out = fz_new_output_with_buffer(gctx, res);
                switch(format) {
                    case(1):
                        fz_print_stext_page_as_html(gctx, out, this_tpage, 0);
                        break;
                    case(3):
                        fz_print_stext_page_as_xml(gctx, out, this_tpage, 0);
                        break;
                    case(4):
                        fz_print_stext_page_as_xhtml(gctx, out, this_tpage, 0);
                        break;
                    default:
                        JM_print_stext_page_as_text(gctx, out, this_tpage);
                        break;
                }
                text = JM_UnicodeFromBuffer(gctx, res);

            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
                fz_drop_output(gctx, out);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return text;
        }
SWIGINTERN PyObject *TextPage_extractSelection(struct TextPage *self,PyObject *pointa,PyObject *pointb){
            fz_stext_page *this_tpage = (fz_stext_page *) self;
            fz_point a = JM_point_from_py(pointa);
            fz_point b = JM_point_from_py(pointb);
            char *found = fz_copy_selection(gctx, this_tpage, a, b, 0);
            PyObject *rc = NULL;
            if (found) {
                rc = PyUnicode_FromString(found);
                JM_Free(found);
            } else {
                rc = EMPTY_STRING;
            }
            return rc;
        }
SWIGINTERN void delete_Graftmap(struct Graftmap *self){
            DEBUGMSG1("Graftmap");
            pdf_drop_graft_map(gctx, (pdf_graft_map *) self);
            DEBUGMSG2;
        }
SWIGINTERN struct Graftmap *new_Graftmap(struct Document *doc){
            pdf_graft_map *map = NULL;
            fz_try(gctx) {
                pdf_document *dst = pdf_specifics(gctx, (fz_document *) doc);
                ASSERT_PDF(dst);
                map = pdf_new_graft_map(gctx, dst);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Graftmap *) pdf_keep_graft_map(gctx, map);
        }
SWIGINTERN void delete_TextWriter(struct TextWriter *self){
            DEBUGMSG1("TextWriter");
            fz_drop_text(gctx, (fz_text *) self);
            DEBUGMSG2;
        }
SWIGINTERN struct TextWriter *new_TextWriter(PyObject *page_rect,float opacity,PyObject *color){
            fz_text *text = NULL;
            fz_try(gctx) {
                text = fz_new_text(gctx);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct TextWriter *) text;
        }
SWIGINTERN PyObject *TextWriter_append(struct TextWriter *self,PyObject *pos,char *text,struct Font *font,float fontsize,char *language,int right_to_left){
            fz_text_language lang = fz_text_language_from_string(language);
            fz_point p = JM_point_from_py(pos);
            fz_matrix trm = fz_make_matrix(fontsize, 0, 0, fontsize, p.x, p.y);
            int markup_dir = 0, wmode = 0;
            fz_try(gctx) {
                trm = fz_show_string(gctx, (fz_text *) self, (fz_font *) font, trm, text, wmode, right_to_left, markup_dir, lang);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return JM_py_from_matrix(trm);
        }
SWIGINTERN PyObject *TextWriter__bbox(struct TextWriter *self){
            return JM_py_from_rect(fz_bound_text(gctx, (fz_text *) self, NULL, fz_identity));
        }
SWIGINTERN PyObject *TextWriter_write_text(struct TextWriter *self,struct Page *page,PyObject *color,float opacity,int overlay,PyObject *morph,PyObject *matrix,int render_mode,int oc){
            pdf_page *pdfpage = pdf_page_from_fz_page(gctx, (fz_page *) page);
            fz_rect mediabox = fz_bound_page(gctx, (fz_page *) page);
            pdf_obj *resources = NULL;
            fz_buffer *contents = NULL;
            fz_device *dev = NULL;
            PyObject *result = NULL, *max_nums, *cont_string;
            float alpha = 1;
            if (opacity >= 0 && opacity < 1)
                alpha = opacity;
            fz_colorspace *colorspace;
            int ncol = 1;
            float dev_color[4] = {0, 0, 0, 0};
            if (color) JM_color_FromSequence(color, &ncol, dev_color);
            switch(ncol) {
                case 3: colorspace = fz_device_rgb(gctx); break;
                case 4: colorspace = fz_device_cmyk(gctx); break;
                default: colorspace = fz_device_gray(gctx); break;
            }

            fz_try(gctx) {
                ASSERT_PDF(pdfpage);
                resources = pdf_new_dict(gctx, pdfpage->doc, 5);
                contents = fz_new_buffer(gctx, 1024);
                dev = pdf_new_pdf_device(gctx, pdfpage->doc, fz_identity,
                            mediabox, resources, contents);
                fz_fill_text(gctx, dev, (fz_text *) self, fz_identity,
                    colorspace, dev_color, alpha, fz_default_color_params);
                fz_close_device(gctx, dev);

                // copy generated resources into the one of the page
                max_nums = JM_merge_resources(gctx, pdfpage, resources);
                cont_string = JM_EscapeStrFromBuffer(gctx, contents);
                result = Py_BuildValue("OO", max_nums, cont_string);
                Py_DECREF(cont_string);
                Py_DECREF(max_nums);
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, contents);
                pdf_drop_obj(gctx, resources);
                fz_drop_device(gctx, dev);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return result;
        }
SWIGINTERN void delete_Font(struct Font *self){
            DEBUGMSG1("Font");
            fz_drop_font(gctx, (fz_font *) self);
            DEBUGMSG2;
        }
SWIGINTERN struct Font *new_Font(char *fontname,char *fontfile,PyObject *fontbuffer,int script,char *language,int ordering,int is_bold,int is_italic,int is_serif){
            fz_font *font = NULL;
            fz_try(gctx) {
                fz_text_language lang = fz_text_language_from_string(language);
                font = JM_get_font(gctx, fontname, fontfile,
                           fontbuffer, script, lang, ordering,
                           is_bold, is_italic, is_serif);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return (struct Font *) font;
        }
SWIGINTERN float Font_glyph_advance(struct Font *self,int chr,char *language,int script,int wmode){
            fz_font *font;
            fz_text_language lang = fz_text_language_from_string(language);
            int gid = fz_encode_character_with_fallback(gctx, (fz_font *) self, chr, script, lang, &font);
            return fz_advance_glyph(gctx, font, gid, wmode);
        }
SWIGINTERN PyObject *Font_glyph_bbox(struct Font *self,int chr,char *language,int script){
            fz_font *font;
            fz_text_language lang = fz_text_language_from_string(language);
            int gid = fz_encode_character_with_fallback(gctx, (fz_font *) self, chr, script, lang, &font);
            return JM_py_from_rect(fz_bound_glyph(gctx, font, gid, fz_identity));
        }
SWIGINTERN PyObject *Font_has_glyph(struct Font *self,int chr,char *language,int script,int fallback){
            fz_font *font;
            fz_text_language lang;
            int gid = 0;
            if (fallback) {
                lang = fz_text_language_from_string(language);
                gid = fz_encode_character_with_fallback(gctx, (fz_font *) self, chr, script, lang, &font);
            } else {
                gid = fz_encode_character(gctx, (fz_font *) self, chr);
            }
            return Py_BuildValue("i", gid);
        }
SWIGINTERN void Font__valid_unicodes(struct Font *self,PyObject *arr){
            fz_font *font = (fz_font *) self;
            PyObject *temp = PySequence_ITEM(arr, 0);
            void *ptr = PyLong_AsVoidPtr(temp);
            JM_valid_chars(gctx, font, ptr);
            Py_DECREF(temp);
        }
SWIGINTERN PyObject *Font_flags(struct Font *self){
            fz_font_flags_t *f = fz_font_flags((fz_font *) self);
            if (!f) Py_RETURN_NONE;
            return Py_BuildValue("{s:i,s:i,s:i,s:i,s:i,s:i,s:i,s:i,s:i,s:i}",
            "mono", f->is_mono, "serif", f->is_serif, "bold", f->is_bold,
            "italic", f->is_italic, "substitute", f->ft_substitute,
            "stretch", f->ft_stretch, "fake-bold", f->fake_bold,
            "fake-italic", f->fake_italic, "opentype", f->has_opentype,
            "invalid-bbox", f->invalid_bbox);
        }
SWIGINTERN PyObject *Font_is_writable(struct Font *self){
            fz_font *font = (fz_font *) self;
            if (fz_font_t3_procs(gctx, font) ||
                fz_font_flags(font)->ft_substitute ||
                !pdf_font_writing_supported(font)) {
                Py_RETURN_FALSE;
            }
            Py_RETURN_TRUE;
        }
SWIGINTERN PyObject *Font_name(struct Font *self){
            return JM_UnicodeFromStr(fz_font_name(gctx, (fz_font *) self));
        }
SWIGINTERN int Font_glyph_count(struct Font *self){
            fz_font *this_font = (fz_font *) self;
            return this_font->glyph_count;
        }
SWIGINTERN PyObject *Font_buffer(struct Font *self){
            fz_font *this_font = (fz_font *) self;
            unsigned char *data = NULL;
            size_t len = fz_buffer_storage(gctx, this_font->buffer, &data);
            return JM_BinFromCharSize(data, len);
        }
SWIGINTERN PyObject *Font_bbox(struct Font *self){
            fz_font *this_font = (fz_font *) self;
            return JM_py_from_rect(fz_font_bbox(gctx, this_font));
        }
SWIGINTERN float Font_ascender(struct Font *self){
            return fz_font_ascender(gctx, (fz_font *) self);
        }
SWIGINTERN float Font_descender(struct Font *self){
            return fz_font_descender(gctx, (fz_font *) self);
        }
SWIGINTERN PyObject *Tools_gen_id(struct Tools *self){
            JM_UNIQUE_ID += 1;
            if (JM_UNIQUE_ID < 0) JM_UNIQUE_ID = 1;
            return Py_BuildValue("i", JM_UNIQUE_ID);
        }
SWIGINTERN PyObject *Tools_set_icc(struct Tools *self,int on){
            fz_try(gctx) {
                if (on) {
                    if (FZ_ENABLE_ICC)
                        fz_enable_icc(gctx);
                    else
                        THROWMSG(gctx, "MuPDF generated without ICC suppot.");
                } else if (FZ_ENABLE_ICC) {
                    fz_disable_icc(gctx);
                }
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN char *Tools_set_annot_stem(struct Tools *self,char *stem){
            if (!stem) {
                return JM_annot_id_stem;
            }
            size_t len = strlen(stem) + 1;
            if (len > 50) len = 50;
            memcpy(&JM_annot_id_stem, stem, len);
            return JM_annot_id_stem;
        }
SWIGINTERN PyObject *Tools_set_small_glyph_heights(struct Tools *self,PyObject *on){
            if (!on || on == Py_None) {
                return JM_BOOL(small_glyph_heights);
            }
            if (PyObject_IsTrue(on)) {
                small_glyph_heights = 1;
            } else {
                small_glyph_heights = 0;
            }
            return JM_BOOL(small_glyph_heights);
        }
SWIGINTERN PyObject *Tools_set_subset_fontnames(struct Tools *self,PyObject *on){
            if (!on || on == Py_None) {
                return JM_BOOL(subset_fontnames);
            }
            if (PyObject_IsTrue(on)) {
                subset_fontnames = 1;
            } else {
                subset_fontnames = 0;
            }
            return JM_BOOL(subset_fontnames);
        }
SWIGINTERN PyObject *Tools_unset_quad_corrections(struct Tools *self,PyObject *on){
            if (!on || on == Py_None) {
                return JM_BOOL(skip_quad_corrections);
            }
            if (PyObject_IsTrue(on)) {
                skip_quad_corrections = 1;
            } else {
                skip_quad_corrections = 0;
            }
            return JM_BOOL(skip_quad_corrections);
        }
SWIGINTERN PyObject *Tools_store_shrink(struct Tools *self,int percent){
            if (percent >= 100) {
                fz_empty_store(gctx);
                return Py_BuildValue("i", 0);
            }
            if (percent > 0) fz_shrink_store(gctx, 100 - percent);
            return Py_BuildValue("i", (int) gctx->store->size);
        }
SWIGINTERN PyObject *Tools_store_size(struct Tools *self){
            return Py_BuildValue("i", (int) gctx->store->size);
        }
SWIGINTERN PyObject *Tools_store_maxsize(struct Tools *self){
            return Py_BuildValue("i", (int) gctx->store->max);
        }
SWIGINTERN PyObject *Tools_show_aa_level(struct Tools *self){
            return Py_BuildValue("iif",
                fz_graphics_aa_level(gctx),
                fz_text_aa_level(gctx),
                fz_graphics_min_line_width(gctx));
        }
SWIGINTERN void Tools_set_aa_level(struct Tools *self,int level){
            fz_set_aa_level(gctx, level);
        }
SWIGINTERN void Tools_set_graphics_min_line_width(struct Tools *self,float min_line_width){
            fz_set_graphics_min_line_width(gctx, min_line_width);
        }
SWIGINTERN PyObject *Tools_image_profile(struct Tools *self,PyObject *stream,int keep_image){
            PyObject *rc = NULL;
            fz_try(gctx) {
                rc = JM_image_profile(gctx, stream, keep_image);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return rc;
        }
SWIGINTERN PyObject *Tools__rotate_matrix(struct Tools *self,struct Page *page){
            pdf_page *pdfpage = pdf_page_from_fz_page(gctx, (fz_page *) page);
            if (!pdfpage) return JM_py_from_matrix(fz_identity);
            return JM_py_from_matrix(JM_rotate_page_matrix(gctx, pdfpage));
        }
SWIGINTERN PyObject *Tools__derotate_matrix(struct Tools *self,struct Page *page){
            pdf_page *pdfpage = pdf_page_from_fz_page(gctx, (fz_page *) page);
            if (!pdfpage) return JM_py_from_matrix(fz_identity);
            return JM_py_from_matrix(JM_derotate_page_matrix(gctx, pdfpage));
        }
SWIGINTERN PyObject *Tools_fitz_config(struct Tools *self){
            return JM_fitz_config();
        }
SWIGINTERN void Tools_glyph_cache_empty(struct Tools *self){
            fz_purge_glyph_cache(gctx);
        }
SWIGINTERN PyObject *Tools__fill_widget(struct Tools *self,struct Annot *annot,PyObject *widget){
            fz_try(gctx) {
                JM_get_widget_properties(gctx, (pdf_annot *) annot, widget);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Tools__save_widget(struct Tools *self,struct Annot *annot,PyObject *widget){
            fz_try(gctx) {
                JM_set_widget_properties(gctx, (pdf_annot *) annot, widget);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Tools__reset_widget(struct Tools *self,struct Annot *annot){
            fz_try(gctx) {
                pdf_annot *this_annot = (pdf_annot *) annot;
                pdf_document *pdf = pdf_get_bound_document(gctx, this_annot->obj);
                pdf_field_reset(gctx, pdf, this_annot->obj);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Tools__parse_da(struct Tools *self,struct Annot *annot){
            char *da_str = NULL;
            pdf_annot *this_annot = (pdf_annot *) annot;
            fz_try(gctx) {
                pdf_obj *da = pdf_dict_get_inheritable(gctx, this_annot->obj,
                                                       PDF_NAME(DA));
                if (!da) {
                    pdf_obj *trailer = pdf_trailer(gctx, this_annot->page->doc);
                    da = pdf_dict_getl(gctx, trailer, PDF_NAME(Root),
                                       PDF_NAME(AcroForm),
                                       PDF_NAME(DA),
                                       NULL);
                }
                da_str = (char *) pdf_to_text_string(gctx, da);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return JM_UnicodeFromStr(da_str);
        }
SWIGINTERN PyObject *Tools__update_da(struct Tools *self,struct Annot *annot,char *da_str){
            fz_try(gctx) {
                pdf_annot *this_annot = (pdf_annot *) annot;
                pdf_dict_put_text_string(gctx, this_annot->obj, PDF_NAME(DA), da_str);
                pdf_dict_del(gctx, this_annot->obj, PDF_NAME(DS)); /* not supported */
                pdf_dict_del(gctx, this_annot->obj, PDF_NAME(RC)); /* not supported */
                pdf_dirty_annot(gctx, this_annot);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_NONE;
        }
SWIGINTERN PyObject *Tools__get_all_contents(struct Tools *self,struct Page *fzpage){
            pdf_page *page = pdf_page_from_fz_page(gctx, (fz_page *) fzpage);
            fz_buffer *res = NULL;
            PyObject *result = NULL;
            fz_try(gctx) {
                ASSERT_PDF(page);
                res = JM_read_contents(gctx, page->obj);
                result = JM_BinFromBuffer(gctx, res);
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, res);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return result;
        }
SWIGINTERN PyObject *Tools__insert_contents(struct Tools *self,struct Page *page,PyObject *newcont,int overlay){
            fz_buffer *contbuf = NULL;
            int xref = 0;
            pdf_page *pdfpage = pdf_page_from_fz_page(gctx, (fz_page *) page);
            fz_try(gctx) {
                ASSERT_PDF(pdfpage);
                contbuf = JM_BufferFromBytes(gctx, newcont);
                xref = JM_insert_contents(gctx, pdfpage->doc, pdfpage->obj, contbuf, overlay);
                pdfpage->doc->dirty = 1;
            }
            fz_always(gctx) {
                fz_drop_buffer(gctx, contbuf);
            }
            fz_catch(gctx) {
                return NULL;
            }
            return Py_BuildValue("i", xref);
        }
SWIGINTERN PyObject *Tools_mupdf_version(struct Tools *self){
            return Py_BuildValue("s", FZ_VERSION);
        }
SWIGINTERN PyObject *Tools_mupdf_warnings(struct Tools *self,int reset){
            Py_INCREF(JM_mupdf_warnings_store);
            return JM_mupdf_warnings_store;
        }
SWIGINTERN int Tools__int_from_language(struct Tools *self,char *language){
            return fz_text_language_from_string(language);
        }
SWIGINTERN void Tools_reset_mupdf_warnings(struct Tools *self){
            Py_CLEAR(JM_mupdf_warnings_store);
            JM_mupdf_warnings_store = PyList_New(0);
        }
SWIGINTERN PyObject *Tools_mupdf_display_errors(struct Tools *self,PyObject *on){
            if (!on || on == Py_None) {
                return JM_BOOL(JM_mupdf_show_errors);
            }
            if (PyObject_IsTrue(on)) {
                JM_mupdf_show_errors = 1;
            } else {
                JM_mupdf_show_errors = 0;
            }
            return JM_BOOL(JM_mupdf_show_errors);
        }
SWIGINTERN PyObject *Tools_mupdf_display_warnings(struct Tools *self,PyObject *on){
            if (!on || on == Py_None) {
                return JM_BOOL(JM_mupdf_show_warnings);
            }
            if (PyObject_IsTrue(on)) {
                JM_mupdf_show_warnings = 1;
            } else {
                JM_mupdf_show_warnings = 0;
            }
            return JM_BOOL(JM_mupdf_show_warnings);
        }
SWIGINTERN PyObject *Tools__transform_rect(struct Tools *self,PyObject *rect,PyObject *matrix){
            return JM_py_from_rect(fz_transform_rect(JM_rect_from_py(rect), JM_matrix_from_py(matrix)));
        }
SWIGINTERN PyObject *Tools__intersect_rect(struct Tools *self,PyObject *r1,PyObject *r2){
            return JM_py_from_rect(fz_intersect_rect(JM_rect_from_py(r1),
                                                     JM_rect_from_py(r2)));
        }
SWIGINTERN PyObject *Tools__include_point_in_rect(struct Tools *self,PyObject *r,PyObject *p){
            return JM_py_from_rect(fz_include_point_in_rect(JM_rect_from_py(r),
                                                     JM_point_from_py(p)));
        }
SWIGINTERN PyObject *Tools__transform_point(struct Tools *self,PyObject *point,PyObject *matrix){
            return JM_py_from_point(fz_transform_point(JM_point_from_py(point), JM_matrix_from_py(matrix)));
        }
SWIGINTERN PyObject *Tools__union_rect(struct Tools *self,PyObject *r1,PyObject *r2){
            return JM_py_from_rect(fz_union_rect(JM_rect_from_py(r1),
                                                 JM_rect_from_py(r2)));
        }
SWIGINTERN PyObject *Tools__concat_matrix(struct Tools *self,PyObject *m1,PyObject *m2){
            return JM_py_from_matrix(fz_concat(JM_matrix_from_py(m1),
                                               JM_matrix_from_py(m2)));
        }
SWIGINTERN PyObject *Tools__invert_matrix(struct Tools *self,PyObject *matrix){
            fz_matrix src = JM_matrix_from_py(matrix);
            float a = src.a;
            float det = a * src.d - src.b * src.c;
            if (det < -FLT_EPSILON || det > FLT_EPSILON)
            {
                fz_matrix dst;
                float rdet = 1 / det;
                dst.a = src.d * rdet;
                dst.b = -src.b * rdet;
                dst.c = -src.c * rdet;
                dst.d = a * rdet;
                a = -src.e * dst.a - src.f * dst.c;
                dst.f = -src.e * dst.b - src.f * dst.d;
                dst.e = a;
                return Py_BuildValue("iN", 0, JM_py_from_matrix(dst));
            }
            return Py_BuildValue("(i, ())", 1);
        }
SWIGINTERN float Tools__measure_string(struct Tools *self,char const *text,char const *fontname,float fontsize,int encoding){
            fz_font *font = fz_new_base14_font(gctx, fontname);
            float w = 0;
            while (*text)
            {
                int c, g;
                text += fz_chartorune(&c, text);
                switch (encoding)
                {
                    case PDF_SIMPLE_ENCODING_GREEK:
                        c = fz_iso8859_7_from_unicode(c); break;
                    case PDF_SIMPLE_ENCODING_CYRILLIC:
                        c = fz_windows_1251_from_unicode(c); break;
                    default:
                        c = fz_windows_1252_from_unicode(c); break;
                }
                if (c < 0) c = 0xB7;
                g = fz_encode_character(gctx, font, c);
                w += fz_advance_glyph(gctx, font, g, 0);
            }
            return w * fontsize;
        }
SWIGINTERN PyObject *Tools__sine_between(struct Tools *self,PyObject *C,PyObject *P,PyObject *Q){
            // for points C, P, Q compute the sine between lines CP and QP
            fz_point c = JM_point_from_py(C);
            fz_point p = JM_point_from_py(P);
            fz_point q = JM_point_from_py(Q);
            fz_point s = JM_normalize_vector(q.x - p.x, q.y - p.y);
            fz_matrix m1 = fz_make_matrix(1, 0, 0, 1, -p.x, -p.y);
            fz_matrix m2 = fz_make_matrix(s.x, -s.y, s.y, s.x, 0, 0);
            m1 = fz_concat(m1, m2);
            c = fz_transform_point(c, m1);
            c = JM_normalize_vector(c.x, c.y);
            return Py_BuildValue("f", c.y);
        }
SWIGINTERN PyObject *Tools__hor_matrix(struct Tools *self,PyObject *C,PyObject *P){
            fz_point c = JM_point_from_py(C);
            fz_point p = JM_point_from_py(P);

            // compute (cosine, sine) of vector P-C with double precision:
            fz_point s = JM_normalize_vector(p.x - c.x, p.y - c.y);

            fz_matrix m1 = fz_make_matrix(1, 0, 0, 1, -c.x, -c.y);
            fz_matrix m2 = fz_make_matrix(s.x, -s.y, s.y, s.x, 0, 0);
            return JM_py_from_matrix(fz_concat(m1, m2));
        }
SWIGINTERN PyObject *Tools__point_in_quad(struct Tools *self,PyObject *P,PyObject *Q){
            fz_point p = JM_point_from_py(P);
            fz_quad q = JM_quad_from_py(Q);
            return JM_BOOL(fz_is_point_inside_quad(p, q));
        }
SWIGINTERN PyObject *Tools_set_font_width(struct Tools *self,struct Document *doc,int xref,int width){
            pdf_document *pdf = pdf_specifics(gctx, (fz_document *) doc);
            if (!pdf) Py_RETURN_FALSE;
            pdf_obj *font=NULL, *dfonts=NULL;
            fz_try(gctx) {
                font = pdf_load_object(gctx, pdf, xref);
                dfonts = pdf_dict_get(gctx, font, PDF_NAME(DescendantFonts));
                if (pdf_is_array(gctx, dfonts)) {
                    int i, n = pdf_array_len(gctx, dfonts);
                    for (i = 0; i < n; i++) {
                        pdf_obj *dfont = pdf_array_get(gctx, dfonts, i);
                        pdf_obj *warray = pdf_new_array(gctx, pdf, 3);
                        pdf_array_push(gctx, warray, pdf_new_int(gctx, 0));
                        pdf_array_push(gctx, warray, pdf_new_int(gctx, 65535));
                        pdf_array_push(gctx, warray, pdf_new_int(gctx, (int64_t) width));
                        pdf_dict_put_drop(gctx, dfont, PDF_NAME(W), warray);
                    }
                }
            }
            fz_always(gctx) {
                pdf_drop_obj(gctx, font);
            }
            fz_catch(gctx) {
                return NULL;
            }
            Py_RETURN_TRUE;
        }
#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_delete_Document(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Document" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  delete_Document(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Document(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) NULL ;
  PyObject *arg2 = (PyObject *) NULL ;
  char *arg3 = (char *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  float arg5 = (float) 0 ;
  float arg6 = (float) 0 ;
  float arg7 = (float) 11 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  float val7 ;
  int ecode7 = 0 ;
  PyObject *swig_obj[7] ;
  struct Document *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_Document", 0, 7, swig_obj)) SWIG_fail;
  if (swig_obj[0]) {
    res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Document" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = (char *)(buf1);
  }
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_Document" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_float(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Document" "', argument " "5"" of type '" "float""'");
    } 
    arg5 = (float)(val5);
  }
  if (swig_obj[5]) {
    ecode6 = SWIG_AsVal_float(swig_obj[5], &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Document" "', argument " "6"" of type '" "float""'");
    } 
    arg6 = (float)(val6);
  }
  if (swig_obj[6]) {
    ecode7 = SWIG_AsVal_float(swig_obj[6], &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_Document" "', argument " "7"" of type '" "float""'");
    } 
    arg7 = (float)(val7);
  }
  {
    result = (struct Document *)new_Document((char const *)arg1,arg2,(char const *)arg3,arg4,arg5,arg6,arg7);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Document, SWIG_POINTER_NEW |  0 );
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_close(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_close" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  Document_close(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_load_page(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  struct Page *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_load_page", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_load_page" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (struct Page *)Document_load_page(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Page, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__remove_links_to(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__remove_links_to", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__remove_links_to" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Document__remove_links_to(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__loadOutline(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct Outline *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__loadOutline" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (struct Outline *)Document__loadOutline(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Outline, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__dropOutline(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  struct Outline *arg2 = (struct Outline *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__dropOutline", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__dropOutline" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Outline, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__dropOutline" "', argument " "2"" of type '" "struct Outline *""'"); 
  }
  arg2 = (struct Outline *)(argp2);
  Document__dropOutline(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__insert_font(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  char *arg2 = (char *) NULL ;
  PyObject *arg3 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__insert_font", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__insert_font" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  if (swig_obj[1]) {
    res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__insert_font" "', argument " "2"" of type '" "char *""'");
    }
    arg2 = (char *)(buf2);
  }
  if (swig_obj[2]) {
    arg3 = swig_obj[2];
  }
  {
    result = (PyObject *)Document__insert_font(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_get_outline_xrefs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_get_outline_xrefs" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document_get_outline_xrefs(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_xref_get_keys(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_xref_get_keys", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_xref_get_keys" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_xref_get_keys" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document_xref_get_keys(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_xref_get_key(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_xref_get_key", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_xref_get_key" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_xref_get_key" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document_xref_get_key" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    result = (PyObject *)Document_xref_get_key(arg1,arg2,(char const *)arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_xref_set_key(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_xref_set_key", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_xref_set_key" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_xref_set_key" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document_xref_set_key" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document_xref_set_key" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  {
    result = (PyObject *)Document_xref_set_key(arg1,arg2,(char const *)arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__extend_toc_items(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__extend_toc_items", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__extend_toc_items" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Document__extend_toc_items(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__embfile_names(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__embfile_names", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__embfile_names" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Document__embfile_names(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__embfile_del(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__embfile_del", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__embfile_del" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__embfile_del" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document__embfile_del(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__embfile_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__embfile_info", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__embfile_info" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__embfile_info" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  arg3 = swig_obj[2];
  {
    result = (PyObject *)Document__embfile_info(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__embfile_upd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  PyObject *arg3 = (PyObject *) NULL ;
  char *arg4 = (char *) NULL ;
  char *arg5 = (char *) NULL ;
  char *arg6 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  PyObject *swig_obj[6] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__embfile_upd", 2, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__embfile_upd" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__embfile_upd" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    arg3 = swig_obj[2];
  }
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document__embfile_upd" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Document__embfile_upd" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (swig_obj[5]) {
    res6 = SWIG_AsCharPtrAndSize(swig_obj[5], &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Document__embfile_upd" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  {
    result = (PyObject *)Document__embfile_upd(arg1,arg2,arg3,arg4,arg5,arg6);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__embeddedFileGet(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__embeddedFileGet", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__embeddedFileGet" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__embeddedFileGet" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document__embeddedFileGet(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__embfile_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  char *arg2 = (char *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  char *arg4 = (char *) NULL ;
  char *arg5 = (char *) NULL ;
  char *arg6 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  PyObject *swig_obj[6] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__embfile_add", 3, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__embfile_add" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__embfile_add" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  arg3 = swig_obj[2];
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document__embfile_add" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Document__embfile_add" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (swig_obj[5]) {
    res6 = SWIG_AsCharPtrAndSize(swig_obj[5], &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Document__embfile_add" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  {
    result = (PyObject *)Document__embfile_add(arg1,(char const *)arg2,arg3,arg4,arg5,arg6);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_convert_to_pdf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_convert_to_pdf", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_convert_to_pdf" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_convert_to_pdf" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_convert_to_pdf" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_convert_to_pdf" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (PyObject *)Document_convert_to_pdf(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_page_count(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_page_count" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document_page_count(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_chapter_count(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_chapter_count" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document_chapter_count(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_last_location(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_last_location" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document_last_location(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_chapter_page_count(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_chapter_page_count", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_chapter_page_count" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_chapter_page_count" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document_chapter_page_count(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_prev_location(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_prev_location", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_prev_location" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Document_prev_location(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_next_location(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_next_location", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_next_location" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Document_next_location(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_location_from_page_number(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_location_from_page_number", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_location_from_page_number" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_location_from_page_number" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document_location_from_page_number(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_page_number_from_location(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_page_number_from_location", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_page_number_from_location" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Document_page_number_from_location(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getMetadata(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__getMetadata", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getMetadata" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__getMetadata" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    result = (PyObject *)Document__getMetadata(arg1,(char const *)arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_needs_pass(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_needs_pass" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_needs_pass(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_language(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_language" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_language(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_set_language(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  char *arg2 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_set_language", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_set_language" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  if (swig_obj[1]) {
    res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_set_language" "', argument " "2"" of type '" "char *""'");
    }
    arg2 = (char *)(buf2);
  }
  {
    result = (PyObject *)Document_set_language(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_resolve_link(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  char *arg2 = (char *) NULL ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_resolve_link", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_resolve_link" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  if (swig_obj[1]) {
    res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_resolve_link" "', argument " "2"" of type '" "char *""'");
    }
    arg2 = (char *)(buf2);
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_resolve_link" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  result = (PyObject *)Document_resolve_link(arg1,arg2,arg3);
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_layout(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  float arg3 = (float) 0 ;
  float arg4 = (float) 0 ;
  float arg5 = (float) 11 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_layout", 1, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_layout" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_float(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_layout" "', argument " "3"" of type '" "float""'");
    } 
    arg3 = (float)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_float(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_layout" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_float(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document_layout" "', argument " "5"" of type '" "float""'");
    } 
    arg5 = (float)(val5);
  }
  {
    result = (PyObject *)Document_layout(arg1,arg2,arg3,arg4,arg5);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_make_bookmark(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_make_bookmark", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_make_bookmark" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Document_make_bookmark(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_find_bookmark(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_find_bookmark", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_find_bookmark" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Document_find_bookmark(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_is_reflowable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_is_reflowable" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_is_reflowable(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__deleteObject(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__deleteObject", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__deleteObject" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__deleteObject" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document__deleteObject(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_pdf_catalog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_pdf_catalog" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document_pdf_catalog(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getPDFfileid(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getPDFfileid" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document__getPDFfileid(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_is_pdf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_is_pdf" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_is_pdf(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_has_xref_streams(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_has_xref_streams" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_has_xref_streams(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_has_old_style_xrefs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_has_old_style_xrefs" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_has_old_style_xrefs(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_is_dirty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_is_dirty" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_is_dirty(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_can_save_incrementally(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_can_save_incrementally" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_can_save_incrementally(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_is_repaired(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_is_repaired" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_is_repaired(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_authenticate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_authenticate", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_authenticate" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_authenticate" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  result = (PyObject *)Document_authenticate(arg1,arg2);
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_save(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  int arg4 = (int) 0 ;
  int arg5 = (int) 0 ;
  int arg6 = (int) 0 ;
  int arg7 = (int) 0 ;
  int arg8 = (int) 0 ;
  int arg9 = (int) 0 ;
  int arg10 = (int) 0 ;
  int arg11 = (int) 0 ;
  int arg12 = (int) 0 ;
  int arg13 = (int) 1 ;
  int arg14 = (int) -1 ;
  char *arg15 = (char *) NULL ;
  char *arg16 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  int res15 ;
  char *buf15 = 0 ;
  int alloc15 = 0 ;
  int res16 ;
  char *buf16 = 0 ;
  int alloc16 = 0 ;
  PyObject *swig_obj[16] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_save", 2, 16, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_save" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  arg2 = swig_obj[1];
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_save" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_save" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document_save" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Document_save" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (swig_obj[6]) {
    ecode7 = SWIG_AsVal_int(swig_obj[6], &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Document_save" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (swig_obj[7]) {
    ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Document_save" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (swig_obj[8]) {
    ecode9 = SWIG_AsVal_int(swig_obj[8], &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Document_save" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  if (swig_obj[9]) {
    ecode10 = SWIG_AsVal_int(swig_obj[9], &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "Document_save" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = (int)(val10);
  }
  if (swig_obj[10]) {
    ecode11 = SWIG_AsVal_int(swig_obj[10], &val11);
    if (!SWIG_IsOK(ecode11)) {
      SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "Document_save" "', argument " "11"" of type '" "int""'");
    } 
    arg11 = (int)(val11);
  }
  if (swig_obj[11]) {
    ecode12 = SWIG_AsVal_int(swig_obj[11], &val12);
    if (!SWIG_IsOK(ecode12)) {
      SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "Document_save" "', argument " "12"" of type '" "int""'");
    } 
    arg12 = (int)(val12);
  }
  if (swig_obj[12]) {
    ecode13 = SWIG_AsVal_int(swig_obj[12], &val13);
    if (!SWIG_IsOK(ecode13)) {
      SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "Document_save" "', argument " "13"" of type '" "int""'");
    } 
    arg13 = (int)(val13);
  }
  if (swig_obj[13]) {
    ecode14 = SWIG_AsVal_int(swig_obj[13], &val14);
    if (!SWIG_IsOK(ecode14)) {
      SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "Document_save" "', argument " "14"" of type '" "int""'");
    } 
    arg14 = (int)(val14);
  }
  if (swig_obj[14]) {
    res15 = SWIG_AsCharPtrAndSize(swig_obj[14], &buf15, NULL, &alloc15);
    if (!SWIG_IsOK(res15)) {
      SWIG_exception_fail(SWIG_ArgError(res15), "in method '" "Document_save" "', argument " "15"" of type '" "char *""'");
    }
    arg15 = (char *)(buf15);
  }
  if (swig_obj[15]) {
    res16 = SWIG_AsCharPtrAndSize(swig_obj[15], &buf16, NULL, &alloc16);
    if (!SWIG_IsOK(res16)) {
      SWIG_exception_fail(SWIG_ArgError(res16), "in method '" "Document_save" "', argument " "16"" of type '" "char *""'");
    }
    arg16 = (char *)(buf16);
  }
  {
    result = (PyObject *)Document_save(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc15 == SWIG_NEWOBJ) free((char*)buf15);
  if (alloc16 == SWIG_NEWOBJ) free((char*)buf16);
  return resultobj;
fail:
  if (alloc15 == SWIG_NEWOBJ) free((char*)buf15);
  if (alloc16 == SWIG_NEWOBJ) free((char*)buf16);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_insert_pdf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  struct Document *arg2 = (struct Document *) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  int arg8 = (int) 1 ;
  int arg9 = (int) 0 ;
  int arg10 = (int) 1 ;
  struct Graftmap *arg11 = (struct Graftmap *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject *swig_obj[11] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_insert_pdf", 2, 11, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_insert_pdf" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_insert_pdf" "', argument " "2"" of type '" "struct Document *""'"); 
  }
  arg2 = (struct Document *)(argp2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_insert_pdf" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_insert_pdf" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document_insert_pdf" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Document_insert_pdf" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (swig_obj[6]) {
    ecode7 = SWIG_AsVal_int(swig_obj[6], &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Document_insert_pdf" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (swig_obj[7]) {
    ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Document_insert_pdf" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (swig_obj[8]) {
    ecode9 = SWIG_AsVal_int(swig_obj[8], &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Document_insert_pdf" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  if (swig_obj[9]) {
    ecode10 = SWIG_AsVal_int(swig_obj[9], &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "Document_insert_pdf" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = (int)(val10);
  }
  if (swig_obj[10]) {
    res11 = SWIG_ConvertPtr(swig_obj[10], &argp11,SWIGTYPE_p_Graftmap, 0 |  0 );
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "Document_insert_pdf" "', argument " "11"" of type '" "struct Graftmap *""'"); 
    }
    arg11 = (struct Graftmap *)(argp11);
  }
  {
    result = (PyObject *)Document_insert_pdf(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__newPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 = (int) -1 ;
  float arg3 = (float) 595 ;
  float arg4 = (float) 842 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__newPage", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__newPage" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__newPage" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_float(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document__newPage" "', argument " "3"" of type '" "float""'");
    } 
    arg3 = (float)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_float(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document__newPage" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  {
    result = (PyObject *)Document__newPage(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_select(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_select", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_select" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Document_select(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__delete_page(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__delete_page", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__delete_page" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__delete_page" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document__delete_page(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_permissions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_permissions" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_permissions(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__get_char_widths(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject *swig_obj[7] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__get_char_widths", 6, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__get_char_widths" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__get_char_widths" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document__get_char_widths" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document__get_char_widths" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document__get_char_widths" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Document__get_char_widths" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  if (swig_obj[6]) {
    ecode7 = SWIG_AsVal_int(swig_obj[6], &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Document__get_char_widths" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    result = (PyObject *)Document__get_char_widths(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_page_xref(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_page_xref", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_page_xref" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_page_xref" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document_page_xref(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_page_annot_xrefs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_page_annot_xrefs", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_page_annot_xrefs" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_page_annot_xrefs" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document_page_annot_xrefs(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_page_cropbox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_page_cropbox", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_page_cropbox" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_page_cropbox" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document_page_cropbox(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getPageInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__getPageInfo", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getPageInfo" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__getPageInfo" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document__getPageInfo" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)Document__getPageInfo(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_extract_font(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 = (int) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_extract_font", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_extract_font" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_extract_font" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_extract_font" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)Document_extract_font(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_extract_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_extract_image", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_extract_image" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_extract_image" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document_extract_image(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__delToC(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__delToC" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document__delToC(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_is_stream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_is_stream", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_is_stream" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_is_stream" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (PyObject *)Document_is_stream(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_need_appearances(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_need_appearances", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_need_appearances" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  result = (PyObject *)Document_need_appearances(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_get_sigflags(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_get_sigflags" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (int)Document_get_sigflags(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_is_form_pdf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_is_form_pdf" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_is_form_pdf(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_FormFonts(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_FormFonts" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_FormFonts(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__addFormFont(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__addFormFont", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__addFormFont" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__addFormFont" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document__addFormFont" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  {
    result = (PyObject *)Document__addFormFont(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__getOLRootNumber(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__getOLRootNumber" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document__getOLRootNumber(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_get_new_xref(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_get_new_xref" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document_get_new_xref(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_xref_length(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_xref_length" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document_xref_length(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_get_xml_metadata(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_get_xml_metadata" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  result = (PyObject *)Document_get_xml_metadata(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_xref_xml_metadata(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_xref_xml_metadata" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document_xref_xml_metadata(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_del_xml_metadata(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_del_xml_metadata" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document_del_xml_metadata(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_set_xml_metadata(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_set_xml_metadata", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_set_xml_metadata" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_set_xml_metadata" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    result = (PyObject *)Document_set_xml_metadata(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_xref_object(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  int arg3 = (int) 0 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_xref_object", 2, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_xref_object" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_xref_object" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_xref_object" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_xref_object" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (PyObject *)Document_xref_object(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_xref_stream_raw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_xref_stream_raw", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_xref_stream_raw" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_xref_stream_raw" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document_xref_stream_raw(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_xref_stream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_xref_stream", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_xref_stream" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_xref_stream" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document_xref_stream(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_update_object(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  struct Page *arg4 = (struct Page *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_update_object", 3, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_update_object" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_update_object" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document_update_object" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  if (swig_obj[3]) {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4,SWIGTYPE_p_Page, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document_update_object" "', argument " "4"" of type '" "struct Page *""'"); 
    }
    arg4 = (struct Page *)(argp4);
  }
  {
    result = (PyObject *)Document_update_object(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_update_stream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 = (int) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_update_stream", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_update_stream" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_update_stream" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (swig_obj[2]) {
    arg3 = swig_obj[2];
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_update_stream" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (PyObject *)Document_update_stream(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__make_page_map(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__make_page_map" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document__make_page_map(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_fullcopy_page(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  int arg3 = (int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_fullcopy_page", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_fullcopy_page" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_fullcopy_page" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_fullcopy_page" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)Document_fullcopy_page(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__move_copy_page(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__move_copy_page", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__move_copy_page" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__move_copy_page" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document__move_copy_page" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document__move_copy_page" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document__move_copy_page" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    result = (PyObject *)Document__move_copy_page(arg1,arg2,arg3,arg4,arg5);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__remove_toc_item(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__remove_toc_item", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__remove_toc_item" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__remove_toc_item" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Document__remove_toc_item(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__update_toc_item(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  char *arg3 = (char *) NULL ;
  char *arg4 = (char *) NULL ;
  int arg5 = (int) 0 ;
  PyObject *arg6 = (PyObject *) NULL ;
  PyObject *arg7 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[7] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__update_toc_item", 2, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__update_toc_item" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document__update_toc_item" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document__update_toc_item" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Document__update_toc_item" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Document__update_toc_item" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    arg6 = swig_obj[5];
  }
  if (swig_obj[6]) {
    arg7 = swig_obj[6];
  }
  {
    result = (PyObject *)Document__update_toc_item(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__get_page_labels(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__get_page_labels" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document__get_page_labels(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document__set_page_labels(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document__set_page_labels", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document__set_page_labels" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document__set_page_labels" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    result = (PyObject *)Document__set_page_labels(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_get_layers(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_get_layers" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document_get_layers(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_switch_layer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_switch_layer", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_switch_layer" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_switch_layer" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_switch_layer" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)Document_switch_layer(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_get_layer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 = (int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_get_layer", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_get_layer" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_get_layer" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (PyObject *)Document_get_layer(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_set_layer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  char *arg3 = (char *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  PyObject *arg5 = (PyObject *) NULL ;
  PyObject *arg6 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[6] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_set_layer", 2, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_set_layer" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_set_layer" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document_set_layer" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  if (swig_obj[4]) {
    arg5 = swig_obj[4];
  }
  if (swig_obj[5]) {
    arg6 = swig_obj[5];
  }
  {
    result = (PyObject *)Document_set_layer(arg1,arg2,(char const *)arg3,arg4,arg5,arg6);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_add_layer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_add_layer", 2, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_add_layer" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_add_layer" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Document_add_layer" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  {
    result = (PyObject *)Document_add_layer(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_layer_ui_configs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_layer_ui_configs" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document_layer_ui_configs(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_set_layer_ui_config(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_set_layer_ui_config", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_set_layer_ui_config" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Document_set_layer_ui_config" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_set_layer_ui_config" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)Document_set_layer_ui_config(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_get_ocgs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_get_ocgs" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (PyObject *)Document_get_ocgs(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Document_add_ocg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  PyObject *arg5 = (PyObject *) NULL ;
  char *arg6 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  PyObject *swig_obj[6] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Document_add_ocg", 2, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Document_add_ocg" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Document_add_ocg" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Document_add_ocg" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Document_add_ocg" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (swig_obj[4]) {
    arg5 = swig_obj[4];
  }
  if (swig_obj[5]) {
    res6 = SWIG_AsCharPtrAndSize(swig_obj[5], &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Document_add_ocg" "', argument " "6"" of type '" "char const *""'");
    }
    arg6 = (char *)(buf6);
  }
  {
    result = (PyObject *)Document_add_ocg(arg1,arg2,arg3,arg4,arg5,(char const *)arg6);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return NULL;
}


SWIGINTERN PyObject *Document_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Document, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Document_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_delete_Page(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Page" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  delete_Page(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_bound(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_bound" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  result = (PyObject *)Page_bound(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_get_image_bbox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_get_image_bbox", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_get_image_bbox" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page_get_image_bbox" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  result = (PyObject *)Page_get_image_bbox(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_run(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  struct DeviceWrapper *arg2 = (struct DeviceWrapper *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_run", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_run" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_DeviceWrapper, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page_run" "', argument " "2"" of type '" "struct DeviceWrapper *""'"); 
  }
  arg2 = (struct DeviceWrapper *)(argp2);
  arg3 = swig_obj[2];
  {
    result = (PyObject *)Page_run(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__get_text_page(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  struct TextPage *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__get_text_page", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__get_text_page" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__get_text_page" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (struct TextPage *)Page__get_text_page(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TextPage, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_language(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_language" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  result = (PyObject *)Page_language(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_set_language(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  char *arg2 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_set_language", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_set_language" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  if (swig_obj[1]) {
    res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page_set_language" "', argument " "2"" of type '" "char *""'");
    }
    arg2 = (char *)(buf2);
  }
  {
    result = (PyObject *)Page_set_language(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_get_svg_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  int arg3 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_get_svg_image", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_get_svg_image" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page_get_svg_image" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)Page_get_svg_image(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__set_opacity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  char *arg2 = (char *) NULL ;
  float arg3 = (float) 1 ;
  float arg4 = (float) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__set_opacity", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__set_opacity" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  if (swig_obj[1]) {
    res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page__set_opacity" "', argument " "2"" of type '" "char *""'");
    }
    arg2 = (char *)(buf2);
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_float(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__set_opacity" "', argument " "3"" of type '" "float""'");
    } 
    arg3 = (float)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_float(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Page__set_opacity" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  {
    result = (PyObject *)Page__set_opacity(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_caret_annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_caret_annot", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_caret_annot" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (struct Annot *)Page__add_caret_annot(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_redact_annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  char *arg3 = (char *) NULL ;
  char *arg4 = (char *) NULL ;
  int arg5 = (int) 0 ;
  PyObject *arg6 = (PyObject *) NULL ;
  PyObject *arg7 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[7] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_redact_annot", 2, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_redact_annot" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page__add_redact_annot" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page__add_redact_annot" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Page__add_redact_annot" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    arg6 = swig_obj[5];
  }
  if (swig_obj[6]) {
    arg7 = swig_obj[6];
  }
  {
    result = (struct Annot *)Page__add_redact_annot(arg1,arg2,arg3,(char const *)arg4,arg5,arg6,arg7);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_line_annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_line_annot", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_line_annot" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  {
    result = (struct Annot *)Page__add_line_annot(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_text_annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  PyObject *swig_obj[4] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_text_annot", 3, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_text_annot" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page__add_text_annot" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page__add_text_annot" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  {
    result = (struct Annot *)Page__add_text_annot(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_ink_annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_ink_annot", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_ink_annot" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (struct Annot *)Page__add_ink_annot(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_stamp_annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_stamp_annot", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_stamp_annot" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__add_stamp_annot" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (struct Annot *)Page__add_stamp_annot(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_file_annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) NULL ;
  char *arg6 = (char *) NULL ;
  char *arg7 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  int res7 ;
  char *buf7 = 0 ;
  int alloc7 = 0 ;
  PyObject *swig_obj[7] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_file_annot", 4, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_file_annot" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page__add_file_annot" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Page__add_file_annot" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (swig_obj[5]) {
    res6 = SWIG_AsCharPtrAndSize(swig_obj[5], &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Page__add_file_annot" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  if (swig_obj[6]) {
    res7 = SWIG_AsCharPtrAndSize(swig_obj[6], &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "Page__add_file_annot" "', argument " "7"" of type '" "char *""'");
    }
    arg7 = (char *)(buf7);
  }
  {
    result = (struct Annot *)Page__add_file_annot(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_text_marker(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_text_marker", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_text_marker" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__add_text_marker" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (struct Annot *)Page__add_text_marker(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_square_or_circle(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_square_or_circle", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_square_or_circle" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__add_square_or_circle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (struct Annot *)Page__add_square_or_circle(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_multiline(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_multiline", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_multiline" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__add_multiline" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (struct Annot *)Page__add_multiline(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__add_freetext_annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  char *arg3 = (char *) 0 ;
  float arg4 = (float) 11 ;
  char *arg5 = (char *) NULL ;
  PyObject *arg6 = (PyObject *) NULL ;
  PyObject *arg7 = (PyObject *) NULL ;
  int arg8 = (int) 0 ;
  int arg9 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[9] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__add_freetext_annot", 3, 9, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__add_freetext_annot" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page__add_freetext_annot" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_float(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Page__add_freetext_annot" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Page__add_freetext_annot" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (swig_obj[5]) {
    arg6 = swig_obj[5];
  }
  if (swig_obj[6]) {
    arg7 = swig_obj[6];
  }
  if (swig_obj[7]) {
    ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Page__add_freetext_annot" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (swig_obj[8]) {
    ecode9 = SWIG_AsVal_int(swig_obj[8], &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Page__add_freetext_annot" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  {
    result = (struct Annot *)Page__add_freetext_annot(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__load_annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__load_annot", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__load_annot" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page__load_annot" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__load_annot" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (struct Annot *)Page__load_annot(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__get_resource_properties(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__get_resource_properties" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  {
    result = (PyObject *)Page__get_resource_properties(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__set_resource_property(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__set_resource_property", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__set_resource_property" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page__set_resource_property" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__set_resource_property" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)Page__set_resource_property(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_annot_names(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_annot_names" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  result = (PyObject *)Page_annot_names(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_annot_xrefs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_annot_xrefs" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  result = (PyObject *)Page_annot_xrefs(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__addWidget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__addWidget", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__addWidget" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Page__addWidget" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page__addWidget" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  {
    result = (struct Annot *)Page__addWidget(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_get_displaylist(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  int arg2 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  struct DisplayList *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_get_displaylist", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_get_displaylist" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Page_get_displaylist" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct DisplayList *)Page_get_displaylist(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DisplayList, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__getDrawings(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__getDrawings" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  {
    result = (PyObject *)Page__getDrawings(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__apply_redactions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  int arg2 = (int) PDF_REDACT_IMAGE_PIXELS ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__apply_redactions", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__apply_redactions" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Page__apply_redactions" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (PyObject *)Page__apply_redactions(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__makePixmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  struct Document *arg2 = (struct Document *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  struct Colorspace *arg4 = (struct Colorspace *) 0 ;
  int arg5 = (int) 0 ;
  int arg6 = (int) 1 ;
  PyObject *arg7 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  PyObject *swig_obj[7] ;
  struct Pixmap *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__makePixmap", 4, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__makePixmap" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page__makePixmap" "', argument " "2"" of type '" "struct Document *""'"); 
  }
  arg2 = (struct Document *)(argp2);
  arg3 = swig_obj[2];
  res4 = SWIG_ConvertPtr(swig_obj[3], &argp4,SWIGTYPE_p_Colorspace, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page__makePixmap" "', argument " "4"" of type '" "struct Colorspace *""'"); 
  }
  arg4 = (struct Colorspace *)(argp4);
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Page__makePixmap" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Page__makePixmap" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (swig_obj[6]) {
    arg7 = swig_obj[6];
  }
  {
    result = (struct Pixmap *)Page__makePixmap(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Pixmap, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_set_mediabox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_set_mediabox", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_set_mediabox" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Page_set_mediabox(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_set_cropbox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_set_cropbox", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_set_cropbox" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Page_set_cropbox(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_load_links(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct Link *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_load_links" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  result = (struct Link *)Page_load_links(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Link, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_first_annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct Annot *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_first_annot" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  result = (struct Annot *)Page_first_annot(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_first_widget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct Annot *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_first_widget" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  result = (struct Annot *)Page_first_widget(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_delete_link(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_delete_link", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_delete_link" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  Page_delete_link(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_delete_annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  struct Annot *arg2 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  struct Annot *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_delete_annot", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_delete_annot" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page_delete_annot" "', argument " "2"" of type '" "struct Annot *""'"); 
  }
  arg2 = (struct Annot *)(argp2);
  result = (struct Annot *)Page_delete_annot(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_mediabox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_mediabox" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  result = (PyObject *)Page_mediabox(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_cropbox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_cropbox" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  result = (PyObject *)Page_cropbox(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_rotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_rotation" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  result = (int)Page_rotation(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_set_rotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_set_rotation", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_set_rotation" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Page_set_rotation" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Page_set_rotation(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__addAnnot_FromString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__addAnnot_FromString", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__addAnnot_FromString" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Page__addAnnot_FromString(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_clean_contents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  int arg2 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page_clean_contents", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_clean_contents" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Page_clean_contents" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (PyObject *)Page_clean_contents(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__show_pdf_page(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  struct Page *arg2 = (struct Page *) 0 ;
  int arg3 = (int) 1 ;
  PyObject *arg4 = (PyObject *) NULL ;
  int arg5 = (int) 0 ;
  int arg6 = (int) 0 ;
  PyObject *arg7 = (PyObject *) NULL ;
  struct Graftmap *arg8 = (struct Graftmap *) NULL ;
  char *arg9 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  int res9 ;
  char *buf9 = 0 ;
  int alloc9 = 0 ;
  PyObject *swig_obj[9] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__show_pdf_page", 2, 9, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__show_pdf_page" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page__show_pdf_page" "', argument " "2"" of type '" "struct Page *""'"); 
  }
  arg2 = (struct Page *)(argp2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Page__show_pdf_page" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Page__show_pdf_page" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Page__show_pdf_page" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (swig_obj[6]) {
    arg7 = swig_obj[6];
  }
  if (swig_obj[7]) {
    res8 = SWIG_ConvertPtr(swig_obj[7], &argp8,SWIGTYPE_p_Graftmap, 0 |  0 );
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "Page__show_pdf_page" "', argument " "8"" of type '" "struct Graftmap *""'"); 
    }
    arg8 = (struct Graftmap *)(argp8);
  }
  if (swig_obj[8]) {
    res9 = SWIG_AsCharPtrAndSize(swig_obj[8], &buf9, NULL, &alloc9);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "Page__show_pdf_page" "', argument " "9"" of type '" "char *""'");
    }
    arg9 = (char *)(buf9);
  }
  {
    result = (PyObject *)Page__show_pdf_page(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return resultobj;
fail:
  if (alloc9 == SWIG_NEWOBJ) free((char*)buf9);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__insert_image(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  char *arg2 = (char *) NULL ;
  struct Pixmap *arg3 = (struct Pixmap *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  PyObject *arg5 = (PyObject *) NULL ;
  PyObject *arg6 = (PyObject *) NULL ;
  int arg7 = (int) 1 ;
  int arg8 = (int) 0 ;
  int arg9 = (int) 1 ;
  int arg10 = (int) 0 ;
  int arg11 = (int) 0 ;
  int arg12 = (int) 0 ;
  int arg13 = (int) 0 ;
  int arg14 = (int) -1 ;
  char *arg15 = (char *) NULL ;
  PyObject *arg16 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  int res15 ;
  char *buf15 = 0 ;
  int alloc15 = 0 ;
  PyObject *swig_obj[16] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__insert_image", 1, 16, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__insert_image" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  if (swig_obj[1]) {
    res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page__insert_image" "', argument " "2"" of type '" "char *""'");
    }
    arg2 = (char *)(buf2);
  }
  if (swig_obj[2]) {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_Pixmap, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page__insert_image" "', argument " "3"" of type '" "struct Pixmap *""'"); 
    }
    arg3 = (struct Pixmap *)(argp3);
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  if (swig_obj[4]) {
    arg5 = swig_obj[4];
  }
  if (swig_obj[5]) {
    arg6 = swig_obj[5];
  }
  if (swig_obj[6]) {
    ecode7 = SWIG_AsVal_int(swig_obj[6], &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Page__insert_image" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (swig_obj[7]) {
    ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Page__insert_image" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (swig_obj[8]) {
    ecode9 = SWIG_AsVal_int(swig_obj[8], &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Page__insert_image" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  if (swig_obj[9]) {
    ecode10 = SWIG_AsVal_int(swig_obj[9], &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "Page__insert_image" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = (int)(val10);
  }
  if (swig_obj[10]) {
    ecode11 = SWIG_AsVal_int(swig_obj[10], &val11);
    if (!SWIG_IsOK(ecode11)) {
      SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "Page__insert_image" "', argument " "11"" of type '" "int""'");
    } 
    arg11 = (int)(val11);
  }
  if (swig_obj[11]) {
    ecode12 = SWIG_AsVal_int(swig_obj[11], &val12);
    if (!SWIG_IsOK(ecode12)) {
      SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "Page__insert_image" "', argument " "12"" of type '" "int""'");
    } 
    arg12 = (int)(val12);
  }
  if (swig_obj[12]) {
    ecode13 = SWIG_AsVal_int(swig_obj[12], &val13);
    if (!SWIG_IsOK(ecode13)) {
      SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "Page__insert_image" "', argument " "13"" of type '" "int""'");
    } 
    arg13 = (int)(val13);
  }
  if (swig_obj[13]) {
    ecode14 = SWIG_AsVal_int(swig_obj[13], &val14);
    if (!SWIG_IsOK(ecode14)) {
      SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "Page__insert_image" "', argument " "14"" of type '" "int""'");
    } 
    arg14 = (int)(val14);
  }
  if (swig_obj[14]) {
    res15 = SWIG_AsCharPtrAndSize(swig_obj[14], &buf15, NULL, &alloc15);
    if (!SWIG_IsOK(res15)) {
      SWIG_exception_fail(SWIG_ArgError(res15), "in method '" "Page__insert_image" "', argument " "15"" of type '" "char const *""'");
    }
    arg15 = (char *)(buf15);
  }
  if (swig_obj[15]) {
    arg16 = swig_obj[15];
  }
  {
    result = (PyObject *)Page__insert_image(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,(char const *)arg15,arg16);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc15 == SWIG_NEWOBJ) free((char*)buf15);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc15 == SWIG_NEWOBJ) free((char*)buf15);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_refresh(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_refresh" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  {
    result = (PyObject *)Page_refresh(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page__insertFont(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  PyObject *arg5 = (PyObject *) 0 ;
  int arg6 ;
  int arg7 ;
  int arg8 ;
  int arg9 ;
  int arg10 ;
  int arg11 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  PyObject *swig_obj[11] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Page__insertFont", 11, 11, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page__insertFont" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Page__insertFont" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Page__insertFont" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Page__insertFont" "', argument " "4"" of type '" "char *""'");
  }
  arg4 = (char *)(buf4);
  arg5 = swig_obj[4];
  ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Page__insertFont" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[6], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Page__insertFont" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Page__insertFont" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  ecode9 = SWIG_AsVal_int(swig_obj[8], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "Page__insertFont" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  ecode10 = SWIG_AsVal_int(swig_obj[9], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "Page__insertFont" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  ecode11 = SWIG_AsVal_int(swig_obj[10], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "Page__insertFont" "', argument " "11"" of type '" "int""'");
  } 
  arg11 = (int)(val11);
  {
    result = (PyObject *)Page__insertFont(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_transformation_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_transformation_matrix" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  result = (PyObject *)Page_transformation_matrix(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Page_get_contents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Page *arg1 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Page_get_contents" "', argument " "1"" of type '" "struct Page *""'"); 
  }
  arg1 = (struct Page *)(argp1);
  {
    result = (PyObject *)Page_get_contents(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Page_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Page, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_Pixmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Pixmap" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  delete_Pixmap(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct Colorspace *arg1 = (struct Colorspace *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  struct Pixmap *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Colorspace, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct Colorspace *""'"); 
  }
  arg1 = (struct Colorspace *)(argp1);
  arg2 = swig_obj[1];
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Pixmap" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (struct Pixmap *)new_Pixmap__SWIG_0(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Pixmap, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct Colorspace *arg1 = (struct Colorspace *) 0 ;
  struct Pixmap *arg2 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  struct Pixmap *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Colorspace, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct Colorspace *""'"); 
  }
  arg1 = (struct Colorspace *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "struct Pixmap *""'"); 
  }
  arg2 = (struct Pixmap *)(argp2);
  {
    result = (struct Pixmap *)new_Pixmap__SWIG_1(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Pixmap, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  float arg2 ;
  float arg3 ;
  PyObject *arg4 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  struct Pixmap *result = 0 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  ecode2 = SWIG_AsVal_float(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  ecode3 = SWIG_AsVal_float(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Pixmap" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = (float)(val3);
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  {
    result = (struct Pixmap *)new_Pixmap__SWIG_2(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Pixmap, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  int arg2 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  struct Pixmap *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct Pixmap *)new_Pixmap__SWIG_3(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Pixmap, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct Colorspace *arg1 = (struct Colorspace *) 0 ;
  int arg2 ;
  int arg3 ;
  PyObject *arg4 = (PyObject *) 0 ;
  int arg5 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  struct Pixmap *result = 0 ;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Colorspace, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct Colorspace *""'"); 
  }
  arg1 = (struct Colorspace *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Pixmap" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  arg4 = swig_obj[3];
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Pixmap" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    result = (struct Pixmap *)new_Pixmap__SWIG_4(arg1,arg2,arg3,arg4,arg5);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Pixmap, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  struct Pixmap *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = swig_obj[0];
  {
    result = (struct Pixmap *)new_Pixmap__SWIG_5(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Pixmap, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  struct Pixmap *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pixmap" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pixmap" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (struct Pixmap *)new_Pixmap__SWIG_6(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Pixmap, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Pixmap(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Pixmap", 0, 5, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Pixmap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      if (argc <= 1) {
        return _wrap_new_Pixmap__SWIG_3(self, argc, argv);
      }
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Pixmap__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      return _wrap_new_Pixmap__SWIG_5(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Colorspace, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_Pixmap, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_Pixmap__SWIG_1(self, argc, argv);
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Colorspace, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        if (argc <= 2) {
          return _wrap_new_Pixmap__SWIG_0(self, argc, argv);
        }
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_Pixmap__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Document, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Pixmap__SWIG_6(self, argc, argv);
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Pixmap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_float(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_float(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          if (argc <= 3) {
            return _wrap_new_Pixmap__SWIG_2(self, argc, argv);
          }
          _v = (argv[3] != 0);
          if (_v) {
            return _wrap_new_Pixmap__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Colorspace, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          _v = (argv[3] != 0);
          if (_v) {
            if (argc <= 4) {
              return _wrap_new_Pixmap__SWIG_4(self, argc, argv);
            }
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_Pixmap__SWIG_4(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Pixmap'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Pixmap::Pixmap(struct Colorspace *,PyObject *,int)\n"
    "    Pixmap::Pixmap(struct Colorspace *,struct Pixmap *)\n"
    "    Pixmap::Pixmap(struct Pixmap *,float,float,PyObject *)\n"
    "    Pixmap::Pixmap(struct Pixmap *,int)\n"
    "    Pixmap::Pixmap(struct Colorspace *,int,int,PyObject *,int)\n"
    "    Pixmap::Pixmap(PyObject *)\n"
    "    Pixmap::Pixmap(struct Document *,int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Pixmap_shrink(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_shrink", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_shrink" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_shrink" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  Pixmap_shrink(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_gamma_with(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_gamma_with", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_gamma_with" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  ecode2 = SWIG_AsVal_float(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_gamma_with" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  Pixmap_gamma_with(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_tint_with(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_tint_with", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_tint_with" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_tint_with" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_tint_with" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  Pixmap_tint_with(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_clear_with__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_clear_with" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  Pixmap_clear_with__SWIG_0(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_clear_with__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_clear_with" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_clear_with" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  Pixmap_clear_with__SWIG_1(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_clear_with__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  int arg2 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_clear_with" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_clear_with" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  arg3 = swig_obj[2];
  Pixmap_clear_with__SWIG_2(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_clear_with(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Pixmap_clear_with", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Pixmap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Pixmap_clear_with__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Pixmap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Pixmap_clear_with__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Pixmap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        _v = (argv[2] != 0);
        if (_v) {
          return _wrap_Pixmap_clear_with__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Pixmap_clear_with'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Pixmap::clear_with()\n"
    "    Pixmap::clear_with(int)\n"
    "    Pixmap::clear_with(int,PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Pixmap_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  struct Pixmap *arg2 = (struct Pixmap *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_copy", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_copy" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pixmap_copy" "', argument " "2"" of type '" "struct Pixmap *""'"); 
  }
  arg2 = (struct Pixmap *)(argp2);
  arg3 = swig_obj[2];
  {
    result = (PyObject *)Pixmap_copy(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_set_alpha(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  int arg3 = (int) 1 ;
  PyObject *arg4 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_set_alpha", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_set_alpha" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_set_alpha" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  {
    result = (PyObject *)Pixmap_set_alpha(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap__tobytes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap__tobytes", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap__tobytes" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap__tobytes" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Pixmap__tobytes(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap__writeIMG(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap__writeIMG", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap__writeIMG" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pixmap__writeIMG" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap__writeIMG" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)Pixmap__writeIMG(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_invert_irect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_invert_irect", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_invert_irect" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  result = (PyObject *)Pixmap_invert_irect(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_pixel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_pixel", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_pixel" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_pixel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_pixel" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)Pixmap_pixel(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_set_pixel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  int arg2 ;
  int arg3 ;
  PyObject *arg4 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_set_pixel", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_set_pixel" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_set_pixel" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_set_pixel" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  arg4 = swig_obj[3];
  {
    result = (PyObject *)Pixmap_set_pixel(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_set_origin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_set_origin", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_set_origin" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_set_origin" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_set_origin" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (PyObject *)Pixmap_set_origin(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_set_dpi(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_set_dpi", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_set_dpi" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pixmap_set_dpi" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pixmap_set_dpi" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (PyObject *)Pixmap_set_dpi(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_set_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Pixmap_set_rect", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_set_rect" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  {
    result = (PyObject *)Pixmap_set_rect(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_is_monochrome(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_is_monochrome" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (PyObject *)Pixmap_is_monochrome(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_digest(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_digest" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (PyObject *)Pixmap_digest(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_stride(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_stride" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (PyObject *)Pixmap_stride(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_xres(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_xres" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (int)Pixmap_xres(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_yres(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_yres" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (int)Pixmap_yres(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_w(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_w" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (PyObject *)Pixmap_w(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_h(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_h" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (PyObject *)Pixmap_h(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_x(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_x" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (int)Pixmap_x(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_y(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_y" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (int)Pixmap_y(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_n(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_n" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (int)Pixmap_n(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_alpha(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_alpha" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (int)Pixmap_alpha(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_colorspace(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct Colorspace *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_colorspace" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (struct Colorspace *)Pixmap_colorspace(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Colorspace, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_irect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_irect" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (PyObject *)Pixmap_irect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_size" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (PyObject *)Pixmap_size(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pixmap_samples(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pixmap_samples" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  result = (PyObject *)Pixmap_samples(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Pixmap_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Pixmap, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Pixmap_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_delete_Colorspace(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Colorspace *arg1 = (struct Colorspace *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Colorspace, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Colorspace" "', argument " "1"" of type '" "struct Colorspace *""'"); 
  }
  arg1 = (struct Colorspace *)(argp1);
  delete_Colorspace(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Colorspace(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  struct Colorspace *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Colorspace" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (struct Colorspace *)new_Colorspace(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Colorspace, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Colorspace_n(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Colorspace *arg1 = (struct Colorspace *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Colorspace, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Colorspace_n" "', argument " "1"" of type '" "struct Colorspace *""'"); 
  }
  arg1 = (struct Colorspace *)(argp1);
  result = (PyObject *)Colorspace_n(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Colorspace__name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Colorspace *arg1 = (struct Colorspace *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Colorspace, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Colorspace__name" "', argument " "1"" of type '" "struct Colorspace *""'"); 
  }
  arg1 = (struct Colorspace *)(argp1);
  result = (PyObject *)Colorspace__name(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Colorspace_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Colorspace, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Colorspace_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Device__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct Pixmap *arg1 = (struct Pixmap *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  struct DeviceWrapper *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Pixmap, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Device" "', argument " "1"" of type '" "struct Pixmap *""'"); 
  }
  arg1 = (struct Pixmap *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (struct DeviceWrapper *)new_DeviceWrapper__SWIG_0(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DeviceWrapper, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Device__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct DisplayList *arg1 = (struct DisplayList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  struct DeviceWrapper *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_DisplayList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Device" "', argument " "1"" of type '" "struct DisplayList *""'"); 
  }
  arg1 = (struct DisplayList *)(argp1);
  {
    result = (struct DeviceWrapper *)new_DeviceWrapper__SWIG_1(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DeviceWrapper, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Device__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  struct TextPage *arg1 = (struct TextPage *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  struct DeviceWrapper *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextPage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Device" "', argument " "1"" of type '" "struct TextPage *""'"); 
  }
  arg1 = (struct TextPage *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Device" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct DeviceWrapper *)new_DeviceWrapper__SWIG_2(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DeviceWrapper, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Device(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Device", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_DisplayList, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Device__SWIG_1(self, argc, argv);
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_TextPage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      if (argc <= 1) {
        return _wrap_new_Device__SWIG_2(self, argc, argv);
      }
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Device__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Pixmap, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (argv[1] != 0);
      if (_v) {
        return _wrap_new_Device__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Device'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    DeviceWrapper::DeviceWrapper(struct Pixmap *,PyObject *)\n"
    "    DeviceWrapper::DeviceWrapper(struct DisplayList *)\n"
    "    DeviceWrapper::DeviceWrapper(struct TextPage *,int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Device(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct DeviceWrapper *arg1 = (struct DeviceWrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_DeviceWrapper, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Device" "', argument " "1"" of type '" "struct DeviceWrapper *""'"); 
  }
  arg1 = (struct DeviceWrapper *)(argp1);
  delete_DeviceWrapper(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Device_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_DeviceWrapper, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Device_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_Outline_uri(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Outline *arg1 = (struct Outline *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Outline, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_uri" "', argument " "1"" of type '" "struct Outline *""'"); 
  }
  arg1 = (struct Outline *)(argp1);
  result = (PyObject *)Outline_uri(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Outline *arg1 = (struct Outline *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct Outline *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Outline, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_next" "', argument " "1"" of type '" "struct Outline *""'"); 
  }
  arg1 = (struct Outline *)(argp1);
  result = (struct Outline *)Outline_next(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Outline, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_down(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Outline *arg1 = (struct Outline *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct Outline *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Outline, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_down" "', argument " "1"" of type '" "struct Outline *""'"); 
  }
  arg1 = (struct Outline *)(argp1);
  result = (struct Outline *)Outline_down(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Outline, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_isExternal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Outline *arg1 = (struct Outline *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Outline, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_isExternal" "', argument " "1"" of type '" "struct Outline *""'"); 
  }
  arg1 = (struct Outline *)(argp1);
  result = (PyObject *)Outline_isExternal(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_page(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Outline *arg1 = (struct Outline *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Outline, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_page" "', argument " "1"" of type '" "struct Outline *""'"); 
  }
  arg1 = (struct Outline *)(argp1);
  result = (int)Outline_page(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_x(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Outline *arg1 = (struct Outline *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  float result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Outline, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_x" "', argument " "1"" of type '" "struct Outline *""'"); 
  }
  arg1 = (struct Outline *)(argp1);
  result = (float)Outline_x(arg1);
  resultobj = SWIG_From_float((float)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_y(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Outline *arg1 = (struct Outline *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  float result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Outline, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_y" "', argument " "1"" of type '" "struct Outline *""'"); 
  }
  arg1 = (struct Outline *)(argp1);
  result = (float)Outline_y(arg1);
  resultobj = SWIG_From_float((float)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_title(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Outline *arg1 = (struct Outline *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Outline, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_title" "', argument " "1"" of type '" "struct Outline *""'"); 
  }
  arg1 = (struct Outline *)(argp1);
  result = (PyObject *)Outline_title(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Outline_is_open(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Outline *arg1 = (struct Outline *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Outline, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Outline_is_open" "', argument " "1"" of type '" "struct Outline *""'"); 
  }
  arg1 = (struct Outline *)(argp1);
  result = (PyObject *)Outline_is_open(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Outline(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Outline *arg1 = (struct Outline *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Outline, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Outline" "', argument " "1"" of type '" "struct Outline *""'"); 
  }
  arg1 = (struct Outline *)(argp1);
  free((char *) arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Outline_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Outline, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_Annot(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Annot" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  delete_Annot(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_rect" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_rect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_xref(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_xref" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_xref(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_apn_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_apn_matrix" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_apn_matrix(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_apn_bbox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_apn_bbox" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_apn_bbox(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_apn_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_apn_matrix", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_apn_matrix" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Annot_set_apn_matrix(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_apn_bbox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_apn_bbox", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_apn_bbox" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Annot_set_apn_bbox(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_blendmode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_blendmode" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_blendmode(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_blendmode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_blendmode", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_blendmode" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Annot_set_blendmode" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  {
    result = (PyObject *)Annot_set_blendmode(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_get_oc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_get_oc" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  {
    result = (PyObject *)Annot_get_oc(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_open(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_open", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_open" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_set_open" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)Annot_set_open(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_is_open(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_is_open" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  {
    result = (PyObject *)Annot_is_open(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_has_popup(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_has_popup" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  {
    result = (PyObject *)Annot_has_popup(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_popup(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_popup", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_popup" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  arg2 = swig_obj[1];
  {
    result = (PyObject *)Annot_set_popup(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_popup_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_popup_rect" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  {
    result = (PyObject *)Annot_popup_rect(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_popup_xref(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_popup_xref" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  {
    result = (PyObject *)Annot_popup_xref(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_oc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_oc", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_oc" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_set_oc" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (PyObject *)Annot_set_oc(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_language(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_language" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_language(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_language(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  char *arg2 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_language", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_language" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  if (swig_obj[1]) {
    res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Annot_set_language" "', argument " "2"" of type '" "char *""'");
    }
    arg2 = (char *)(buf2);
  }
  {
    result = (PyObject *)Annot_set_language(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__getAP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__getAP" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  {
    result = (PyObject *)Annot__getAP(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__setAP(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot__setAP", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__setAP" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  arg2 = swig_obj[1];
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Annot__setAP" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)Annot__setAP(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__get_redact_values(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__get_redact_values" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  {
    result = (PyObject *)Annot__get_redact_values(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_get_textpage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  struct TextPage *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_get_textpage", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_get_textpage" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Annot_get_textpage" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (struct TextPage *)Annot_get_textpage(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TextPage, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_name", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_name" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Annot_set_name" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  result = (PyObject *)Annot_set_name(arg1,arg2);
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_rect", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_rect" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  arg2 = swig_obj[1];
  result = (PyObject *)Annot_set_rect(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_rotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_rotation", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_rotation" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_set_rotation" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (PyObject *)Annot_set_rotation(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_rotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_rotation" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (int)Annot_rotation(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_vertices(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_vertices" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_vertices(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_colors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_colors" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_colors(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot__update_appearance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  float arg2 = (float) -1 ;
  char *arg3 = (char *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  int arg5 = (int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot__update_appearance", 1, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot__update_appearance" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_float(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot__update_appearance" "', argument " "2"" of type '" "float""'");
    } 
    arg2 = (float)(val2);
  }
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Annot__update_appearance" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Annot__update_appearance" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  result = (PyObject *)Annot__update_appearance(arg1,arg2,arg3,arg4,arg5);
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_colors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  PyObject *arg3 = (PyObject *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_colors", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_colors" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    arg3 = swig_obj[2];
  }
  if (swig_obj[3]) {
    arg4 = swig_obj[3];
  }
  Annot_set_colors(arg1,arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_line_ends(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_line_ends" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_line_ends(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_line_ends(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_line_ends", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_line_ends" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_set_line_ends" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Annot_set_line_ends" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  Annot_set_line_ends(arg1,arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_type" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_type(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_opacity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_opacity" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_opacity(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_opacity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_opacity", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_opacity" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  ecode2 = SWIG_AsVal_float(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_set_opacity" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  Annot_set_opacity(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_file_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_file_info" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  {
    result = (PyObject *)Annot_file_info(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_get_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_get_file" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  {
    result = (PyObject *)Annot_get_file(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_get_sound(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_get_sound" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  {
    result = (PyObject *)Annot_get_sound(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_update_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  char *arg3 = (char *) NULL ;
  char *arg4 = (char *) NULL ;
  char *arg5 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  PyObject *swig_obj[5] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_update_file", 1, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_update_file" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Annot_update_file" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Annot_update_file" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Annot_update_file" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  {
    result = (PyObject *)Annot_update_file(arg1,arg2,arg3,arg4,arg5);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_info" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_info(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  char *arg3 = (char *) NULL ;
  char *arg4 = (char *) NULL ;
  char *arg5 = (char *) NULL ;
  char *arg6 = (char *) NULL ;
  char *arg7 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  int res7 ;
  char *buf7 = 0 ;
  int alloc7 = 0 ;
  PyObject *swig_obj[7] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_info", 1, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_info" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Annot_set_info" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Annot_set_info" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Annot_set_info" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (swig_obj[5]) {
    res6 = SWIG_AsCharPtrAndSize(swig_obj[5], &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Annot_set_info" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  if (swig_obj[6]) {
    res7 = SWIG_AsCharPtrAndSize(swig_obj[6], &buf7, NULL, &alloc7);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "Annot_set_info" "', argument " "7"" of type '" "char *""'");
    }
    arg7 = (char *)(buf7);
  }
  {
    result = (PyObject *)Annot_set_info(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  if (alloc7 == SWIG_NEWOBJ) free((char*)buf7);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_border(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_border" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (PyObject *)Annot_border(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_border(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  float arg3 = (float) 0 ;
  char *arg4 = (char *) NULL ;
  PyObject *arg5 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  PyObject *swig_obj[5] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_border", 1, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_border" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_float(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Annot_set_border" "', argument " "3"" of type '" "float""'");
    } 
    arg3 = (float)(val3);
  }
  if (swig_obj[3]) {
    res4 = SWIG_AsCharPtrAndSize(swig_obj[3], &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Annot_set_border" "', argument " "4"" of type '" "char *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (swig_obj[4]) {
    arg5 = swig_obj[4];
  }
  result = (PyObject *)Annot_set_border(arg1,arg2,arg3,arg4,arg5);
  resultobj = result;
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) free((char*)buf4);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_flags(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_flags" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (int)Annot_flags(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_clean_contents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  int arg2 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_clean_contents", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_clean_contents" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_clean_contents" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (PyObject *)Annot_clean_contents(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_set_flags(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_set_flags", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_set_flags" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Annot_set_flags" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  Annot_set_flags(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_delete_responses(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_delete_responses" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  {
    result = (PyObject *)Annot_delete_responses(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct Annot *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_next" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  result = (struct Annot *)Annot_next(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Annot, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Annot_get_pixmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Annot *arg1 = (struct Annot *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  struct Colorspace *arg3 = (struct Colorspace *) NULL ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  struct Pixmap *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Annot_get_pixmap", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Annot_get_pixmap" "', argument " "1"" of type '" "struct Annot *""'"); 
  }
  arg1 = (struct Annot *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_Colorspace, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Annot_get_pixmap" "', argument " "3"" of type '" "struct Colorspace *""'"); 
    }
    arg3 = (struct Colorspace *)(argp3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Annot_get_pixmap" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (struct Pixmap *)Annot_get_pixmap(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Pixmap, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Annot_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Annot, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_Link(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Link *arg1 = (struct Link *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Link, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Link" "', argument " "1"" of type '" "struct Link *""'"); 
  }
  arg1 = (struct Link *)(argp1);
  delete_Link(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link__border(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Link *arg1 = (struct Link *) 0 ;
  struct Document *arg2 = (struct Document *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Link__border", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Link, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link__border" "', argument " "1"" of type '" "struct Link *""'"); 
  }
  arg1 = (struct Link *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Link__border" "', argument " "2"" of type '" "struct Document *""'"); 
  }
  arg2 = (struct Document *)(argp2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Link__border" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (PyObject *)Link__border(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link__setBorder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Link *arg1 = (struct Link *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  struct Document *arg3 = (struct Document *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Link__setBorder", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Link, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link__setBorder" "', argument " "1"" of type '" "struct Link *""'"); 
  }
  arg1 = (struct Link *)(argp1);
  arg2 = swig_obj[1];
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Link__setBorder" "', argument " "3"" of type '" "struct Document *""'"); 
  }
  arg3 = (struct Document *)(argp3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Link__setBorder" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  result = (PyObject *)Link__setBorder(arg1,arg2,arg3,arg4);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link__colors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Link *arg1 = (struct Link *) 0 ;
  struct Document *arg2 = (struct Document *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Link__colors", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Link, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link__colors" "', argument " "1"" of type '" "struct Link *""'"); 
  }
  arg1 = (struct Link *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Link__colors" "', argument " "2"" of type '" "struct Document *""'"); 
  }
  arg2 = (struct Document *)(argp2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Link__colors" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (PyObject *)Link__colors(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link__setColors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Link *arg1 = (struct Link *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  struct Document *arg3 = (struct Document *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Link__setColors", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Link, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link__setColors" "', argument " "1"" of type '" "struct Link *""'"); 
  }
  arg1 = (struct Link *)(argp1);
  arg2 = swig_obj[1];
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Link__setColors" "', argument " "3"" of type '" "struct Document *""'"); 
  }
  arg3 = (struct Document *)(argp3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Link__setColors" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  result = (PyObject *)Link__setColors(arg1,arg2,arg3,arg4);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link_uri(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Link *arg1 = (struct Link *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Link, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_uri" "', argument " "1"" of type '" "struct Link *""'"); 
  }
  arg1 = (struct Link *)(argp1);
  result = (PyObject *)Link_uri(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link_isExternal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Link *arg1 = (struct Link *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Link, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_isExternal" "', argument " "1"" of type '" "struct Link *""'"); 
  }
  arg1 = (struct Link *)(argp1);
  result = (PyObject *)Link_isExternal(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Link *arg1 = (struct Link *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Link, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_rect" "', argument " "1"" of type '" "struct Link *""'"); 
  }
  arg1 = (struct Link *)(argp1);
  result = (PyObject *)Link_rect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Link_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Link *arg1 = (struct Link *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct Link *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Link, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_next" "', argument " "1"" of type '" "struct Link *""'"); 
  }
  arg1 = (struct Link *)(argp1);
  result = (struct Link *)Link_next(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Link, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Link_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Link, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_DisplayList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct DisplayList *arg1 = (struct DisplayList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_DisplayList, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DisplayList" "', argument " "1"" of type '" "struct DisplayList *""'"); 
  }
  arg1 = (struct DisplayList *)(argp1);
  delete_DisplayList(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DisplayList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *swig_obj[1] ;
  struct DisplayList *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = swig_obj[0];
  {
    result = (struct DisplayList *)new_DisplayList(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DisplayList, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DisplayList_run(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct DisplayList *arg1 = (struct DisplayList *) 0 ;
  struct DeviceWrapper *arg2 = (struct DeviceWrapper *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject *arg4 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "DisplayList_run", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_DisplayList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DisplayList_run" "', argument " "1"" of type '" "struct DisplayList *""'"); 
  }
  arg1 = (struct DisplayList *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_DeviceWrapper, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DisplayList_run" "', argument " "2"" of type '" "struct DeviceWrapper *""'"); 
  }
  arg2 = (struct DeviceWrapper *)(argp2);
  arg3 = swig_obj[2];
  arg4 = swig_obj[3];
  {
    result = (PyObject *)DisplayList_run(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DisplayList_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct DisplayList *arg1 = (struct DisplayList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_DisplayList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DisplayList_rect" "', argument " "1"" of type '" "struct DisplayList *""'"); 
  }
  arg1 = (struct DisplayList *)(argp1);
  result = (PyObject *)DisplayList_rect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DisplayList_get_pixmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct DisplayList *arg1 = (struct DisplayList *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  struct Colorspace *arg3 = (struct Colorspace *) NULL ;
  int arg4 = (int) 0 ;
  PyObject *arg5 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[5] ;
  struct Pixmap *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "DisplayList_get_pixmap", 1, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_DisplayList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DisplayList_get_pixmap" "', argument " "1"" of type '" "struct DisplayList *""'"); 
  }
  arg1 = (struct DisplayList *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  if (swig_obj[2]) {
    res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_Colorspace, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DisplayList_get_pixmap" "', argument " "3"" of type '" "struct Colorspace *""'"); 
    }
    arg3 = (struct Colorspace *)(argp3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "DisplayList_get_pixmap" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (swig_obj[4]) {
    arg5 = swig_obj[4];
  }
  {
    result = (struct Pixmap *)DisplayList_get_pixmap(arg1,arg2,arg3,arg4,arg5);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Pixmap, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DisplayList_get_textpage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct DisplayList *arg1 = (struct DisplayList *) 0 ;
  int arg2 = (int) 3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  struct TextPage *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "DisplayList_get_textpage", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_DisplayList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DisplayList_get_textpage" "', argument " "1"" of type '" "struct DisplayList *""'"); 
  }
  arg1 = (struct DisplayList *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DisplayList_get_textpage" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (struct TextPage *)DisplayList_get_textpage(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TextPage, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *DisplayList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_DisplayList, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *DisplayList_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_delete_TextPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextPage *arg1 = (struct TextPage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextPage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TextPage" "', argument " "1"" of type '" "struct TextPage *""'"); 
  }
  arg1 = (struct TextPage *)(argp1);
  delete_TextPage(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_TextPage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *swig_obj[1] ;
  struct TextPage *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = swig_obj[0];
  {
    result = (struct TextPage *)new_TextPage(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TextPage, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage_search(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextPage *arg1 = (struct TextPage *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 = (int) 0 ;
  int arg4 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TextPage_search", 2, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextPage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage_search" "', argument " "1"" of type '" "struct TextPage *""'"); 
  }
  arg1 = (struct TextPage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TextPage_search" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TextPage_search" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TextPage_search" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (PyObject *)TextPage_search(arg1,(char const *)arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage__getNewBlockList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextPage *arg1 = (struct TextPage *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TextPage__getNewBlockList", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextPage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage__getNewBlockList" "', argument " "1"" of type '" "struct TextPage *""'"); 
  }
  arg1 = (struct TextPage *)(argp1);
  arg2 = swig_obj[1];
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TextPage__getNewBlockList" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    result = (PyObject *)TextPage__getNewBlockList(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage_extractIMGINFO(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextPage *arg1 = (struct TextPage *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TextPage_extractIMGINFO", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextPage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage_extractIMGINFO" "', argument " "1"" of type '" "struct TextPage *""'"); 
  }
  arg1 = (struct TextPage *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TextPage_extractIMGINFO" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (PyObject *)TextPage_extractIMGINFO(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage_extractBLOCKS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextPage *arg1 = (struct TextPage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextPage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage_extractBLOCKS" "', argument " "1"" of type '" "struct TextPage *""'"); 
  }
  arg1 = (struct TextPage *)(argp1);
  {
    result = (PyObject *)TextPage_extractBLOCKS(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage_extractWORDS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextPage *arg1 = (struct TextPage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextPage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage_extractWORDS" "', argument " "1"" of type '" "struct TextPage *""'"); 
  }
  arg1 = (struct TextPage *)(argp1);
  {
    result = (PyObject *)TextPage_extractWORDS(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextPage *arg1 = (struct TextPage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextPage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage_rect" "', argument " "1"" of type '" "struct TextPage *""'"); 
  }
  arg1 = (struct TextPage *)(argp1);
  result = (PyObject *)TextPage_rect(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage__extractText(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextPage *arg1 = (struct TextPage *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TextPage__extractText", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextPage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage__extractText" "', argument " "1"" of type '" "struct TextPage *""'"); 
  }
  arg1 = (struct TextPage *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TextPage__extractText" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    result = (PyObject *)TextPage__extractText(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextPage_extractSelection(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextPage *arg1 = (struct TextPage *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TextPage_extractSelection", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextPage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextPage_extractSelection" "', argument " "1"" of type '" "struct TextPage *""'"); 
  }
  arg1 = (struct TextPage *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)TextPage_extractSelection(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *TextPage_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_TextPage, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *TextPage_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_delete_Graftmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Graftmap *arg1 = (struct Graftmap *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Graftmap, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Graftmap" "', argument " "1"" of type '" "struct Graftmap *""'"); 
  }
  arg1 = (struct Graftmap *)(argp1);
  delete_Graftmap(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Graftmap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Document *arg1 = (struct Document *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  struct Graftmap *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Graftmap" "', argument " "1"" of type '" "struct Document *""'"); 
  }
  arg1 = (struct Document *)(argp1);
  {
    result = (struct Graftmap *)new_Graftmap(arg1);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Graftmap, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Graftmap_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Graftmap, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Graftmap_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_delete_TextWriter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextWriter *arg1 = (struct TextWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextWriter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TextWriter" "', argument " "1"" of type '" "struct TextWriter *""'"); 
  }
  arg1 = (struct TextWriter *)(argp1);
  delete_TextWriter(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_TextWriter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  float arg2 = (float) 1 ;
  PyObject *arg3 = (PyObject *) NULL ;
  float val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[3] ;
  struct TextWriter *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_TextWriter", 1, 3, swig_obj)) SWIG_fail;
  arg1 = swig_obj[0];
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_float(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_TextWriter" "', argument " "2"" of type '" "float""'");
    } 
    arg2 = (float)(val2);
  }
  if (swig_obj[2]) {
    arg3 = swig_obj[2];
  }
  {
    result = (struct TextWriter *)new_TextWriter(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TextWriter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextWriter_append(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextWriter *arg1 = (struct TextWriter *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  char *arg3 = (char *) 0 ;
  struct Font *arg4 = (struct Font *) NULL ;
  float arg5 = (float) 11 ;
  char *arg6 = (char *) NULL ;
  int arg7 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject *swig_obj[7] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TextWriter_append", 3, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextWriter_append" "', argument " "1"" of type '" "struct TextWriter *""'"); 
  }
  arg1 = (struct TextWriter *)(argp1);
  arg2 = swig_obj[1];
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "TextWriter_append" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  if (swig_obj[3]) {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4,SWIGTYPE_p_Font, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "TextWriter_append" "', argument " "4"" of type '" "struct Font *""'"); 
    }
    arg4 = (struct Font *)(argp4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_float(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "TextWriter_append" "', argument " "5"" of type '" "float""'");
    } 
    arg5 = (float)(val5);
  }
  if (swig_obj[5]) {
    res6 = SWIG_AsCharPtrAndSize(swig_obj[5], &buf6, NULL, &alloc6);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "TextWriter_append" "', argument " "6"" of type '" "char *""'");
    }
    arg6 = (char *)(buf6);
  }
  if (swig_obj[6]) {
    ecode7 = SWIG_AsVal_int(swig_obj[6], &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "TextWriter_append" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    result = (PyObject *)TextWriter_append(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  if (alloc6 == SWIG_NEWOBJ) free((char*)buf6);
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextWriter__bbox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextWriter *arg1 = (struct TextWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextWriter__bbox" "', argument " "1"" of type '" "struct TextWriter *""'"); 
  }
  arg1 = (struct TextWriter *)(argp1);
  result = (PyObject *)TextWriter__bbox(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextWriter_write_text(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct TextWriter *arg1 = (struct TextWriter *) 0 ;
  struct Page *arg2 = (struct Page *) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  float arg4 = (float) -1 ;
  int arg5 = (int) 1 ;
  PyObject *arg6 = (PyObject *) NULL ;
  PyObject *arg7 = (PyObject *) NULL ;
  int arg8 = (int) 0 ;
  int arg9 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[9] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "TextWriter_write_text", 2, 9, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_TextWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextWriter_write_text" "', argument " "1"" of type '" "struct TextWriter *""'"); 
  }
  arg1 = (struct TextWriter *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TextWriter_write_text" "', argument " "2"" of type '" "struct Page *""'"); 
  }
  arg2 = (struct Page *)(argp2);
  if (swig_obj[2]) {
    arg3 = swig_obj[2];
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_float(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TextWriter_write_text" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "TextWriter_write_text" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (swig_obj[5]) {
    arg6 = swig_obj[5];
  }
  if (swig_obj[6]) {
    arg7 = swig_obj[6];
  }
  if (swig_obj[7]) {
    ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "TextWriter_write_text" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (swig_obj[8]) {
    ecode9 = SWIG_AsVal_int(swig_obj[8], &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "TextWriter_write_text" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  {
    result = (PyObject *)TextWriter_write_text(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *TextWriter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_TextWriter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *TextWriter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_delete_Font(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Font" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  delete_Font(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Font(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) NULL ;
  char *arg2 = (char *) NULL ;
  PyObject *arg3 = (PyObject *) NULL ;
  int arg4 = (int) 0 ;
  char *arg5 = (char *) NULL ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 0 ;
  int arg8 = (int) 0 ;
  int arg9 = (int) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  PyObject *swig_obj[9] ;
  struct Font *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_Font", 0, 9, swig_obj)) SWIG_fail;
  if (swig_obj[0]) {
    res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Font" "', argument " "1"" of type '" "char *""'");
    }
    arg1 = (char *)(buf1);
  }
  if (swig_obj[1]) {
    res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Font" "', argument " "2"" of type '" "char *""'");
    }
    arg2 = (char *)(buf2);
  }
  if (swig_obj[2]) {
    arg3 = swig_obj[2];
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Font" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (swig_obj[4]) {
    res5 = SWIG_AsCharPtrAndSize(swig_obj[4], &buf5, NULL, &alloc5);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_Font" "', argument " "5"" of type '" "char *""'");
    }
    arg5 = (char *)(buf5);
  }
  if (swig_obj[5]) {
    ecode6 = SWIG_AsVal_int(swig_obj[5], &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Font" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (swig_obj[6]) {
    ecode7 = SWIG_AsVal_int(swig_obj[6], &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_Font" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (swig_obj[7]) {
    ecode8 = SWIG_AsVal_int(swig_obj[7], &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_Font" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (swig_obj[8]) {
    ecode9 = SWIG_AsVal_int(swig_obj[8], &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "new_Font" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  {
    result = (struct Font *)new_Font(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Font, SWIG_POINTER_NEW |  0 );
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) free((char*)buf1);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc5 == SWIG_NEWOBJ) free((char*)buf5);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Font_glyph_advance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  int arg2 ;
  char *arg3 = (char *) NULL ;
  int arg4 = (int) 0 ;
  int arg5 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  float result;
  
  if (!SWIG_Python_UnpackTuple(args, "Font_glyph_advance", 2, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Font_glyph_advance" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Font_glyph_advance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Font_glyph_advance" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Font_glyph_advance" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Font_glyph_advance" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  result = (float)Font_glyph_advance(arg1,arg2,arg3,arg4,arg5);
  resultobj = SWIG_From_float((float)(result));
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Font_glyph_bbox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  int arg2 ;
  char *arg3 = (char *) NULL ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Font_glyph_bbox", 2, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Font_glyph_bbox" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Font_glyph_bbox" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Font_glyph_bbox" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Font_glyph_bbox" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  result = (PyObject *)Font_glyph_bbox(arg1,arg2,arg3,arg4);
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Font_has_glyph(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  int arg2 ;
  char *arg3 = (char *) NULL ;
  int arg4 = (int) 0 ;
  int arg5 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Font_has_glyph", 2, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Font_has_glyph" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Font_has_glyph" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (swig_obj[2]) {
    res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Font_has_glyph" "', argument " "3"" of type '" "char *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Font_has_glyph" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Font_has_glyph" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  result = (PyObject *)Font_has_glyph(arg1,arg2,arg3,arg4,arg5);
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Font__valid_unicodes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Font__valid_unicodes", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Font__valid_unicodes" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  arg2 = swig_obj[1];
  Font__valid_unicodes(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Font_flags(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Font_flags" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  result = (PyObject *)Font_flags(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Font_is_writable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Font_is_writable" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  result = (PyObject *)Font_is_writable(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Font_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Font_name" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  result = (PyObject *)Font_name(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Font_glyph_count(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Font_glyph_count" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  result = (int)Font_glyph_count(arg1);
  resultobj = SWIG_From_int((int)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Font_buffer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Font_buffer" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  result = (PyObject *)Font_buffer(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Font_bbox(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Font_bbox" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  result = (PyObject *)Font_bbox(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Font_ascender(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  float result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Font_ascender" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  result = (float)Font_ascender(arg1);
  resultobj = SWIG_From_float((float)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Font_descender(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Font *arg1 = (struct Font *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  float result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Font, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Font_descender" "', argument " "1"" of type '" "struct Font *""'"); 
  }
  arg1 = (struct Font *)(argp1);
  result = (float)Font_descender(arg1);
  resultobj = SWIG_From_float((float)(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Font_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Font, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Font_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_Tools_gen_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_gen_id" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_gen_id(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_set_icc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_set_icc", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_set_icc" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tools_set_icc" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    result = (PyObject *)Tools_set_icc(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_set_annot_stem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  char *arg2 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_set_annot_stem", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_set_annot_stem" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  if (swig_obj[1]) {
    res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools_set_annot_stem" "', argument " "2"" of type '" "char *""'");
    }
    arg2 = (char *)(buf2);
  }
  result = (char *)Tools_set_annot_stem(arg1,arg2);
  resultobj = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_set_small_glyph_heights(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_set_small_glyph_heights", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_set_small_glyph_heights" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  result = (PyObject *)Tools_set_small_glyph_heights(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_set_subset_fontnames(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_set_subset_fontnames", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_set_subset_fontnames" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  result = (PyObject *)Tools_set_subset_fontnames(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_unset_quad_corrections(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_unset_quad_corrections", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_unset_quad_corrections" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  result = (PyObject *)Tools_unset_quad_corrections(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_store_shrink(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_store_shrink", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_store_shrink" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tools_store_shrink" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  result = (PyObject *)Tools_store_shrink(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_store_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_store_size" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_store_size(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_store_maxsize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_store_maxsize" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_store_maxsize(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_show_aa_level(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_show_aa_level" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_show_aa_level(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_set_aa_level(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_set_aa_level", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_set_aa_level" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tools_set_aa_level" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  Tools_set_aa_level(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_set_graphics_min_line_width(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_set_graphics_min_line_width", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_set_graphics_min_line_width" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  ecode2 = SWIG_AsVal_float(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tools_set_graphics_min_line_width" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  Tools_set_graphics_min_line_width(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_image_profile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_image_profile", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_image_profile" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Tools_image_profile" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    result = (PyObject *)Tools_image_profile(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__rotate_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct Page *arg2 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__rotate_matrix", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__rotate_matrix" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__rotate_matrix" "', argument " "2"" of type '" "struct Page *""'"); 
  }
  arg2 = (struct Page *)(argp2);
  result = (PyObject *)Tools__rotate_matrix(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__derotate_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct Page *arg2 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__derotate_matrix", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__derotate_matrix" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__derotate_matrix" "', argument " "2"" of type '" "struct Page *""'"); 
  }
  arg2 = (struct Page *)(argp2);
  result = (PyObject *)Tools__derotate_matrix(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_fitz_config(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_fitz_config" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_fitz_config(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_glyph_cache_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_glyph_cache_empty" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  Tools_glyph_cache_empty(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__fill_widget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct Annot *arg2 = (struct Annot *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__fill_widget", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__fill_widget" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__fill_widget" "', argument " "2"" of type '" "struct Annot *""'"); 
  }
  arg2 = (struct Annot *)(argp2);
  arg3 = swig_obj[2];
  {
    result = (PyObject *)Tools__fill_widget(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__save_widget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct Annot *arg2 = (struct Annot *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__save_widget", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__save_widget" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__save_widget" "', argument " "2"" of type '" "struct Annot *""'"); 
  }
  arg2 = (struct Annot *)(argp2);
  arg3 = swig_obj[2];
  {
    result = (PyObject *)Tools__save_widget(arg1,arg2,arg3);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__reset_widget(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct Annot *arg2 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__reset_widget", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__reset_widget" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__reset_widget" "', argument " "2"" of type '" "struct Annot *""'"); 
  }
  arg2 = (struct Annot *)(argp2);
  {
    result = (PyObject *)Tools__reset_widget(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__parse_da(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct Annot *arg2 = (struct Annot *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__parse_da", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__parse_da" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__parse_da" "', argument " "2"" of type '" "struct Annot *""'"); 
  }
  arg2 = (struct Annot *)(argp2);
  {
    result = (PyObject *)Tools__parse_da(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__update_da(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct Annot *arg2 = (struct Annot *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__update_da", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__update_da" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Annot, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__update_da" "', argument " "2"" of type '" "struct Annot *""'"); 
  }
  arg2 = (struct Annot *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Tools__update_da" "', argument " "3"" of type '" "char *""'");
  }
  arg3 = (char *)(buf3);
  result = (PyObject *)Tools__update_da(arg1,arg2,arg3);
  resultobj = result;
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__get_all_contents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct Page *arg2 = (struct Page *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__get_all_contents", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__get_all_contents" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__get_all_contents" "', argument " "2"" of type '" "struct Page *""'"); 
  }
  arg2 = (struct Page *)(argp2);
  {
    result = (PyObject *)Tools__get_all_contents(arg1,arg2);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__insert_contents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct Page *arg2 = (struct Page *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  int arg4 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__insert_contents", 3, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__insert_contents" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Page, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__insert_contents" "', argument " "2"" of type '" "struct Page *""'"); 
  }
  arg2 = (struct Page *)(argp2);
  arg3 = swig_obj[2];
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Tools__insert_contents" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    result = (PyObject *)Tools__insert_contents(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_mupdf_version(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_mupdf_version" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  result = (PyObject *)Tools_mupdf_version(arg1);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_mupdf_warnings(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  int arg2 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_mupdf_warnings", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_mupdf_warnings" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Tools_mupdf_warnings" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  result = (PyObject *)Tools_mupdf_warnings(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__int_from_language(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__int_from_language", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__int_from_language" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__int_from_language" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  result = (int)Tools__int_from_language(arg1,arg2);
  resultobj = SWIG_From_int((int)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_reset_mupdf_warnings(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_reset_mupdf_warnings" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  Tools_reset_mupdf_warnings(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_mupdf_display_errors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_mupdf_display_errors", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_mupdf_display_errors" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  result = (PyObject *)Tools_mupdf_display_errors(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_mupdf_display_warnings(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_mupdf_display_warnings", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_mupdf_display_warnings" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  if (swig_obj[1]) {
    arg2 = swig_obj[1];
  }
  result = (PyObject *)Tools_mupdf_display_warnings(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__transform_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__transform_rect", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__transform_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__transform_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__intersect_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__intersect_rect", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__intersect_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__intersect_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__include_point_in_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__include_point_in_rect", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__include_point_in_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__include_point_in_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__transform_point(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__transform_point", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__transform_point" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__transform_point(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__union_rect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__union_rect", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__union_rect" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__union_rect(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__concat_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__concat_matrix", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__concat_matrix" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__concat_matrix(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__invert_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__invert_matrix", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__invert_matrix" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  result = (PyObject *)Tools__invert_matrix(arg1,arg2);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__measure_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  float arg4 ;
  int arg5 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  float result;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__measure_string", 4, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__measure_string" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(swig_obj[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools__measure_string" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(swig_obj[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Tools__measure_string" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_float(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Tools__measure_string" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = (float)(val4);
  if (swig_obj[4]) {
    ecode5 = SWIG_AsVal_int(swig_obj[4], &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Tools__measure_string" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  result = (float)Tools__measure_string(arg1,(char const *)arg2,(char const *)arg3,arg4,arg5);
  resultobj = SWIG_From_float((float)(result));
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) free((char*)buf2);
  if (alloc3 == SWIG_NEWOBJ) free((char*)buf3);
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__sine_between(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  PyObject *arg4 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__sine_between", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__sine_between" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  arg4 = swig_obj[3];
  result = (PyObject *)Tools__sine_between(arg1,arg2,arg3,arg4);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__hor_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__hor_matrix", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__hor_matrix" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__hor_matrix(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools__point_in_quad(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools__point_in_quad", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools__point_in_quad" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  arg2 = swig_obj[1];
  arg3 = swig_obj[2];
  result = (PyObject *)Tools__point_in_quad(arg1,arg2,arg3);
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Tools_set_font_width(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  struct Document *arg2 = (struct Document *) 0 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "Tools_set_font_width", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Tools_set_font_width" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_Document, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Tools_set_font_width" "', argument " "2"" of type '" "struct Document *""'"); 
  }
  arg2 = (struct Document *)(argp2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Tools_set_font_width" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Tools_set_font_width" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    result = (PyObject *)Tools_set_font_width(arg1,arg2,arg3,arg4);
    if (!result) {
      PyErr_SetString(PyExc_RuntimeError, fz_caught_message(gctx));return NULL;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Tools(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_Tools", 0, 0, 0)) SWIG_fail;
  result = (struct Tools *)calloc(1, sizeof(struct Tools));
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Tools, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Tools(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  struct Tools *arg1 = (struct Tools *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_Tools, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Tools" "', argument " "1"" of type '" "struct Tools *""'"); 
  }
  arg1 = (struct Tools *)(argp1);
  free((char *) arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Tools_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Tools, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Tools_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

static PyMethodDef SwigMethods[] = {
	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { "delete_Document", _wrap_delete_Document, METH_O, NULL},
	 { "new_Document", _wrap_new_Document, METH_VARARGS, NULL},
	 { "Document_close", _wrap_Document_close, METH_O, NULL},
	 { "Document_load_page", _wrap_Document_load_page, METH_VARARGS, NULL},
	 { "Document__remove_links_to", _wrap_Document__remove_links_to, METH_VARARGS, NULL},
	 { "Document__loadOutline", _wrap_Document__loadOutline, METH_O, NULL},
	 { "Document__dropOutline", _wrap_Document__dropOutline, METH_VARARGS, NULL},
	 { "Document__insert_font", _wrap_Document__insert_font, METH_VARARGS, NULL},
	 { "Document_get_outline_xrefs", _wrap_Document_get_outline_xrefs, METH_O, NULL},
	 { "Document_xref_get_keys", _wrap_Document_xref_get_keys, METH_VARARGS, NULL},
	 { "Document_xref_get_key", _wrap_Document_xref_get_key, METH_VARARGS, NULL},
	 { "Document_xref_set_key", _wrap_Document_xref_set_key, METH_VARARGS, NULL},
	 { "Document__extend_toc_items", _wrap_Document__extend_toc_items, METH_VARARGS, NULL},
	 { "Document__embfile_names", _wrap_Document__embfile_names, METH_VARARGS, NULL},
	 { "Document__embfile_del", _wrap_Document__embfile_del, METH_VARARGS, NULL},
	 { "Document__embfile_info", _wrap_Document__embfile_info, METH_VARARGS, NULL},
	 { "Document__embfile_upd", _wrap_Document__embfile_upd, METH_VARARGS, NULL},
	 { "Document__embeddedFileGet", _wrap_Document__embeddedFileGet, METH_VARARGS, NULL},
	 { "Document__embfile_add", _wrap_Document__embfile_add, METH_VARARGS, NULL},
	 { "Document_convert_to_pdf", _wrap_Document_convert_to_pdf, METH_VARARGS, NULL},
	 { "Document_page_count", _wrap_Document_page_count, METH_O, NULL},
	 { "Document_chapter_count", _wrap_Document_chapter_count, METH_O, NULL},
	 { "Document_last_location", _wrap_Document_last_location, METH_O, NULL},
	 { "Document_chapter_page_count", _wrap_Document_chapter_page_count, METH_VARARGS, NULL},
	 { "Document_prev_location", _wrap_Document_prev_location, METH_VARARGS, NULL},
	 { "Document_next_location", _wrap_Document_next_location, METH_VARARGS, NULL},
	 { "Document_location_from_page_number", _wrap_Document_location_from_page_number, METH_VARARGS, NULL},
	 { "Document_page_number_from_location", _wrap_Document_page_number_from_location, METH_VARARGS, NULL},
	 { "Document__getMetadata", _wrap_Document__getMetadata, METH_VARARGS, NULL},
	 { "Document_needs_pass", _wrap_Document_needs_pass, METH_O, NULL},
	 { "Document_language", _wrap_Document_language, METH_O, NULL},
	 { "Document_set_language", _wrap_Document_set_language, METH_VARARGS, NULL},
	 { "Document_resolve_link", _wrap_Document_resolve_link, METH_VARARGS, NULL},
	 { "Document_layout", _wrap_Document_layout, METH_VARARGS, NULL},
	 { "Document_make_bookmark", _wrap_Document_make_bookmark, METH_VARARGS, NULL},
	 { "Document_find_bookmark", _wrap_Document_find_bookmark, METH_VARARGS, NULL},
	 { "Document_is_reflowable", _wrap_Document_is_reflowable, METH_O, NULL},
	 { "Document__deleteObject", _wrap_Document__deleteObject, METH_VARARGS, NULL},
	 { "Document_pdf_catalog", _wrap_Document_pdf_catalog, METH_O, NULL},
	 { "Document__getPDFfileid", _wrap_Document__getPDFfileid, METH_O, NULL},
	 { "Document_is_pdf", _wrap_Document_is_pdf, METH_O, NULL},
	 { "Document_has_xref_streams", _wrap_Document_has_xref_streams, METH_O, NULL},
	 { "Document_has_old_style_xrefs", _wrap_Document_has_old_style_xrefs, METH_O, NULL},
	 { "Document_is_dirty", _wrap_Document_is_dirty, METH_O, NULL},
	 { "Document_can_save_incrementally", _wrap_Document_can_save_incrementally, METH_O, NULL},
	 { "Document_is_repaired", _wrap_Document_is_repaired, METH_O, NULL},
	 { "Document_authenticate", _wrap_Document_authenticate, METH_VARARGS, NULL},
	 { "Document_save", _wrap_Document_save, METH_VARARGS, NULL},
	 { "Document_insert_pdf", _wrap_Document_insert_pdf, METH_VARARGS, NULL},
	 { "Document__newPage", _wrap_Document__newPage, METH_VARARGS, NULL},
	 { "Document_select", _wrap_Document_select, METH_VARARGS, NULL},
	 { "Document__delete_page", _wrap_Document__delete_page, METH_VARARGS, NULL},
	 { "Document_permissions", _wrap_Document_permissions, METH_O, NULL},
	 { "Document__get_char_widths", _wrap_Document__get_char_widths, METH_VARARGS, NULL},
	 { "Document_page_xref", _wrap_Document_page_xref, METH_VARARGS, NULL},
	 { "Document_page_annot_xrefs", _wrap_Document_page_annot_xrefs, METH_VARARGS, NULL},
	 { "Document_page_cropbox", _wrap_Document_page_cropbox, METH_VARARGS, NULL},
	 { "Document__getPageInfo", _wrap_Document__getPageInfo, METH_VARARGS, NULL},
	 { "Document_extract_font", _wrap_Document_extract_font, METH_VARARGS, NULL},
	 { "Document_extract_image", _wrap_Document_extract_image, METH_VARARGS, NULL},
	 { "Document__delToC", _wrap_Document__delToC, METH_O, NULL},
	 { "Document_is_stream", _wrap_Document_is_stream, METH_VARARGS, NULL},
	 { "Document_need_appearances", _wrap_Document_need_appearances, METH_VARARGS, NULL},
	 { "Document_get_sigflags", _wrap_Document_get_sigflags, METH_O, NULL},
	 { "Document_is_form_pdf", _wrap_Document_is_form_pdf, METH_O, NULL},
	 { "Document_FormFonts", _wrap_Document_FormFonts, METH_O, NULL},
	 { "Document__addFormFont", _wrap_Document__addFormFont, METH_VARARGS, NULL},
	 { "Document__getOLRootNumber", _wrap_Document__getOLRootNumber, METH_O, NULL},
	 { "Document_get_new_xref", _wrap_Document_get_new_xref, METH_O, NULL},
	 { "Document_xref_length", _wrap_Document_xref_length, METH_O, NULL},
	 { "Document_get_xml_metadata", _wrap_Document_get_xml_metadata, METH_O, NULL},
	 { "Document_xref_xml_metadata", _wrap_Document_xref_xml_metadata, METH_O, NULL},
	 { "Document_del_xml_metadata", _wrap_Document_del_xml_metadata, METH_O, NULL},
	 { "Document_set_xml_metadata", _wrap_Document_set_xml_metadata, METH_VARARGS, NULL},
	 { "Document_xref_object", _wrap_Document_xref_object, METH_VARARGS, NULL},
	 { "Document_xref_stream_raw", _wrap_Document_xref_stream_raw, METH_VARARGS, NULL},
	 { "Document_xref_stream", _wrap_Document_xref_stream, METH_VARARGS, NULL},
	 { "Document_update_object", _wrap_Document_update_object, METH_VARARGS, NULL},
	 { "Document_update_stream", _wrap_Document_update_stream, METH_VARARGS, NULL},
	 { "Document__make_page_map", _wrap_Document__make_page_map, METH_O, NULL},
	 { "Document_fullcopy_page", _wrap_Document_fullcopy_page, METH_VARARGS, NULL},
	 { "Document__move_copy_page", _wrap_Document__move_copy_page, METH_VARARGS, NULL},
	 { "Document__remove_toc_item", _wrap_Document__remove_toc_item, METH_VARARGS, NULL},
	 { "Document__update_toc_item", _wrap_Document__update_toc_item, METH_VARARGS, NULL},
	 { "Document__get_page_labels", _wrap_Document__get_page_labels, METH_O, NULL},
	 { "Document__set_page_labels", _wrap_Document__set_page_labels, METH_VARARGS, NULL},
	 { "Document_get_layers", _wrap_Document_get_layers, METH_O, NULL},
	 { "Document_switch_layer", _wrap_Document_switch_layer, METH_VARARGS, NULL},
	 { "Document_get_layer", _wrap_Document_get_layer, METH_VARARGS, NULL},
	 { "Document_set_layer", _wrap_Document_set_layer, METH_VARARGS, NULL},
	 { "Document_add_layer", _wrap_Document_add_layer, METH_VARARGS, NULL},
	 { "Document_layer_ui_configs", _wrap_Document_layer_ui_configs, METH_O, NULL},
	 { "Document_set_layer_ui_config", _wrap_Document_set_layer_ui_config, METH_VARARGS, NULL},
	 { "Document_get_ocgs", _wrap_Document_get_ocgs, METH_O, NULL},
	 { "Document_add_ocg", _wrap_Document_add_ocg, METH_VARARGS, NULL},
	 { "Document_swigregister", Document_swigregister, METH_O, NULL},
	 { "Document_swiginit", Document_swiginit, METH_VARARGS, NULL},
	 { "delete_Page", _wrap_delete_Page, METH_O, NULL},
	 { "Page_bound", _wrap_Page_bound, METH_O, NULL},
	 { "Page_get_image_bbox", _wrap_Page_get_image_bbox, METH_VARARGS, NULL},
	 { "Page_run", _wrap_Page_run, METH_VARARGS, NULL},
	 { "Page__get_text_page", _wrap_Page__get_text_page, METH_VARARGS, NULL},
	 { "Page_language", _wrap_Page_language, METH_O, NULL},
	 { "Page_set_language", _wrap_Page_set_language, METH_VARARGS, NULL},
	 { "Page_get_svg_image", _wrap_Page_get_svg_image, METH_VARARGS, NULL},
	 { "Page__set_opacity", _wrap_Page__set_opacity, METH_VARARGS, NULL},
	 { "Page__add_caret_annot", _wrap_Page__add_caret_annot, METH_VARARGS, NULL},
	 { "Page__add_redact_annot", _wrap_Page__add_redact_annot, METH_VARARGS, NULL},
	 { "Page__add_line_annot", _wrap_Page__add_line_annot, METH_VARARGS, NULL},
	 { "Page__add_text_annot", _wrap_Page__add_text_annot, METH_VARARGS, NULL},
	 { "Page__add_ink_annot", _wrap_Page__add_ink_annot, METH_VARARGS, NULL},
	 { "Page__add_stamp_annot", _wrap_Page__add_stamp_annot, METH_VARARGS, NULL},
	 { "Page__add_file_annot", _wrap_Page__add_file_annot, METH_VARARGS, NULL},
	 { "Page__add_text_marker", _wrap_Page__add_text_marker, METH_VARARGS, NULL},
	 { "Page__add_square_or_circle", _wrap_Page__add_square_or_circle, METH_VARARGS, NULL},
	 { "Page__add_multiline", _wrap_Page__add_multiline, METH_VARARGS, NULL},
	 { "Page__add_freetext_annot", _wrap_Page__add_freetext_annot, METH_VARARGS, NULL},
	 { "Page__load_annot", _wrap_Page__load_annot, METH_VARARGS, NULL},
	 { "Page__get_resource_properties", _wrap_Page__get_resource_properties, METH_O, NULL},
	 { "Page__set_resource_property", _wrap_Page__set_resource_property, METH_VARARGS, NULL},
	 { "Page_annot_names", _wrap_Page_annot_names, METH_O, NULL},
	 { "Page_annot_xrefs", _wrap_Page_annot_xrefs, METH_O, NULL},
	 { "Page__addWidget", _wrap_Page__addWidget, METH_VARARGS, NULL},
	 { "Page_get_displaylist", _wrap_Page_get_displaylist, METH_VARARGS, NULL},
	 { "Page__getDrawings", _wrap_Page__getDrawings, METH_O, NULL},
	 { "Page__apply_redactions", _wrap_Page__apply_redactions, METH_VARARGS, NULL},
	 { "Page__makePixmap", _wrap_Page__makePixmap, METH_VARARGS, NULL},
	 { "Page_set_mediabox", _wrap_Page_set_mediabox, METH_VARARGS, NULL},
	 { "Page_set_cropbox", _wrap_Page_set_cropbox, METH_VARARGS, NULL},
	 { "Page_load_links", _wrap_Page_load_links, METH_O, NULL},
	 { "Page_first_annot", _wrap_Page_first_annot, METH_O, NULL},
	 { "Page_first_widget", _wrap_Page_first_widget, METH_O, NULL},
	 { "Page_delete_link", _wrap_Page_delete_link, METH_VARARGS, NULL},
	 { "Page_delete_annot", _wrap_Page_delete_annot, METH_VARARGS, NULL},
	 { "Page_mediabox", _wrap_Page_mediabox, METH_O, NULL},
	 { "Page_cropbox", _wrap_Page_cropbox, METH_O, NULL},
	 { "Page_rotation", _wrap_Page_rotation, METH_O, NULL},
	 { "Page_set_rotation", _wrap_Page_set_rotation, METH_VARARGS, NULL},
	 { "Page__addAnnot_FromString", _wrap_Page__addAnnot_FromString, METH_VARARGS, NULL},
	 { "Page_clean_contents", _wrap_Page_clean_contents, METH_VARARGS, NULL},
	 { "Page__show_pdf_page", _wrap_Page__show_pdf_page, METH_VARARGS, NULL},
	 { "Page__insert_image", _wrap_Page__insert_image, METH_VARARGS, NULL},
	 { "Page_refresh", _wrap_Page_refresh, METH_O, NULL},
	 { "Page__insertFont", _wrap_Page__insertFont, METH_VARARGS, NULL},
	 { "Page_transformation_matrix", _wrap_Page_transformation_matrix, METH_O, NULL},
	 { "Page_get_contents", _wrap_Page_get_contents, METH_O, NULL},
	 { "Page_swigregister", Page_swigregister, METH_O, NULL},
	 { "delete_Pixmap", _wrap_delete_Pixmap, METH_O, NULL},
	 { "new_Pixmap", _wrap_new_Pixmap, METH_VARARGS, NULL},
	 { "Pixmap_shrink", _wrap_Pixmap_shrink, METH_VARARGS, NULL},
	 { "Pixmap_gamma_with", _wrap_Pixmap_gamma_with, METH_VARARGS, NULL},
	 { "Pixmap_tint_with", _wrap_Pixmap_tint_with, METH_VARARGS, NULL},
	 { "Pixmap_clear_with", _wrap_Pixmap_clear_with, METH_VARARGS, NULL},
	 { "Pixmap_copy", _wrap_Pixmap_copy, METH_VARARGS, NULL},
	 { "Pixmap_set_alpha", _wrap_Pixmap_set_alpha, METH_VARARGS, NULL},
	 { "Pixmap__tobytes", _wrap_Pixmap__tobytes, METH_VARARGS, NULL},
	 { "Pixmap__writeIMG", _wrap_Pixmap__writeIMG, METH_VARARGS, NULL},
	 { "Pixmap_invert_irect", _wrap_Pixmap_invert_irect, METH_VARARGS, NULL},
	 { "Pixmap_pixel", _wrap_Pixmap_pixel, METH_VARARGS, NULL},
	 { "Pixmap_set_pixel", _wrap_Pixmap_set_pixel, METH_VARARGS, NULL},
	 { "Pixmap_set_origin", _wrap_Pixmap_set_origin, METH_VARARGS, NULL},
	 { "Pixmap_set_dpi", _wrap_Pixmap_set_dpi, METH_VARARGS, NULL},
	 { "Pixmap_set_rect", _wrap_Pixmap_set_rect, METH_VARARGS, NULL},
	 { "Pixmap_is_monochrome", _wrap_Pixmap_is_monochrome, METH_O, NULL},
	 { "Pixmap_digest", _wrap_Pixmap_digest, METH_O, NULL},
	 { "Pixmap_stride", _wrap_Pixmap_stride, METH_O, NULL},
	 { "Pixmap_xres", _wrap_Pixmap_xres, METH_O, NULL},
	 { "Pixmap_yres", _wrap_Pixmap_yres, METH_O, NULL},
	 { "Pixmap_w", _wrap_Pixmap_w, METH_O, NULL},
	 { "Pixmap_h", _wrap_Pixmap_h, METH_O, NULL},
	 { "Pixmap_x", _wrap_Pixmap_x, METH_O, NULL},
	 { "Pixmap_y", _wrap_Pixmap_y, METH_O, NULL},
	 { "Pixmap_n", _wrap_Pixmap_n, METH_O, NULL},
	 { "Pixmap_alpha", _wrap_Pixmap_alpha, METH_O, NULL},
	 { "Pixmap_colorspace", _wrap_Pixmap_colorspace, METH_O, NULL},
	 { "Pixmap_irect", _wrap_Pixmap_irect, METH_O, NULL},
	 { "Pixmap_size", _wrap_Pixmap_size, METH_O, NULL},
	 { "Pixmap_samples", _wrap_Pixmap_samples, METH_O, NULL},
	 { "Pixmap_swigregister", Pixmap_swigregister, METH_O, NULL},
	 { "Pixmap_swiginit", Pixmap_swiginit, METH_VARARGS, NULL},
	 { "delete_Colorspace", _wrap_delete_Colorspace, METH_O, NULL},
	 { "new_Colorspace", _wrap_new_Colorspace, METH_O, NULL},
	 { "Colorspace_n", _wrap_Colorspace_n, METH_O, NULL},
	 { "Colorspace__name", _wrap_Colorspace__name, METH_O, NULL},
	 { "Colorspace_swigregister", Colorspace_swigregister, METH_O, NULL},
	 { "Colorspace_swiginit", Colorspace_swiginit, METH_VARARGS, NULL},
	 { "new_Device", _wrap_new_Device, METH_VARARGS, NULL},
	 { "delete_Device", _wrap_delete_Device, METH_O, NULL},
	 { "Device_swigregister", Device_swigregister, METH_O, NULL},
	 { "Device_swiginit", Device_swiginit, METH_VARARGS, NULL},
	 { "Outline_uri", _wrap_Outline_uri, METH_O, NULL},
	 { "Outline_next", _wrap_Outline_next, METH_O, NULL},
	 { "Outline_down", _wrap_Outline_down, METH_O, NULL},
	 { "Outline_isExternal", _wrap_Outline_isExternal, METH_O, NULL},
	 { "Outline_page", _wrap_Outline_page, METH_O, NULL},
	 { "Outline_x", _wrap_Outline_x, METH_O, NULL},
	 { "Outline_y", _wrap_Outline_y, METH_O, NULL},
	 { "Outline_title", _wrap_Outline_title, METH_O, NULL},
	 { "Outline_is_open", _wrap_Outline_is_open, METH_O, NULL},
	 { "delete_Outline", _wrap_delete_Outline, METH_O, NULL},
	 { "Outline_swigregister", Outline_swigregister, METH_O, NULL},
	 { "delete_Annot", _wrap_delete_Annot, METH_O, NULL},
	 { "Annot_rect", _wrap_Annot_rect, METH_O, NULL},
	 { "Annot_xref", _wrap_Annot_xref, METH_O, NULL},
	 { "Annot_apn_matrix", _wrap_Annot_apn_matrix, METH_O, NULL},
	 { "Annot_apn_bbox", _wrap_Annot_apn_bbox, METH_O, NULL},
	 { "Annot_set_apn_matrix", _wrap_Annot_set_apn_matrix, METH_VARARGS, NULL},
	 { "Annot_set_apn_bbox", _wrap_Annot_set_apn_bbox, METH_VARARGS, NULL},
	 { "Annot_blendmode", _wrap_Annot_blendmode, METH_O, NULL},
	 { "Annot_set_blendmode", _wrap_Annot_set_blendmode, METH_VARARGS, NULL},
	 { "Annot_get_oc", _wrap_Annot_get_oc, METH_O, NULL},
	 { "Annot_set_open", _wrap_Annot_set_open, METH_VARARGS, NULL},
	 { "Annot_is_open", _wrap_Annot_is_open, METH_O, NULL},
	 { "Annot_has_popup", _wrap_Annot_has_popup, METH_O, NULL},
	 { "Annot_set_popup", _wrap_Annot_set_popup, METH_VARARGS, NULL},
	 { "Annot_popup_rect", _wrap_Annot_popup_rect, METH_O, NULL},
	 { "Annot_popup_xref", _wrap_Annot_popup_xref, METH_O, NULL},
	 { "Annot_set_oc", _wrap_Annot_set_oc, METH_VARARGS, NULL},
	 { "Annot_language", _wrap_Annot_language, METH_O, NULL},
	 { "Annot_set_language", _wrap_Annot_set_language, METH_VARARGS, NULL},
	 { "Annot__getAP", _wrap_Annot__getAP, METH_O, NULL},
	 { "Annot__setAP", _wrap_Annot__setAP, METH_VARARGS, NULL},
	 { "Annot__get_redact_values", _wrap_Annot__get_redact_values, METH_O, NULL},
	 { "Annot_get_textpage", _wrap_Annot_get_textpage, METH_VARARGS, NULL},
	 { "Annot_set_name", _wrap_Annot_set_name, METH_VARARGS, NULL},
	 { "Annot_set_rect", _wrap_Annot_set_rect, METH_VARARGS, NULL},
	 { "Annot_set_rotation", _wrap_Annot_set_rotation, METH_VARARGS, NULL},
	 { "Annot_rotation", _wrap_Annot_rotation, METH_O, NULL},
	 { "Annot_vertices", _wrap_Annot_vertices, METH_O, NULL},
	 { "Annot_colors", _wrap_Annot_colors, METH_O, NULL},
	 { "Annot__update_appearance", _wrap_Annot__update_appearance, METH_VARARGS, NULL},
	 { "Annot_set_colors", _wrap_Annot_set_colors, METH_VARARGS, NULL},
	 { "Annot_line_ends", _wrap_Annot_line_ends, METH_O, NULL},
	 { "Annot_set_line_ends", _wrap_Annot_set_line_ends, METH_VARARGS, NULL},
	 { "Annot_type", _wrap_Annot_type, METH_O, NULL},
	 { "Annot_opacity", _wrap_Annot_opacity, METH_O, NULL},
	 { "Annot_set_opacity", _wrap_Annot_set_opacity, METH_VARARGS, NULL},
	 { "Annot_file_info", _wrap_Annot_file_info, METH_O, NULL},
	 { "Annot_get_file", _wrap_Annot_get_file, METH_O, NULL},
	 { "Annot_get_sound", _wrap_Annot_get_sound, METH_O, NULL},
	 { "Annot_update_file", _wrap_Annot_update_file, METH_VARARGS, NULL},
	 { "Annot_info", _wrap_Annot_info, METH_O, NULL},
	 { "Annot_set_info", _wrap_Annot_set_info, METH_VARARGS, NULL},
	 { "Annot_border", _wrap_Annot_border, METH_O, NULL},
	 { "Annot_set_border", _wrap_Annot_set_border, METH_VARARGS, NULL},
	 { "Annot_flags", _wrap_Annot_flags, METH_O, NULL},
	 { "Annot_clean_contents", _wrap_Annot_clean_contents, METH_VARARGS, NULL},
	 { "Annot_set_flags", _wrap_Annot_set_flags, METH_VARARGS, NULL},
	 { "Annot_delete_responses", _wrap_Annot_delete_responses, METH_O, NULL},
	 { "Annot_next", _wrap_Annot_next, METH_O, NULL},
	 { "Annot_get_pixmap", _wrap_Annot_get_pixmap, METH_VARARGS, NULL},
	 { "Annot_swigregister", Annot_swigregister, METH_O, NULL},
	 { "delete_Link", _wrap_delete_Link, METH_O, NULL},
	 { "Link__border", _wrap_Link__border, METH_VARARGS, NULL},
	 { "Link__setBorder", _wrap_Link__setBorder, METH_VARARGS, NULL},
	 { "Link__colors", _wrap_Link__colors, METH_VARARGS, NULL},
	 { "Link__setColors", _wrap_Link__setColors, METH_VARARGS, NULL},
	 { "Link_uri", _wrap_Link_uri, METH_O, NULL},
	 { "Link_isExternal", _wrap_Link_isExternal, METH_O, NULL},
	 { "Link_rect", _wrap_Link_rect, METH_O, NULL},
	 { "Link_next", _wrap_Link_next, METH_O, NULL},
	 { "Link_swigregister", Link_swigregister, METH_O, NULL},
	 { "delete_DisplayList", _wrap_delete_DisplayList, METH_O, NULL},
	 { "new_DisplayList", _wrap_new_DisplayList, METH_O, NULL},
	 { "DisplayList_run", _wrap_DisplayList_run, METH_VARARGS, NULL},
	 { "DisplayList_rect", _wrap_DisplayList_rect, METH_O, NULL},
	 { "DisplayList_get_pixmap", _wrap_DisplayList_get_pixmap, METH_VARARGS, NULL},
	 { "DisplayList_get_textpage", _wrap_DisplayList_get_textpage, METH_VARARGS, NULL},
	 { "DisplayList_swigregister", DisplayList_swigregister, METH_O, NULL},
	 { "DisplayList_swiginit", DisplayList_swiginit, METH_VARARGS, NULL},
	 { "delete_TextPage", _wrap_delete_TextPage, METH_O, NULL},
	 { "new_TextPage", _wrap_new_TextPage, METH_O, NULL},
	 { "TextPage_search", _wrap_TextPage_search, METH_VARARGS, NULL},
	 { "TextPage__getNewBlockList", _wrap_TextPage__getNewBlockList, METH_VARARGS, NULL},
	 { "TextPage_extractIMGINFO", _wrap_TextPage_extractIMGINFO, METH_VARARGS, NULL},
	 { "TextPage_extractBLOCKS", _wrap_TextPage_extractBLOCKS, METH_O, NULL},
	 { "TextPage_extractWORDS", _wrap_TextPage_extractWORDS, METH_O, NULL},
	 { "TextPage_rect", _wrap_TextPage_rect, METH_O, NULL},
	 { "TextPage__extractText", _wrap_TextPage__extractText, METH_VARARGS, NULL},
	 { "TextPage_extractSelection", _wrap_TextPage_extractSelection, METH_VARARGS, NULL},
	 { "TextPage_swigregister", TextPage_swigregister, METH_O, NULL},
	 { "TextPage_swiginit", TextPage_swiginit, METH_VARARGS, NULL},
	 { "delete_Graftmap", _wrap_delete_Graftmap, METH_O, NULL},
	 { "new_Graftmap", _wrap_new_Graftmap, METH_O, NULL},
	 { "Graftmap_swigregister", Graftmap_swigregister, METH_O, NULL},
	 { "Graftmap_swiginit", Graftmap_swiginit, METH_VARARGS, NULL},
	 { "delete_TextWriter", _wrap_delete_TextWriter, METH_O, NULL},
	 { "new_TextWriter", _wrap_new_TextWriter, METH_VARARGS, NULL},
	 { "TextWriter_append", _wrap_TextWriter_append, METH_VARARGS, NULL},
	 { "TextWriter__bbox", _wrap_TextWriter__bbox, METH_O, NULL},
	 { "TextWriter_write_text", _wrap_TextWriter_write_text, METH_VARARGS, NULL},
	 { "TextWriter_swigregister", TextWriter_swigregister, METH_O, NULL},
	 { "TextWriter_swiginit", TextWriter_swiginit, METH_VARARGS, NULL},
	 { "delete_Font", _wrap_delete_Font, METH_O, NULL},
	 { "new_Font", _wrap_new_Font, METH_VARARGS, NULL},
	 { "Font_glyph_advance", _wrap_Font_glyph_advance, METH_VARARGS, NULL},
	 { "Font_glyph_bbox", _wrap_Font_glyph_bbox, METH_VARARGS, NULL},
	 { "Font_has_glyph", _wrap_Font_has_glyph, METH_VARARGS, NULL},
	 { "Font__valid_unicodes", _wrap_Font__valid_unicodes, METH_VARARGS, NULL},
	 { "Font_flags", _wrap_Font_flags, METH_O, NULL},
	 { "Font_is_writable", _wrap_Font_is_writable, METH_O, NULL},
	 { "Font_name", _wrap_Font_name, METH_O, NULL},
	 { "Font_glyph_count", _wrap_Font_glyph_count, METH_O, NULL},
	 { "Font_buffer", _wrap_Font_buffer, METH_O, NULL},
	 { "Font_bbox", _wrap_Font_bbox, METH_O, NULL},
	 { "Font_ascender", _wrap_Font_ascender, METH_O, NULL},
	 { "Font_descender", _wrap_Font_descender, METH_O, NULL},
	 { "Font_swigregister", Font_swigregister, METH_O, NULL},
	 { "Font_swiginit", Font_swiginit, METH_VARARGS, NULL},
	 { "Tools_gen_id", _wrap_Tools_gen_id, METH_O, NULL},
	 { "Tools_set_icc", _wrap_Tools_set_icc, METH_VARARGS, NULL},
	 { "Tools_set_annot_stem", _wrap_Tools_set_annot_stem, METH_VARARGS, NULL},
	 { "Tools_set_small_glyph_heights", _wrap_Tools_set_small_glyph_heights, METH_VARARGS, NULL},
	 { "Tools_set_subset_fontnames", _wrap_Tools_set_subset_fontnames, METH_VARARGS, NULL},
	 { "Tools_unset_quad_corrections", _wrap_Tools_unset_quad_corrections, METH_VARARGS, NULL},
	 { "Tools_store_shrink", _wrap_Tools_store_shrink, METH_VARARGS, NULL},
	 { "Tools_store_size", _wrap_Tools_store_size, METH_O, NULL},
	 { "Tools_store_maxsize", _wrap_Tools_store_maxsize, METH_O, NULL},
	 { "Tools_show_aa_level", _wrap_Tools_show_aa_level, METH_O, NULL},
	 { "Tools_set_aa_level", _wrap_Tools_set_aa_level, METH_VARARGS, NULL},
	 { "Tools_set_graphics_min_line_width", _wrap_Tools_set_graphics_min_line_width, METH_VARARGS, NULL},
	 { "Tools_image_profile", _wrap_Tools_image_profile, METH_VARARGS, NULL},
	 { "Tools__rotate_matrix", _wrap_Tools__rotate_matrix, METH_VARARGS, NULL},
	 { "Tools__derotate_matrix", _wrap_Tools__derotate_matrix, METH_VARARGS, NULL},
	 { "Tools_fitz_config", _wrap_Tools_fitz_config, METH_O, NULL},
	 { "Tools_glyph_cache_empty", _wrap_Tools_glyph_cache_empty, METH_O, NULL},
	 { "Tools__fill_widget", _wrap_Tools__fill_widget, METH_VARARGS, NULL},
	 { "Tools__save_widget", _wrap_Tools__save_widget, METH_VARARGS, NULL},
	 { "Tools__reset_widget", _wrap_Tools__reset_widget, METH_VARARGS, NULL},
	 { "Tools__parse_da", _wrap_Tools__parse_da, METH_VARARGS, NULL},
	 { "Tools__update_da", _wrap_Tools__update_da, METH_VARARGS, NULL},
	 { "Tools__get_all_contents", _wrap_Tools__get_all_contents, METH_VARARGS, NULL},
	 { "Tools__insert_contents", _wrap_Tools__insert_contents, METH_VARARGS, NULL},
	 { "Tools_mupdf_version", _wrap_Tools_mupdf_version, METH_O, NULL},
	 { "Tools_mupdf_warnings", _wrap_Tools_mupdf_warnings, METH_VARARGS, NULL},
	 { "Tools__int_from_language", _wrap_Tools__int_from_language, METH_VARARGS, NULL},
	 { "Tools_reset_mupdf_warnings", _wrap_Tools_reset_mupdf_warnings, METH_O, NULL},
	 { "Tools_mupdf_display_errors", _wrap_Tools_mupdf_display_errors, METH_VARARGS, NULL},
	 { "Tools_mupdf_display_warnings", _wrap_Tools_mupdf_display_warnings, METH_VARARGS, NULL},
	 { "Tools__transform_rect", _wrap_Tools__transform_rect, METH_VARARGS, NULL},
	 { "Tools__intersect_rect", _wrap_Tools__intersect_rect, METH_VARARGS, NULL},
	 { "Tools__include_point_in_rect", _wrap_Tools__include_point_in_rect, METH_VARARGS, NULL},
	 { "Tools__transform_point", _wrap_Tools__transform_point, METH_VARARGS, NULL},
	 { "Tools__union_rect", _wrap_Tools__union_rect, METH_VARARGS, NULL},
	 { "Tools__concat_matrix", _wrap_Tools__concat_matrix, METH_VARARGS, NULL},
	 { "Tools__invert_matrix", _wrap_Tools__invert_matrix, METH_VARARGS, NULL},
	 { "Tools__measure_string", _wrap_Tools__measure_string, METH_VARARGS, NULL},
	 { "Tools__sine_between", _wrap_Tools__sine_between, METH_VARARGS, NULL},
	 { "Tools__hor_matrix", _wrap_Tools__hor_matrix, METH_VARARGS, NULL},
	 { "Tools__point_in_quad", _wrap_Tools__point_in_quad, METH_VARARGS, NULL},
	 { "Tools_set_font_width", _wrap_Tools_set_font_width, METH_VARARGS, NULL},
	 { "new_Tools", _wrap_new_Tools, METH_NOARGS, NULL},
	 { "delete_Tools", _wrap_delete_Tools, METH_O, NULL},
	 { "Tools_swigregister", Tools_swigregister, METH_O, NULL},
	 { "Tools_swiginit", Tools_swiginit, METH_VARARGS, NULL},
	 { NULL, NULL, 0, NULL }
};

static PyMethodDef SwigMethods_proxydocs[] = {
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_Annot = {"_p_Annot", "struct Annot *|Annot *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Colorspace = {"_p_Colorspace", "struct Colorspace *|Colorspace *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DeviceWrapper = {"_p_DeviceWrapper", "struct DeviceWrapper *|DeviceWrapper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DisplayList = {"_p_DisplayList", "struct DisplayList *|DisplayList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Document = {"_p_Document", "struct Document *|Document *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Font = {"_p_Font", "struct Font *|Font *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Graftmap = {"_p_Graftmap", "struct Graftmap *|Graftmap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Link = {"_p_Link", "struct Link *|Link *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Outline = {"_p_Outline", "struct Outline *|Outline *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Page = {"_p_Page", "struct Page *|Page *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Pixmap = {"_p_Pixmap", "struct Pixmap *|Pixmap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TextPage = {"_p_TextPage", "struct TextPage *|TextPage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TextWriter = {"_p_TextWriter", "struct TextWriter *|TextWriter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Tools = {"_p_Tools", "struct Tools *|Tools *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Annot,
  &_swigt__p_Colorspace,
  &_swigt__p_DeviceWrapper,
  &_swigt__p_DisplayList,
  &_swigt__p_Document,
  &_swigt__p_Font,
  &_swigt__p_Graftmap,
  &_swigt__p_Link,
  &_swigt__p_Outline,
  &_swigt__p_Page,
  &_swigt__p_Pixmap,
  &_swigt__p_TextPage,
  &_swigt__p_TextWriter,
  &_swigt__p_Tools,
  &_swigt__p_char,
};

static swig_cast_info _swigc__p_Annot[] = {  {&_swigt__p_Annot, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Colorspace[] = {  {&_swigt__p_Colorspace, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DeviceWrapper[] = {  {&_swigt__p_DeviceWrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DisplayList[] = {  {&_swigt__p_DisplayList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Document[] = {  {&_swigt__p_Document, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Font[] = {  {&_swigt__p_Font, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Graftmap[] = {  {&_swigt__p_Graftmap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Link[] = {  {&_swigt__p_Link, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Outline[] = {  {&_swigt__p_Outline, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Page[] = {  {&_swigt__p_Page, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Pixmap[] = {  {&_swigt__p_Pixmap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TextPage[] = {  {&_swigt__p_TextPage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TextWriter[] = {  {&_swigt__p_TextWriter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Tools[] = {  {&_swigt__p_Tools, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Annot,
  _swigc__p_Colorspace,
  _swigc__p_DeviceWrapper,
  _swigc__p_DisplayList,
  _swigc__p_Document,
  _swigc__p_Font,
  _swigc__p_Graftmap,
  _swigc__p_Link,
  _swigc__p_Outline,
  _swigc__p_Page,
  _swigc__p_Pixmap,
  _swigc__p_TextPage,
  _swigc__p_TextWriter,
  _swigc__p_Tools,
  _swigc__p_char,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;
    if (!type_init) {
      const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(NULL, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* ob_size */
#endif
        "swigvarlink",                      /* tp_name */
        sizeof(swig_varlinkobject),         /* tp_basicsize */
        0,                                  /* tp_itemsize */
        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
        0,                                  /* tp_print */
        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
        0,                                  /* tp_del */
        0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
        0,                                  /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
        0,                                  /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
        0,                                  /* tp_print */
#endif
#ifdef COUNT_ALLOCS
        0,                                  /* tp_allocs */
        0,                                  /* tp_frees */
        0,                                  /* tp_maxalloc */
        0,                                  /* tp_prev */
        0                                   /* tp_next */
#endif
      };
      varlink_type = tmp;
      type_init = 1;
      if (PyType_Ready(&varlink_type) < 0)
      return NULL;
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        memcpy(gv->name, name, size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *globals = 0;
    if (!globals) {
      globals = SWIG_newvarlink();
    }
    return globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (!c) continue;
      c = strstr(c, "swig_ptr: ");
      if (c) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              memcpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              memcpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
  /* -----------------------------------------------------------------------------
   * Method creation and docstring support functions
   * ----------------------------------------------------------------------------- */
  
  /* -----------------------------------------------------------------------------
   * Function to find the method definition with the correct docstring for the
   * proxy module as opposed to the low-level API
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
    /* Find the function in the modified method table */
    size_t offset = 0;
    int found = 0;
    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
        found = 1;
        break;
      }
      offset++;
    }
    /* Use the copy with the modified docstring if available */
    return found ? &SwigMethods_proxydocs[offset] : NULL;
  }
  
  /* -----------------------------------------------------------------------------
   * Wrapper of PyInstanceMethod_New() used in Python 3
   * It is exported to the generated module, used for -fastproxy
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
    if (PyCFunction_Check(func)) {
      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
      if (ml)
      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
    }
#if PY_VERSION_HEX >= 0x03000000
    return PyInstanceMethod_New(func);
#else
    return PyMethod_New(func, NULL, NULL);
#endif
  }
  
  /* -----------------------------------------------------------------------------
   * Wrapper of PyStaticMethod_New()
   * It is exported to the generated module, used for -fastproxy
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
    if (PyCFunction_Check(func)) {
      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
      if (ml)
      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
    }
    return PyStaticMethod_New(func);
  }
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md, *globals;
  
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
    PyModuleDef_HEAD_INIT,
    SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {
    0, 0, 0, 0, 0, 0, 0
  };
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    SwigPyObject_own,
    SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  PyTypeObject *swigpyobject;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;
  
  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;
  
  /* Metaclass is used to implement static member variables */
  metatype = SwigPyObjectType();
  assert(metatype);
#endif
  
  (void)globals;
  
  /* Create singletons now to avoid potential deadlocks with multi-threaded usage after module initialization */
  SWIG_This();
  SWIG_Python_TypeCache();
  SwigPyPacked_type();
#ifndef SWIGPYTHON_BUILTIN
  SwigPyObject_type();
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule(SWIG_name, SwigMethods);
#endif
  
  md = d = PyModule_GetDict(m);
  (void)md;
  
  SWIG_InitializeModule(0);
  
#ifdef SWIGPYTHON_BUILTIN
  swigpyobject = SwigPyObject_TypeOnce();
  
  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = swigpyobject;
  } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  
  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;
  
  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;
  
  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;
  
  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif
  
  SWIG_InstallConstants(d,swig_const_table);
  
  
#if JM_MEMORY == 1
  gctx = fz_new_context(&JM_Alloc_Context, NULL, FZ_STORE_DEFAULT);
#else
  gctx = fz_new_context(NULL, NULL, FZ_STORE_DEFAULT);
#endif
  if(!gctx)
  {
    PyErr_SetString(PyExc_RuntimeError, "Fatal error: could not create global context.");
    return NULL;
  }
  fz_register_document_handlers(gctx);
  
  //------------------------------------------------------------------------
  // START redirect stdout/stderr
  //------------------------------------------------------------------------
  JM_mupdf_warnings_store = PyList_New(0);
  JM_mupdf_show_errors = 1;
  JM_mupdf_show_warnings = 0;
  char user[] = "PyMuPDF";
  fz_set_warning_callback(gctx, JM_mupdf_warning, &user);
  fz_set_error_callback(gctx, JM_mupdf_error, &user);
  //------------------------------------------------------------------------
  // STOP redirect stdout/stderr
  //------------------------------------------------------------------------
  // init global constants
  //------------------------------------------------------------------------
  dictkey_align = PyUnicode_InternFromString("align");
  dictkey_bbox = PyUnicode_InternFromString("bbox");
  dictkey_blocks = PyUnicode_InternFromString("blocks");
  dictkey_bpc = PyUnicode_InternFromString("bpc");
  dictkey_c = PyUnicode_InternFromString("c");
  dictkey_chars = PyUnicode_InternFromString("chars");
  dictkey_color = PyUnicode_InternFromString("color");
  dictkey_colorspace = PyUnicode_InternFromString("colorspace");
  dictkey_content = PyUnicode_InternFromString("content");
  dictkey_creationDate = PyUnicode_InternFromString("creationDate");
  dictkey_cs_name = PyUnicode_InternFromString("cs-name");
  dictkey_da = PyUnicode_InternFromString("da");
  dictkey_dashes = PyUnicode_InternFromString("dashes");
  dictkey_desc = PyUnicode_InternFromString("desc");
  dictkey_dir = PyUnicode_InternFromString("dir");
  dictkey_effect = PyUnicode_InternFromString("effect");
  dictkey_ext = PyUnicode_InternFromString("ext");
  dictkey_filename = PyUnicode_InternFromString("filename");
  dictkey_fill = PyUnicode_InternFromString("fill");
  dictkey_flags = PyUnicode_InternFromString("flags");
  dictkey_font = PyUnicode_InternFromString("font");
  dictkey_height = PyUnicode_InternFromString("height");
  dictkey_id = PyUnicode_InternFromString("id");
  dictkey_image = PyUnicode_InternFromString("image");
  dictkey_length = PyUnicode_InternFromString("length");
  dictkey_lines = PyUnicode_InternFromString("lines");
  dictkey_matrix = PyUnicode_InternFromString("transform");
  dictkey_modDate = PyUnicode_InternFromString("modDate");
  dictkey_name = PyUnicode_InternFromString("name");
  dictkey_number = PyUnicode_InternFromString("number");
  dictkey_origin = PyUnicode_InternFromString("origin");
  dictkey_size = PyUnicode_InternFromString("size");
  dictkey_smask = PyUnicode_InternFromString("smask");
  dictkey_spans = PyUnicode_InternFromString("spans");
  dictkey_stroke = PyUnicode_InternFromString("stroke");
  dictkey_style = PyUnicode_InternFromString("style");
  dictkey_subject = PyUnicode_InternFromString("subject");
  dictkey_text = PyUnicode_InternFromString("text");
  dictkey_title = PyUnicode_InternFromString("title");
  dictkey_type = PyUnicode_InternFromString("type");
  dictkey_ufilename = PyUnicode_InternFromString("ufilename");
  dictkey_width = PyUnicode_InternFromString("width");
  dictkey_wmode = PyUnicode_InternFromString("wmode");
  dictkey_xref = PyUnicode_InternFromString("xref");
  dictkey_xres = PyUnicode_InternFromString("xres");
  dictkey_yres = PyUnicode_InternFromString("yres");
  
  SWIG_Python_SetConstant(d, "EPSILON",SWIG_From_double((double)(1e-5)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_TEXT",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LINK",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_FREE_TEXT",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LINE",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_SQUARE",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_CIRCLE",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_POLYGON",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_POLY_LINE",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_HIGHLIGHT",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_UNDERLINE",SWIG_From_int((int)(9)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_SQUIGGLY",SWIG_From_int((int)(10)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_STRIKE_OUT",SWIG_From_int((int)(11)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_REDACT",SWIG_From_int((int)(12)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_STAMP",SWIG_From_int((int)(13)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_CARET",SWIG_From_int((int)(14)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_INK",SWIG_From_int((int)(15)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_POPUP",SWIG_From_int((int)(16)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_FILE_ATTACHMENT",SWIG_From_int((int)(17)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_SOUND",SWIG_From_int((int)(18)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_MOVIE",SWIG_From_int((int)(19)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_RICH_MEDIA",SWIG_From_int((int)(20)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_WIDGET",SWIG_From_int((int)(21)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_SCREEN",SWIG_From_int((int)(22)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_PRINTER_MARK",SWIG_From_int((int)(23)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_TRAP_NET",SWIG_From_int((int)(24)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_WATERMARK",SWIG_From_int((int)(25)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_3D",SWIG_From_int((int)(26)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_PROJECTION",SWIG_From_int((int)(27)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_UNKNOWN",SWIG_From_int((int)(-1)));
  SWIG_Python_SetConstant(d, "PDF_REDACT_IMAGE_NONE",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "PDF_REDACT_IMAGE_REMOVE",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_REDACT_IMAGE_PIXELS",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_INVISIBLE",SWIG_From_int((int)(1 << (1-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_HIDDEN",SWIG_From_int((int)(1 << (2-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_PRINT",SWIG_From_int((int)(1 << (3-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_NO_ZOOM",SWIG_From_int((int)(1 << (4-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_NO_ROTATE",SWIG_From_int((int)(1 << (5-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_NO_VIEW",SWIG_From_int((int)(1 << (6-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_READ_ONLY",SWIG_From_int((int)(1 << (7-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_LOCKED",SWIG_From_int((int)(1 << (8-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_TOGGLE_NO_VIEW",SWIG_From_int((int)(1 << (9-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_IS_LOCKED_CONTENTS",SWIG_From_int((int)(1 << (10-1))));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_NONE",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_SQUARE",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_CIRCLE",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_DIAMOND",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_OPEN_ARROW",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_CLOSED_ARROW",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_BUTT",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_R_OPEN_ARROW",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_R_CLOSED_ARROW",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "PDF_ANNOT_LE_SLASH",SWIG_From_int((int)(9)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_UNKNOWN",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_BUTTON",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_CHECKBOX",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_COMBOBOX",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_LISTBOX",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_RADIOBUTTON",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_SIGNATURE",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TYPE_TEXT",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TX_FORMAT_NONE",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TX_FORMAT_NUMBER",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TX_FORMAT_SPECIAL",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TX_FORMAT_DATE",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_WIDGET_TX_FORMAT_TIME",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "PDF_FIELD_IS_READ_ONLY",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_FIELD_IS_REQUIRED",SWIG_From_int((int)(1 << 1)));
  SWIG_Python_SetConstant(d, "PDF_FIELD_IS_NO_EXPORT",SWIG_From_int((int)(1 << 2)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_MULTILINE",SWIG_From_int((int)(1 << 12)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_PASSWORD",SWIG_From_int((int)(1 << 13)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_FILE_SELECT",SWIG_From_int((int)(1 << 20)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK",SWIG_From_int((int)(1 << 22)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_DO_NOT_SCROLL",SWIG_From_int((int)(1 << 23)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_COMB",SWIG_From_int((int)(1 << 24)));
  SWIG_Python_SetConstant(d, "PDF_TX_FIELD_IS_RICH_TEXT",SWIG_From_int((int)(1 << 25)));
  SWIG_Python_SetConstant(d, "PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF",SWIG_From_int((int)(1 << 14)));
  SWIG_Python_SetConstant(d, "PDF_BTN_FIELD_IS_RADIO",SWIG_From_int((int)(1 << 15)));
  SWIG_Python_SetConstant(d, "PDF_BTN_FIELD_IS_PUSHBUTTON",SWIG_From_int((int)(1 << 16)));
  SWIG_Python_SetConstant(d, "PDF_BTN_FIELD_IS_RADIOS_IN_UNISON",SWIG_From_int((int)(1 << 25)));
  SWIG_Python_SetConstant(d, "PDF_CH_FIELD_IS_COMBO",SWIG_From_int((int)(1 << 17)));
  SWIG_Python_SetConstant(d, "PDF_CH_FIELD_IS_EDIT",SWIG_From_int((int)(1 << 18)));
  SWIG_Python_SetConstant(d, "PDF_CH_FIELD_IS_SORT",SWIG_From_int((int)(1 << 19)));
  SWIG_Python_SetConstant(d, "PDF_CH_FIELD_IS_MULTI_SELECT",SWIG_From_int((int)(1 << 21)));
  SWIG_Python_SetConstant(d, "PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK",SWIG_From_int((int)(1 << 22)));
  SWIG_Python_SetConstant(d, "PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE",SWIG_From_int((int)(1 << 26)));
  SWIG_Python_SetConstant(d, "PDF_SIGNATURE_ERROR_OKAY",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "PDF_SIGNATURE_ERROR_NO_SIGNATURES",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_SIGNATURE_ERROR_NO_CERTIFICATE",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "PDF_SIGNATURE_ERROR_DIGEST_FAILURE",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_SIGNATURE_ERROR_SELF_SIGNED",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "PDF_SIGNATURE_ERROR_SELF_SIGNED_IN_CHAIN",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "PDF_SIGNATURE_ERROR_NOT_TRUSTED",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "PDF_SIGNATURE_ERROR_UNKNOWN",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "CS_RGB",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "CS_GRAY",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "CS_CMYK",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_KEEP",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_NONE",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_RC4_40",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_RC4_128",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_AES_128",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_AES_256",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "PDF_ENCRYPT_UNKNOWN",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "PDF_PERM_PRINT",SWIG_From_int((int)(1 << 2)));
  SWIG_Python_SetConstant(d, "PDF_PERM_MODIFY",SWIG_From_int((int)(1 << 3)));
  SWIG_Python_SetConstant(d, "PDF_PERM_COPY",SWIG_From_int((int)(1 << 4)));
  SWIG_Python_SetConstant(d, "PDF_PERM_ANNOTATE",SWIG_From_int((int)(1 << 5)));
  SWIG_Python_SetConstant(d, "PDF_PERM_FORM",SWIG_From_int((int)(1 << 8)));
  SWIG_Python_SetConstant(d, "PDF_PERM_ACCESSIBILITY",SWIG_From_int((int)(1 << 9)));
  SWIG_Python_SetConstant(d, "PDF_PERM_ASSEMBLE",SWIG_From_int((int)(1 << 10)));
  SWIG_Python_SetConstant(d, "PDF_PERM_PRINT_HQ",SWIG_From_int((int)(1 << 11)));
  SWIG_Python_SetConstant(d, "PDF_BM_Color",SWIG_FromCharPtr("Color"));
  SWIG_Python_SetConstant(d, "PDF_BM_ColorBurn",SWIG_FromCharPtr("ColorBurn"));
  SWIG_Python_SetConstant(d, "PDF_BM_ColorDodge",SWIG_FromCharPtr("ColorDodge"));
  SWIG_Python_SetConstant(d, "PDF_BM_Darken",SWIG_FromCharPtr("Darken"));
  SWIG_Python_SetConstant(d, "PDF_BM_Difference",SWIG_FromCharPtr("Difference"));
  SWIG_Python_SetConstant(d, "PDF_BM_Exclusion",SWIG_FromCharPtr("Exclusion"));
  SWIG_Python_SetConstant(d, "PDF_BM_HardLight",SWIG_FromCharPtr("HardLight"));
  SWIG_Python_SetConstant(d, "PDF_BM_Hue",SWIG_FromCharPtr("Hue"));
  SWIG_Python_SetConstant(d, "PDF_BM_Lighten",SWIG_FromCharPtr("Lighten"));
  SWIG_Python_SetConstant(d, "PDF_BM_Luminosity",SWIG_FromCharPtr("Luminosity"));
  SWIG_Python_SetConstant(d, "PDF_BM_Multiply",SWIG_FromCharPtr("Multiply"));
  SWIG_Python_SetConstant(d, "PDF_BM_Normal",SWIG_FromCharPtr("Normal"));
  SWIG_Python_SetConstant(d, "PDF_BM_Overlay",SWIG_FromCharPtr("Overlay"));
  SWIG_Python_SetConstant(d, "PDF_BM_Saturation",SWIG_FromCharPtr("Saturation"));
  SWIG_Python_SetConstant(d, "PDF_BM_Screen",SWIG_FromCharPtr("Screen"));
  SWIG_Python_SetConstant(d, "PDF_BM_SoftLight",SWIG_FromCharPtr("Softlight"));
  SWIG_Python_SetConstant(d, "TEXT_FONT_SUPERSCRIPT",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "TEXT_FONT_ITALIC",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "TEXT_FONT_SERIFED",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "TEXT_FONT_MONOSPACED",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "TEXT_FONT_BOLD",SWIG_From_int((int)(16)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_COMMON",SWIG_From_int((int)(0)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_LATIN",SWIG_From_int((int)(1)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_GREEK",SWIG_From_int((int)(2)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_CYRILLIC",SWIG_From_int((int)(3)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_ARMENIAN",SWIG_From_int((int)(4)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_HEBREW",SWIG_From_int((int)(5)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_ARABIC",SWIG_From_int((int)(6)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SYRIAC",SWIG_From_int((int)(7)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_THAANA",SWIG_From_int((int)(8)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_DEVANAGARI",SWIG_From_int((int)(9)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_BENGALI",SWIG_From_int((int)(10)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_GURMUKHI",SWIG_From_int((int)(11)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_GUJARATI",SWIG_From_int((int)(12)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_ORIYA",SWIG_From_int((int)(13)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_TAMIL",SWIG_From_int((int)(14)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_TELUGU",SWIG_From_int((int)(15)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_KANNADA",SWIG_From_int((int)(16)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MALAYALAM",SWIG_From_int((int)(17)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SINHALA",SWIG_From_int((int)(18)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_THAI",SWIG_From_int((int)(19)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_LAO",SWIG_From_int((int)(20)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_TIBETAN",SWIG_From_int((int)(21)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MYANMAR",SWIG_From_int((int)(22)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_GEORGIAN",SWIG_From_int((int)(23)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_HANGUL",SWIG_From_int((int)(24)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_ETHIOPIC",SWIG_From_int((int)(25)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_CHEROKEE",SWIG_From_int((int)(26)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_CANADIAN_ABORIGINAL",SWIG_From_int((int)(27)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_OGHAM",SWIG_From_int((int)(28)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_RUNIC",SWIG_From_int((int)(29)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_KHMER",SWIG_From_int((int)(30)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MONGOLIAN",SWIG_From_int((int)(31)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_HIRAGANA",SWIG_From_int((int)(32)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_KATAKANA",SWIG_From_int((int)(33)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_BOPOMOFO",SWIG_From_int((int)(34)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_HAN",SWIG_From_int((int)(35)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_YI",SWIG_From_int((int)(36)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_OLD_ITALIC",SWIG_From_int((int)(37)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_GOTHIC",SWIG_From_int((int)(38)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_DESERET",SWIG_From_int((int)(39)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_INHERITED",SWIG_From_int((int)(40)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_TAGALOG",SWIG_From_int((int)(41)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_HANUNOO",SWIG_From_int((int)(42)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_BUHID",SWIG_From_int((int)(43)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_TAGBANWA",SWIG_From_int((int)(44)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_LIMBU",SWIG_From_int((int)(45)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_TAI_LE",SWIG_From_int((int)(46)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_LINEAR_B",SWIG_From_int((int)(47)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_UGARITIC",SWIG_From_int((int)(48)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SHAVIAN",SWIG_From_int((int)(49)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_OSMANYA",SWIG_From_int((int)(50)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_CYPRIOT",SWIG_From_int((int)(51)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_BRAILLE",SWIG_From_int((int)(52)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_BUGINESE",SWIG_From_int((int)(53)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_COPTIC",SWIG_From_int((int)(54)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_NEW_TAI_LUE",SWIG_From_int((int)(55)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_GLAGOLITIC",SWIG_From_int((int)(56)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_TIFINAGH",SWIG_From_int((int)(57)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SYLOTI_NAGRI",SWIG_From_int((int)(58)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_OLD_PERSIAN",SWIG_From_int((int)(59)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_KHAROSHTHI",SWIG_From_int((int)(60)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_BALINESE",SWIG_From_int((int)(61)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_CUNEIFORM",SWIG_From_int((int)(62)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_PHOENICIAN",SWIG_From_int((int)(63)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_PHAGS_PA",SWIG_From_int((int)(64)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_NKO",SWIG_From_int((int)(65)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SUNDANESE",SWIG_From_int((int)(66)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_LEPCHA",SWIG_From_int((int)(67)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_OL_CHIKI",SWIG_From_int((int)(68)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_VAI",SWIG_From_int((int)(69)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SAURASHTRA",SWIG_From_int((int)(70)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_KAYAH_LI",SWIG_From_int((int)(71)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_REJANG",SWIG_From_int((int)(72)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_LYCIAN",SWIG_From_int((int)(73)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_CARIAN",SWIG_From_int((int)(74)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_LYDIAN",SWIG_From_int((int)(75)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_CHAM",SWIG_From_int((int)(76)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_TAI_THAM",SWIG_From_int((int)(77)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_TAI_VIET",SWIG_From_int((int)(78)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_AVESTAN",SWIG_From_int((int)(79)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_EGYPTIAN_HIEROGLYPHS",SWIG_From_int((int)(80)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SAMARITAN",SWIG_From_int((int)(81)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_LISU",SWIG_From_int((int)(82)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_BAMUM",SWIG_From_int((int)(83)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_JAVANESE",SWIG_From_int((int)(84)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MEETEI_MAYEK",SWIG_From_int((int)(85)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_IMPERIAL_ARAMAIC",SWIG_From_int((int)(86)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_OLD_SOUTH_ARABIAN",SWIG_From_int((int)(87)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_INSCRIPTIONAL_PARTHIAN",SWIG_From_int((int)(88)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_INSCRIPTIONAL_PAHLAVI",SWIG_From_int((int)(89)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_OLD_TURKIC",SWIG_From_int((int)(90)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_KAITHI",SWIG_From_int((int)(91)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_BATAK",SWIG_From_int((int)(92)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_BRAHMI",SWIG_From_int((int)(93)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MANDAIC",SWIG_From_int((int)(94)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_CHAKMA",SWIG_From_int((int)(95)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MEROITIC_CURSIVE",SWIG_From_int((int)(96)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MEROITIC_HIEROGLYPHS",SWIG_From_int((int)(97)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MIAO",SWIG_From_int((int)(98)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SHARADA",SWIG_From_int((int)(99)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SORA_SOMPENG",SWIG_From_int((int)(100)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_TAKRI",SWIG_From_int((int)(101)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_UNKNOWN",SWIG_From_int((int)(102)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_BASSA_VAH",SWIG_From_int((int)(103)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_CAUCASIAN_ALBANIAN",SWIG_From_int((int)(104)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_DUPLOYAN",SWIG_From_int((int)(105)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_ELBASAN",SWIG_From_int((int)(106)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_GRANTHA",SWIG_From_int((int)(107)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_KHOJKI",SWIG_From_int((int)(108)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_KHUDAWADI",SWIG_From_int((int)(109)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_LINEAR_A",SWIG_From_int((int)(110)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MAHAJANI",SWIG_From_int((int)(111)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MANICHAEAN",SWIG_From_int((int)(112)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MENDE_KIKAKUI",SWIG_From_int((int)(113)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MODI",SWIG_From_int((int)(114)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MRO",SWIG_From_int((int)(115)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_NABATAEAN",SWIG_From_int((int)(116)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_OLD_NORTH_ARABIAN",SWIG_From_int((int)(117)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_OLD_PERMIC",SWIG_From_int((int)(118)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_PAHAWH_HMONG",SWIG_From_int((int)(119)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_PALMYRENE",SWIG_From_int((int)(120)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_PAU_CIN_HAU",SWIG_From_int((int)(121)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_PSALTER_PAHLAVI",SWIG_From_int((int)(122)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SIDDHAM",SWIG_From_int((int)(123)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_TIRHUTA",SWIG_From_int((int)(124)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_WARANG_CITI",SWIG_From_int((int)(125)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_AHOM",SWIG_From_int((int)(126)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_ANATOLIAN_HIEROGLYPHS",SWIG_From_int((int)(127)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_HATRAN",SWIG_From_int((int)(128)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MULTANI",SWIG_From_int((int)(129)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_OLD_HUNGARIAN",SWIG_From_int((int)(130)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SIGNWRITING",SWIG_From_int((int)(131)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_ADLAM",SWIG_From_int((int)(132)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_BHAIKSUKI",SWIG_From_int((int)(133)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MARCHEN",SWIG_From_int((int)(134)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_NEWA",SWIG_From_int((int)(135)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_OSAGE",SWIG_From_int((int)(136)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_TANGUT",SWIG_From_int((int)(137)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MASARAM_GONDI",SWIG_From_int((int)(138)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_NUSHU",SWIG_From_int((int)(139)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SOYOMBO",SWIG_From_int((int)(140)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_ZANABAZAR_SQUARE",SWIG_From_int((int)(141)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_DOGRA",SWIG_From_int((int)(142)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_GUNJALA_GONDI",SWIG_From_int((int)(143)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_HANIFI_ROHINGYA",SWIG_From_int((int)(144)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MAKASAR",SWIG_From_int((int)(145)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_MEDEFAIDRIN",SWIG_From_int((int)(146)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_OLD_SOGDIAN",SWIG_From_int((int)(147)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_SOGDIAN",SWIG_From_int((int)(148)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_ELYMAIC",SWIG_From_int((int)(149)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_NANDINAGARI",SWIG_From_int((int)(150)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_NYIAKENG_PUACHUE_HMONG",SWIG_From_int((int)(151)));
  SWIG_Python_SetConstant(d, "UCDN_SCRIPT_WANCHO",SWIG_From_int((int)(152)));
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}

